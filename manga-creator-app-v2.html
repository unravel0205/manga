<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>漫画クリエイター</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3b82f6',
            secondary: '#f97316',
          }
        }
      }
    }
  </script>
  <style>
    .tooltip {
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s, visibility 0.2s;
    }
    .tooltip-trigger:hover .tooltip,
    .tooltip-trigger:focus .tooltip {
      visibility: visible;
      opacity: 1;
    }
    .scrollbar-thin::-webkit-scrollbar {
      height: 6px;
    }
    .scrollbar-thin::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }
    .scrollbar-thin::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="app"></div>

  <script type="module">
    import { createRoot } from 'https://esm.sh/react-dom@18/client';
    import React, { useState, useEffect, useRef } from 'https://esm.sh/react@18';
    import htm from 'https://esm.sh/htm';

    const html = htm.bind(React.createElement);

    // ヘルプアイコンコンポーネント
    function HelpIcon({ text }) {
      return html`
        <div class="tooltip-trigger relative inline-block ml-2">
          <div class="w-5 h-5 bg-gray-200 rounded-full flex items-center justify-center cursor-help text-xs text-gray-600 font-bold hover:bg-gray-300">
            ?
          </div>
          <div class="tooltip absolute z-50 w-72 p-3 bg-gray-800 text-white text-sm rounded-lg shadow-lg -left-32 top-8">
            <div class="absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-gray-800"></div>
            <div class="whitespace-pre-wrap">${text}</div>
          </div>
        </div>
      `;
    }

    // スタイルデータ
    const STYLES = [
      { id: 1, name: 'ビジネス説明マンガ風', description: 'パステルカラーで信頼感のある、企業の説明資料に最適なスタイル', prompt: 'Japanese business explainer manga style. Pastel color palette (pink, light purple, pale blue). Slightly shoujo manga influenced but mature, not childish. Trustworthy and professional atmosphere.' },
      { id: 2, name: '少年漫画風', description: '太い線と力強い表現。アクションやスポーツ系の内容に', prompt: 'Japanese shonen manga style. Dynamic lines, bold colors, energetic atmosphere. Action-oriented with strong contrast and impact lines.' },
      { id: 3, name: '少女漫画風', description: '繊細な線とキラキラ効果。恋愛や感情表現豊かな内容に', prompt: 'Japanese shoujo manga style. Soft lines, sparkly effects, romantic atmosphere. Delicate expressions with flower motifs and screen tones.' },
      { id: 4, name: 'シンプル線画風', description: 'ミニマルでスッキリ。図解や手順説明に最適', prompt: 'Minimalist line art style. Clean black outlines with flat colors or white space. Simple and modern aesthetic.' },
      { id: 5, name: 'アメコミ風', description: 'ポップで派手な色使い。インパクト重視の内容に', prompt: 'American comic book style. Bold outlines, vibrant saturated colors, halftone dots. Pop art influenced with strong shadows.' },
      { id: 6, name: '水彩イラスト風', description: '柔らかく芸術的。エッセイや物語調の内容に', prompt: 'Watercolor illustration style. Soft edges, blended colors, artistic and gentle atmosphere. Hand-painted texture.' },
      { id: 7, name: 'レトロ漫画風', description: '昭和の懐かしい雰囲気。歴史や昔話の内容に', prompt: 'Retro Japanese manga style (1970s-80s). Nostalgic coloring, classic screen tones, vintage aesthetic.' },
      { id: 8, name: 'Webtoon風', description: '現代的でクリーン。SNS向けコンテンツに', prompt: 'Korean webtoon style. Clean digital art, soft shading, modern character designs. Bright and appealing colors.' },
      { id: 9, name: '絵本イラスト風', description: '温かみのある丸い絵柄。子ども向けや教育コンテンツに', prompt: 'Picture book illustration style. Warm and friendly, rounded shapes, gentle colors. Suitable for all ages.' },
      { id: 10, name: 'クール・スタイリッシュ風', description: 'モノトーン基調でおしゃれ。ファッションやライフスタイル系に', prompt: 'Cool and stylish manga style. Monochromatic base with accent colors. Sophisticated, urban, fashion-forward aesthetic.' },
    ];

    // ヘルプテキスト
    const HELP_TEXTS = {
      api: `Google AI Studioで発行したAPIキーを入力してください。
APIキーはこのブラウザ内に安全に保存され、漫画生成時にGoogleのサーバーへ送信されます。

【APIキーの取得方法】
1. Google AI Studio (aistudio.google.com) にアクセス
2. 「Get API Key」をクリック
3. 新しいキーを作成してコピー`,
      library: `よく使うキャラクター画像を保存できます。
保存したキャラクターは次回以降も使えます。

【使い方】
・「+追加」でキャラクターを登録
・キャラクター名をつけて管理
・クリックで下の選択エリアに設定
・長押しで削除`,
      character: `今回の漫画に登場するキャラクターを設定します。

【説明者（必須）】
メインで話を進めるキャラクターです。
記事の内容を読者に説明する役割を担います。

【相談者（任意）】
説明者に質問したり、相槌を打つ役割です。
設定すると2人の会話形式になります。
設定しない場合は1人語りスタイルになります。`,
      style: `漫画の絵柄（画風）を選択できます。
選んだスタイルに合わせて、線の太さ・色使い・雰囲気が変わります。

【おすすめ】
・ビジネス用途 → 「ビジネス説明マンガ風」
・若者向け → 「少年漫画風」「Webtoon風」
・女性向け → 「少女漫画風」「水彩イラスト風」
・子ども向け → 「絵本イラスト風」

★マークでお気に入り登録すると上部に表示されます。`,
      speech: `キャラクターのセリフの話し方を選択できます。

【敬語（です・ます調）】
「〜ですね」「〜しましょう」など丁寧な話し方。
ビジネス向けや公式な内容におすすめ。

【タメ口（カジュアル）】
「〜だよね」「〜しよう」など親しみやすい話し方。
SNS向けやカジュアルな内容におすすめ。`,
      story: `漫画にしたい内容を自由に入力してください。
文章量の目安は100〜500文字程度です。

【入力のコツ】
・伝えたいポイントを箇条書きでもOK
・専門用語があれば簡単な説明を添えると◎
・キャラクターの感情（驚き、納得など）を入れるとより表現豊かになります

生成後もテキストは消えないので、続きを書いて次の4コマを作ることもできます。`,
      generateCount: `同じストーリーとプロンプトで、複数パターンの漫画を生成できます。

1枚ずつ生成するので、気に入った結果が出るまで「次の1枚を生成」で追加できます。`,
    };

    // メインアプリ
    function App() {
      // State
      const [apiKey, setApiKey] = useState('');
      const [apiKeySaved, setApiKeySaved] = useState(false);
      const [showApiKey, setShowApiKey] = useState(false);
      const [characters, setCharacters] = useState([]);
      const [selectedExplainer, setSelectedExplainer] = useState(null);
      const [selectedConsultant, setSelectedConsultant] = useState(null);
      const [selectedStyle, setSelectedStyle] = useState(1);
      const [favorites, setFavorites] = useState([]);
      const [speechStyle, setSpeechStyle] = useState('formal');
      const [story, setStory] = useState('');
      const [generatedImages, setGeneratedImages] = useState([]);
      const [currentImageIndex, setCurrentImageIndex] = useState(0);
      const [isGenerating, setIsGenerating] = useState(false);
      const [error, setError] = useState('');
      const [history, setHistory] = useState([]);
      const [showHistory, setShowHistory] = useState(false);
      const [showAddCharacter, setShowAddCharacter] = useState(false);
      const [newCharacterName, setNewCharacterName] = useState('');
      const [newCharacterImage, setNewCharacterImage] = useState(null);

      // Refs
      const fileInputRef = useRef(null);
      const explainerInputRef = useRef(null);
      const consultantInputRef = useRef(null);

      // Load from localStorage
      useEffect(() => {
        const savedApiKey = localStorage.getItem('manga_api_key');
        if (savedApiKey) {
          setApiKey(savedApiKey);
          setApiKeySaved(true);
        }
        const savedCharacters = localStorage.getItem('manga_characters');
        if (savedCharacters) {
          setCharacters(JSON.parse(savedCharacters));
        }
        const savedFavorites = localStorage.getItem('manga_favorite_styles');
        if (savedFavorites) {
          setFavorites(JSON.parse(savedFavorites));
        }
        const savedHistory = localStorage.getItem('manga_history');
        if (savedHistory) {
          setHistory(JSON.parse(savedHistory));
        }
      }, []);

      // Save API key
      const saveApiKey = () => {
        localStorage.setItem('manga_api_key', apiKey);
        setApiKeySaved(true);
      };

      // Toggle favorite
      const toggleFavorite = (styleId) => {
        const newFavorites = favorites.includes(styleId)
          ? favorites.filter(id => id !== styleId)
          : [...favorites, styleId];
        setFavorites(newFavorites);
        localStorage.setItem('manga_favorite_styles', JSON.stringify(newFavorites));
      };

      // Add character to library
      const addCharacter = () => {
        if (!newCharacterName || !newCharacterImage) return;
        const newChar = {
          id: 'char_' + Date.now(),
          name: newCharacterName,
          imageBase64: newCharacterImage,
          createdAt: new Date().toISOString()
        };
        const newCharacters = [...characters, newChar];
        setCharacters(newCharacters);
        localStorage.setItem('manga_characters', JSON.stringify(newCharacters));
        setShowAddCharacter(false);
        setNewCharacterName('');
        setNewCharacterImage(null);
      };

      // Delete character
      const deleteCharacter = (charId) => {
        if (!confirm('このキャラクターを削除しますか？')) return;
        const newCharacters = characters.filter(c => c.id !== charId);
        setCharacters(newCharacters);
        localStorage.setItem('manga_characters', JSON.stringify(newCharacters));
        if (selectedExplainer?.id === charId) setSelectedExplainer(null);
        if (selectedConsultant?.id === charId) setSelectedConsultant(null);
      };

      // Handle file upload for new character
      const handleNewCharacterFile = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          setNewCharacterImage(e.target.result);
        };
        reader.readAsDataURL(file);
      };

      // Handle direct upload for explainer/consultant
      const handleDirectUpload = (e, role) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const tempChar = {
            id: 'temp_' + Date.now(),
            name: role === 'explainer' ? '説明者' : '相談者',
            imageBase64: ev.target.result,
            isTemp: true
          };
          if (role === 'explainer') {
            setSelectedExplainer(tempChar);
          } else {
            setSelectedConsultant(tempChar);
          }
        };
        reader.readAsDataURL(file);
      };

      // Generate prompt
      const generatePrompt = () => {
        const style = STYLES.find(s => s.id === selectedStyle);
        const isTwoPerson = selectedConsultant !== null;
        
        const characterCountText = isTwoPerson ? '2人のキャラクター' : '1人のキャラクター';
        
        const speechStyleText = speechStyle === 'formal' 
          ? `【セリフ・語尾のバリエーション（重要）】
・敬語（です・ます調）を基本とする
・同じ語尾が連続しないようにする
・4コマ内で最低3種類以上の語尾パターンを使い分ける
・以下から自然に混ぜる：
　問いかけ系（〜ですか？／〜でしょうか）
　説明系（〜なんです／〜ております）
　展開系（〜ですが、／実は〜／つまり〜）
　強調系（〜なのです／〜と言えます）
　締め系（〜しましょう／〜してみてください）`
          : `【セリフ・語尾のバリエーション（重要）】
・タメ口（だ・である調、カジュアル）を基本とする
・同じ語尾が連続しないようにする
・4コマ内で最低3種類以上の語尾パターンを使い分ける
・以下から自然に混ぜる：
　問いかけ系（〜だよね？／〜じゃない？／〜かな？）
　説明系（〜なんだ／〜だよ／〜ってこと）
　展開系（〜だけど、／実は〜／つまり〜）
　強調系（〜なんだよ！／〜だって！）
　締め系（〜しよう／〜してみて／〜だね）
・親しみやすく、フレンドリーなトーンで`;

        const characterRuleText = isTwoPerson
          ? `【キャラクター人数ルール】
・メインの登場人物は2人（デザインは参考画像に従う）
・1枚目の画像のキャラクター：説明役
・2枚目の画像のキャラクター：相談者役
・相談者は絶対に説明をさせないでください
・背景内の説明用イメージ人物（歴史的人物など）は別扱い

【キャラクター登場ルール】
・1コマに2人が登場しなくてもいい
・1コマに説明者のみ、相談者のみでもいい`
          : `【キャラクター人数ルール】
・登場人物は1人のみ（参考画像のキャラクター）
・読者に語りかける形式で進行
・独白・説明形式で内容を伝える`;

        return `これまでに与えられている記事内容を正確に理解したうえで、
${characterCountText}が会話形式で語るマンガを生成してください。

【参考画像への忠実度（最重要）】
・参考画像が与えられている場合は、キャラクターデザイン・絵のテイストを忠実に再現する
・顔立ち・髪型・髪色・服装・線の太さ・彩色・色調を正確に引き継ぐ
・独自のアレンジや解釈を加えすぎない

【絵のテイスト・彩色（重要）】
・線ははっきり明瞭に、色はクリアで鮮明に
・白っぽく霞んだ仕上がりにしない
・コントラストをしっかりつけ、メリハリのある画面にする
・影やハイライトで立体感を出す
・${style.prompt}

${speechStyleText}

【吹き出し・文字量のルール（重要）】
・1吹き出し：最大25文字以内
・1コマ合計：最大35文字以内
・1コマ内の吹き出しは最大2つまで
・吹き出しの配置は読み順（右上→左下）を妨げない
・吹き出し形状：通常→丸型、心の声→雲型、驚き→トゲトゲ型

【表情・アングルのバリエーション（重要）】
・4コマすべてで同じアングル・表情にしない
・4コマ内で最低3種類のアングルを使用：
　正面／斜め45度／横顔／やや俯瞰／やや煽り
・距離も変化させる：バストアップ／顔アップ／全身／上半身
・表情：困惑／不安／真剣／ハッとする／安堵／微笑み／納得
・視線の向きも変化させる

【背景のルール（重要）】
■ 基本原則
・4コマ内で最低3種類の背景バリエーションを使用
・シンプルな単色グラデーションのみは避ける
・具体的なイメージ画像、図解を積極的に使用

■ 背景の種類
　【A】場所・情景背景：書斎、オフィス、自然の風景など
　【B】イメージ画像：歴史的人物、概念を表すイメージ
　【C】図解・インフォグラフィック：チャート、フロー図、アイコン
　【D】光の表現：キラキラ効果、放射状の光（気づき・納得に）
　【E】自然・季節背景：桜、青空、木漏れ日（希望・結論に）

■ 感情と背景の連動
　不安・困惑→落ち着いたグレー系
　驚き・発見→放射状の光
　理解・納得→キラキラ効果、整理された図解
　安心・希望→自然の情景、開放感のある空

【キャラクター登場のルール（重要）】
■ 基本原則
・全コマにキャラクターを登場させる必要はない
・4コマ中、1コマのみキャラクター不在にする

■ キャラクター不在コマの種類（5パターンから1つ選択）
【A】概念のイメージカット
【B】手元・部分のクローズアップ
【C】図解・ダイアグラム
【D】吹き出しなし＋背景・風景
【E】たとえ話のビジュアル化

■ 不在コマの文字表現ルール
　・吹き出しは原則使用しない
　・タイトル・見出し形式で簡潔に（体言止め、名詞句）
　・ナレーション枠（四角い枠）は使用可

${characterRuleText}

【画像全体の条件】
・縦長1枚画像、アスペクト比 2:3
・解像度は4K（高解像度）
・上から縦に4コマが並んだ固定構成
・日本語は縦書き、読み順は右から左
・コマの区切りが明確、カラーマンガのみ

【レイアウト・構成ルール】
・日本マンガの読み方向（右→左）を必ず守る
・図解や比較表現は「先に理解するもの→右、後→左」
・遠景／中景／近景／顔アップが偏らないようにする
・同じ画角・構図が連続しないようにする

【マンガの目的・作画トーン】
・記事内容を自然な語りの流れで理解させる
・この4コマはストーリー全体の一部として機能する（完結しなくてよい）
・読者に直接語りかけるような親しみやすさ
・記事に書かれていない事実や誇張は入れない

【NGパターン】
× 4コマすべて正面バストアップ／同じ表情／カメラ目線
× 語尾が4コマとも同じ
× ギャグ的な誇張表現（汗マーク大量、デフォルメ顔）
× 1吹き出し25文字超、1コマ35文字超
× 4コマすべて白背景または単純グラデーションのみ
× キャラの服装・髪型がコマごとに変わる
× 白っぽくぼやけた仕上がり、コントラストの弱い画面
× 白黒マンガ
× 全コマに同じキャラ登場（1コマは不在に）
× エフェクトは文字にしないでください（キラキラなど）

---
【記事内容】
${story}`;
      };

      // Generate manga (single image)
      const generateManga = async (isAdditional = false) => {
        if (!apiKey) {
          setError('APIキーを設定してください');
          return;
        }
        if (!selectedExplainer) {
          setError('説明者のキャラクター画像を選択してください');
          return;
        }
        if (!story || story.length < 20) {
          setError('ストーリーを20文字以上入力してください');
          return;
        }

        setIsGenerating(true);
        setError('');

        try {
          // Prepare image parts
          const imageParts = [];
          
          // Add explainer image
          const explainerBase64 = selectedExplainer.imageBase64.split(',')[1];
          imageParts.push({
            inlineData: {
              mimeType: 'image/png',
              data: explainerBase64
            }
          });
          
          // Add consultant image if exists
          if (selectedConsultant) {
            const consultantBase64 = selectedConsultant.imageBase64.split(',')[1];
            imageParts.push({
              inlineData: {
                mimeType: 'image/png',
                data: consultantBase64
              }
            });
          }

          // System Instruction（プロンプトテンプレート）と User Content（ストーリー）を分離
          const systemPrompt = generatePrompt().split('【記事内容】')[0] + '【記事内容】';
          
          const requestBody = {
            system_instruction: {
              parts: [{ text: systemPrompt }]
            },
            contents: [{
              parts: [
                ...imageParts,
                { text: story }
              ]
            }],
            generationConfig: {
              responseModalities: ["IMAGE", "TEXT"]
            }
          };

          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key=${apiKey}`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(requestBody)
            }
          );

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'API request failed');
          }

          const data = await response.json();
          
          // Extract image from response
          let imageData = null;
          if (data.candidates && data.candidates[0]?.content?.parts) {
            for (const part of data.candidates[0].content.parts) {
              if (part.inlineData) {
                imageData = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                break;
              }
            }
          }

          if (imageData) {
            if (isAdditional) {
              // 追加生成の場合、既存の配列に追加
              const newImages = [...generatedImages, imageData];
              setGeneratedImages(newImages);
              setCurrentImageIndex(newImages.length - 1);
            } else {
              // 新規生成の場合、配列をリセット
              setGeneratedImages([imageData]);
              setCurrentImageIndex(0);
            }
            
            // Save to history
            const newHistory = [{
              id: 'gen_' + Date.now(),
              imageBase64: imageData,
              settings: {
                styleId: selectedStyle,
                speechStyle,
                story: story.substring(0, 100) + '...'
              },
              createdAt: new Date().toISOString()
            }, ...history].slice(0, 10);
            
            setHistory(newHistory);
            localStorage.setItem('manga_history', JSON.stringify(newHistory));
          } else {
            throw new Error('画像の生成に失敗しました');
          }
        } catch (err) {
          console.error(err);
          if (err.message.includes('401')) {
            setError('APIキーが無効です。正しいキーを入力してください');
          } else if (err.message.includes('429')) {
            setError('リクエスト制限に達しました。しばらく待ってから再度お試しください');
          } else {
            setError('エラーが発生しました: ' + err.message);
          }
        } finally {
          setIsGenerating(false);
        }
      };

      // Download image
      const downloadImage = (index) => {
        const imageData = generatedImages[index];
        if (!imageData) return;
        const link = document.createElement('a');
        link.href = imageData;
        link.download = `manga_${Date.now()}_${index + 1}.png`;
        link.click();
      };

      // Download all images
      const downloadAllImages = () => {
        generatedImages.forEach((_, index) => {
          setTimeout(() => downloadImage(index), index * 500);
        });
      };

      // Clear all generated images
      const clearImages = () => {
        setGeneratedImages([]);
        setCurrentImageIndex(0);
      };

      // Sorted styles (favorites first)
      const sortedStyles = [...STYLES].sort((a, b) => {
        const aFav = favorites.includes(a.id);
        const bFav = favorites.includes(b.id);
        if (aFav && !bFav) return -1;
        if (!aFav && bFav) return 1;
        return 0;
      });

      const favoriteStyles = STYLES.filter(s => favorites.includes(s.id));

      return html`
        <div class="flex min-h-screen">
          <!-- Sidebar -->
          <div class="w-96 bg-white border-r border-gray-200 p-5 overflow-y-auto">
            <h1 class="text-xl font-bold text-gray-800 mb-6">
              漫画クリエイター
            </h1>

            <!-- API Key Section -->
            <div class="mb-6 p-4 bg-gray-50 rounded-lg">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">API設定</span>
                <${HelpIcon} text=${HELP_TEXTS.api} />
              </div>
              <div class="relative mb-2">
                <input
                  type=${showApiKey ? 'text' : 'password'}
                  value=${apiKey}
                  onChange=${(e) => { setApiKey(e.target.value); setApiKeySaved(false); }}
                  placeholder="APIキーを入力"
                  class="w-full px-3 py-2 pr-10 border border-gray-300 rounded-lg text-sm focus:outline-none focus:border-blue-500"
                />
                <button
                  onClick=${() => setShowApiKey(!showApiKey)}
                  class="absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 hover:text-gray-700 text-sm"
                >
                  ${showApiKey ? '隠す' : '表示'}
                </button>
              </div>
              <button
                onClick=${saveApiKey}
                class="w-full py-2 bg-blue-500 text-white text-sm rounded-lg hover:bg-blue-600 transition"
              >
                APIキーを保存
              </button>
              <div class="mt-2 text-xs ${apiKeySaved ? 'text-green-600' : 'text-amber-600'}">
                ${apiKeySaved ? 'APIキーは保存済みです' : 'APIキーが未保存です'}
              </div>
            </div>

            <!-- Character Library -->
            <div class="mb-6">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">キャラクターライブラリ</span>
                <${HelpIcon} text=${HELP_TEXTS.library} />
              </div>
              <div class="flex gap-2 overflow-x-auto pb-2 scrollbar-thin">
                ${characters.map(char => html`
                  <div
                    key=${char.id}
                    class="flex-shrink-0 w-16 cursor-pointer group relative"
                    onContextMenu=${(e) => { e.preventDefault(); deleteCharacter(char.id); }}
                  >
                    <img
                      src=${char.imageBase64}
                      alt=${char.name}
                      class="w-16 h-16 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400"
                      onClick=${() => {
                        if (!selectedExplainer) setSelectedExplainer(char);
                        else if (!selectedConsultant) setSelectedConsultant(char);
                      }}
                    />
                    <div class="text-xs text-center mt-1 truncate">${char.name}</div>
                  </div>
                `)}
                <button
                  onClick=${() => setShowAddCharacter(true)}
                  class="flex-shrink-0 w-16 h-16 border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center text-gray-400 hover:border-blue-400 hover:text-blue-400"
                >
                  <span class="text-2xl">+</span>
                </button>
              </div>
            </div>

            <!-- Current Characters -->
            <div class="mb-6">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">今回のキャラクター</span>
                <${HelpIcon} text=${HELP_TEXTS.character} />
              </div>
              <div class="grid grid-cols-2 gap-3">
                <!-- Explainer -->
                <div class="border-2 ${selectedExplainer ? 'border-blue-400' : 'border-dashed border-gray-300'} rounded-lg p-2">
                  <div class="text-xs text-gray-500 mb-2 text-center">説明者（必須）</div>
                  ${selectedExplainer ? html`
                    <div class="relative">
                      <img src=${selectedExplainer.imageBase64} class="w-full h-24 object-cover rounded" />
                      <button
                        onClick=${() => setSelectedExplainer(null)}
                        class="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white rounded-full text-xs"
                      >×</button>
                    </div>
                  ` : html`
                    <div
                      class="h-24 flex items-center justify-center bg-gray-50 rounded cursor-pointer hover:bg-gray-100"
                      onClick=${() => explainerInputRef.current?.click()}
                    >
                      <span class="text-gray-400 text-sm">+ 選択</span>
                    </div>
                  `}
                  <input
                    ref=${explainerInputRef}
                    type="file"
                    accept="image/*"
                    class="hidden"
                    onChange=${(e) => handleDirectUpload(e, 'explainer')}
                  />
                </div>
                <!-- Consultant -->
                <div class="border-2 ${selectedConsultant ? 'border-blue-400' : 'border-dashed border-gray-300'} rounded-lg p-2">
                  <div class="text-xs text-gray-500 mb-2 text-center">相談者（任意）</div>
                  ${selectedConsultant ? html`
                    <div class="relative">
                      <img src=${selectedConsultant.imageBase64} class="w-full h-24 object-cover rounded" />
                      <button
                        onClick=${() => setSelectedConsultant(null)}
                        class="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white rounded-full text-xs"
                      >×</button>
                    </div>
                  ` : html`
                    <div
                      class="h-24 flex items-center justify-center bg-gray-50 rounded cursor-pointer hover:bg-gray-100"
                      onClick=${() => consultantInputRef.current?.click()}
                    >
                      <span class="text-gray-400 text-sm">+ 選択</span>
                    </div>
                  `}
                  <input
                    ref=${consultantInputRef}
                    type="file"
                    accept="image/*"
                    class="hidden"
                    onChange=${(e) => handleDirectUpload(e, 'consultant')}
                  />
                </div>
              </div>
              <div class="text-xs text-gray-500 mt-2 text-center">
                1人のみ→1人語り / 2人選択→2人会話
              </div>
            </div>

            <!-- Style Selection -->
            <div class="mb-6">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">絵のテイスト</span>
                <${HelpIcon} text=${HELP_TEXTS.style} />
              </div>
              
              ${favoriteStyles.length > 0 && html`
                <div class="mb-3">
                  <div class="text-xs text-gray-500 mb-2">★ お気に入り</div>
                  ${favoriteStyles.map(style => html`
                    <label
                      key=${style.id}
                      class="flex items-center p-2 rounded-lg cursor-pointer ${selectedStyle === style.id ? 'bg-blue-50 border-l-4 border-blue-500' : 'hover:bg-gray-50'}"
                    >
                      <input
                        type="radio"
                        name="style"
                        checked=${selectedStyle === style.id}
                        onChange=${() => setSelectedStyle(style.id)}
                        class="mr-2"
                      />
                      <span class="flex-1 text-sm">${style.name}</span>
                      <button
                        onClick=${(e) => { e.preventDefault(); toggleFavorite(style.id); }}
                        class="text-yellow-500"
                      >★</button>
                    </label>
                  `)}
                </div>
              `}
              
              <div class="max-h-48 overflow-y-auto">
                <div class="text-xs text-gray-500 mb-2">すべてのスタイル</div>
                ${sortedStyles.map(style => html`
                  <div key=${style.id} class="tooltip-trigger relative">
                    <label
                      class="flex items-center p-2 rounded-lg cursor-pointer ${selectedStyle === style.id ? 'bg-blue-50 border-l-4 border-blue-500' : 'hover:bg-gray-50'}"
                    >
                      <input
                        type="radio"
                        name="style"
                        checked=${selectedStyle === style.id}
                        onChange=${() => setSelectedStyle(style.id)}
                        class="mr-2"
                      />
                      <span class="flex-1 text-sm">${style.name}</span>
                      <button
                        onClick=${(e) => { e.preventDefault(); toggleFavorite(style.id); }}
                        class="${favorites.includes(style.id) ? 'text-yellow-500' : 'text-gray-300 hover:text-yellow-400'}"
                      >${favorites.includes(style.id) ? '★' : '☆'}</button>
                    </label>
                    <div class="tooltip absolute z-50 w-48 p-2 bg-gray-800 text-white text-xs rounded shadow-lg left-full top-0 ml-2">
                      ${style.description}
                    </div>
                  </div>
                `)}
              </div>
            </div>

            <!-- Speech Style -->
            <div class="mb-6">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">セリフスタイル</span>
                <${HelpIcon} text=${HELP_TEXTS.speech} />
              </div>
              <div class="space-y-2">
                <label class="flex items-center p-2 rounded-lg cursor-pointer ${speechStyle === 'formal' ? 'bg-blue-50' : 'hover:bg-gray-50'}">
                  <input
                    type="radio"
                    name="speech"
                    checked=${speechStyle === 'formal'}
                    onChange=${() => setSpeechStyle('formal')}
                    class="mr-2"
                  />
                  <span class="text-sm">敬語（です・ます調）</span>
                </label>
                <label class="flex items-center p-2 rounded-lg cursor-pointer ${speechStyle === 'casual' ? 'bg-blue-50' : 'hover:bg-gray-50'}">
                  <input
                    type="radio"
                    name="speech"
                    checked=${speechStyle === 'casual'}
                    onChange=${() => setSpeechStyle('casual')}
                    class="mr-2"
                  />
                  <span class="text-sm">タメ口（カジュアル）</span>
                </label>
              </div>
            </div>
          </div>

          <!-- Main Area -->
          <div class="flex-1 p-6 overflow-y-auto">
            <!-- Story Input -->
            <div class="mb-6">
              <div class="flex items-center mb-3">
                <span class="text-lg font-semibold text-gray-700">ストーリー・記事内容</span>
                <${HelpIcon} text=${HELP_TEXTS.story} />
              </div>
              <textarea
                value=${story}
                onChange=${(e) => setStory(e.target.value)}
                placeholder="漫画にしたい内容を入力してください。
例：新商品の特徴、サービスの説明、歴史の解説など..."
                class="w-full h-48 p-4 border border-gray-300 rounded-lg resize-y focus:outline-none focus:border-blue-500"
              />
              <div class="text-right text-xs text-gray-500 mt-1">${story.length} 文字</div>
            </div>

            <!-- Generate Buttons -->
            <div class="mb-6">
              <div class="flex gap-3">
                <button
                  onClick=${() => generateManga(false)}
                  disabled=${isGenerating || !apiKeySaved}
                  class="flex-1 py-4 bg-gradient-to-r from-orange-500 to-orange-600 text-white text-lg font-bold rounded-lg hover:from-orange-600 hover:to-orange-700 disabled:opacity-50 disabled:cursor-not-allowed transition flex items-center justify-center"
                >
                  ${isGenerating ? html`
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    生成中...
                  ` : '1枚目を生成'}
                </button>
                
                ${generatedImages.length > 0 && generatedImages.length < 4 && html`
                  <button
                    onClick=${() => generateManga(true)}
                    disabled=${isGenerating || !apiKeySaved}
                    class="flex-1 py-4 bg-gradient-to-r from-blue-500 to-blue-600 text-white text-lg font-bold rounded-lg hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition flex items-center justify-center"
                  >
                    ${isGenerating ? html`
                      <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      生成中...
                    ` : `次の1枚を生成（${generatedImages.length + 1}枚目）`}
                  </button>
                `}
              </div>
              
              ${generatedImages.length >= 4 && html`
                <div class="text-center text-sm text-gray-500 mt-2">
                  最大4枚まで生成できます
                </div>
              `}
              
              ${!apiKeySaved && html`
                <div class="text-amber-600 text-sm mt-2 text-center">APIキーを保存してください</div>
              `}
              ${error && html`
                <div class="text-red-600 text-sm mt-2 text-center">${error}</div>
              `}
            </div>

            <!-- Generated Images -->
            <div class="mb-6">
              <div class="flex items-center justify-between mb-3">
                <span class="text-lg font-semibold text-gray-700">生成された漫画</span>
                ${generatedImages.length > 0 && html`
                  <span class="text-sm text-gray-500">${currentImageIndex + 1} / ${generatedImages.length}枚</span>
                `}
              </div>
              
              <div class="bg-gray-100 rounded-lg p-4 min-h-96 flex items-center justify-center">
                ${generatedImages.length > 0 ? html`
                  <img src=${generatedImages[currentImageIndex]} alt="Generated manga" class="max-w-full max-h-[600px] rounded-lg shadow-lg" />
                ` : html`
                  <div class="text-gray-400 text-center">
                    <div class="text-4xl mb-2">○</div>
                    <div>ここに生成された漫画が表示されます</div>
                  </div>
                `}
              </div>
              
              <!-- Image Navigation -->
              ${generatedImages.length > 1 && html`
                <div class="flex justify-center gap-2 mt-4">
                  ${generatedImages.map((_, index) => html`
                    <button
                      key=${index}
                      onClick=${() => setCurrentImageIndex(index)}
                      class="w-10 h-10 rounded-lg border-2 ${currentImageIndex === index ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-400'} flex items-center justify-center text-sm font-bold"
                    >
                      ${index + 1}
                    </button>
                  `)}
                </div>
              `}
              
              <!-- Action Buttons -->
              ${generatedImages.length > 0 && html`
                <div class="flex gap-3 mt-4 justify-center">
                  <button
                    onClick=${() => downloadImage(currentImageIndex)}
                    class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition"
                  >
                    この画像をダウンロード
                  </button>
                  ${generatedImages.length > 1 && html`
                    <button
                      onClick=${downloadAllImages}
                      class="px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition"
                    >
                      全てダウンロード
                    </button>
                  `}
                  <button
                    onClick=${clearImages}
                    class="px-6 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition"
                  >
                    クリア
                  </button>
                </div>
              `}
            </div>

            <!-- Thumbnail Gallery -->
            ${generatedImages.length > 1 && html`
              <div class="mb-6">
                <div class="text-sm font-semibold text-gray-700 mb-3">生成した画像一覧</div>
                <div class="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">
                  ${generatedImages.map((img, index) => html`
                    <div
                      key=${index}
                      class="flex-shrink-0 cursor-pointer"
                      onClick=${() => setCurrentImageIndex(index)}
                    >
                      <img
                        src=${img}
                        class="w-24 h-32 object-cover rounded-lg border-2 ${currentImageIndex === index ? 'border-blue-500' : 'border-gray-200 hover:border-blue-400'}"
                      />
                      <div class="text-xs text-center mt-1">${index + 1}枚目</div>
                    </div>
                  `)}
                </div>
              </div>
            `}

            <!-- History -->
            ${history.length > 0 && html`
              <div>
                <div class="flex items-center justify-between mb-3">
                  <span class="text-lg font-semibold text-gray-700">生成履歴</span>
                  <button
                    onClick=${() => setShowHistory(true)}
                    class="text-blue-500 text-sm hover:underline"
                  >すべて見る →</button>
                </div>
                <div class="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">
                  ${history.slice(0, 5).map(item => html`
                    <div
                      key=${item.id}
                      class="flex-shrink-0 cursor-pointer"
                      onClick=${() => { setGeneratedImages([item.imageBase64]); setCurrentImageIndex(0); }}
                    >
                      <img
                        src=${item.imageBase64}
                        class="w-24 h-32 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400"
                      />
                      <div class="text-xs text-gray-500 mt-1 text-center">
                        ${new Date(item.createdAt).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}
                      </div>
                    </div>
                  `)}
                </div>
              </div>
            `}
          </div>

          <!-- Add Character Modal -->
          ${showAddCharacter && html`
            <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
              <div class="bg-white rounded-xl p-6 w-96 max-w-[90vw]">
                <h3 class="text-lg font-bold mb-4">キャラクターを追加</h3>
                <input
                  type="text"
                  value=${newCharacterName}
                  onChange=${(e) => setNewCharacterName(e.target.value)}
                  placeholder="キャラクター名"
                  class="w-full px-3 py-2 border border-gray-300 rounded-lg mb-4"
                />
                <div
                  class="border-2 border-dashed border-gray-300 rounded-lg p-4 mb-4 text-center cursor-pointer hover:border-blue-400"
                  onClick=${() => fileInputRef.current?.click()}
                >
                  ${newCharacterImage ? html`
                    <img src=${newCharacterImage} class="max-h-32 mx-auto rounded" />
                  ` : html`
                    <div class="text-gray-400">
                      <div class="text-3xl mb-2">+</div>
                      <div>クリックして画像を選択</div>
                    </div>
                  `}
                </div>
                <input
                  ref=${fileInputRef}
                  type="file"
                  accept="image/*"
                  class="hidden"
                  onChange=${handleNewCharacterFile}
                />
                <div class="flex gap-3">
                  <button
                    onClick=${() => { setShowAddCharacter(false); setNewCharacterName(''); setNewCharacterImage(null); }}
                    class="flex-1 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
                  >キャンセル</button>
                  <button
                    onClick=${addCharacter}
                    disabled=${!newCharacterName || !newCharacterImage}
                    class="flex-1 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50"
                  >追加</button>
                </div>
              </div>
            </div>
          `}

          <!-- History Modal -->
          ${showHistory && html`
            <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick=${() => setShowHistory(false)}>
              <div class="bg-white rounded-xl p-6 w-[800px] max-w-[90vw] max-h-[80vh] overflow-y-auto" onClick=${(e) => e.stopPropagation()}>
                <div class="flex justify-between items-center mb-4">
                  <h3 class="text-lg font-bold">生成履歴</h3>
                  <button onClick=${() => setShowHistory(false)} class="text-gray-500 hover:text-gray-700 text-2xl">×</button>
                </div>
                <div class="grid grid-cols-3 gap-4">
                  ${history.map(item => html`
                    <div
                      key=${item.id}
                      class="cursor-pointer"
                      onClick=${() => { setGeneratedImages([item.imageBase64]); setCurrentImageIndex(0); setShowHistory(false); }}
                    >
                      <img
                        src=${item.imageBase64}
                        class="w-full h-48 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400"
                      />
                      <div class="text-xs text-gray-500 mt-1">
                        ${new Date(item.createdAt).toLocaleString('ja-JP')}
                      </div>
                    </div>
                  `)}
                </div>
              </div>
            </div>
          `}
        </div>
      `;
    }

    // Mount app
    const root = createRoot(document.getElementById('app'));
    root.render(html`<${App} />`);
  </script>
</body>
</html>
