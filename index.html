<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>漫画クリエイター</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    .tooltip { visibility: hidden; opacity: 0; transition: opacity 0.2s; }
    .tooltip-trigger:hover .tooltip { visibility: visible; opacity: 1; }
    .scrollbar-thin::-webkit-scrollbar { height: 6px; width: 6px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
    .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
    .accordion-content.open { max-height: 2000px; }
    @media (max-width: 768px) {
      .sidebar { position: fixed; left: -100%; top: 0; height: 100vh; z-index: 50; transition: left 0.3s ease; width: 85%; max-width: 360px; }
      .sidebar.open { left: 0; }
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="app"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/htm@3/dist/htm.umd.js"></script>
  
  <script>
    var html = htm.bind(React.createElement);
    var useState = React.useState;
    var useEffect = React.useEffect;
    var useRef = React.useRef;

    // Supabase設定
    var SUPABASE_URL = 'https://twhhrgcksstikdoyroto.supabase.co';
    var SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3aGhyZ2Nrc3N0aWtkb3lyb3RvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwMzk3MzIsImV4cCI6MjA4NjYxNTczMn0.grPvawJNNXoikE7tLVf-Fq3rglXJjwdfpYGjdmYlL7s';
    var supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // 定数
    var STYLES = [
      { id: 1, name: 'ビジネス説明マンガ風', desc: '企業向けビジネス書・まんがでわかる○○シリーズの優しいタッチ', prompt: 'Japanese josei manga illustration style for business books. Soft natural color palette with warm beige skin tones and natural brown hair. Delicate thin linework with subtle line weight variation. Soft gradient shading, not cel-shaded. Realistic proportions with slightly large but natural-looking eyes. Clean, professional, and approachable atmosphere. Detailed hair strands with natural flow. Gentle highlights and minimal shadows. Style similar to "manga de wakaru" business book illustrations.' },
      { id: 2, name: '少年漫画風', desc: '週刊少年ジャンプ風・ワンピース/ドラゴンボールのような迫力バトル', prompt: 'Japanese Weekly Shonen Jump manga illustration style, full color spread page quality. Extremely bold heavy ink linework with exaggerated line weight variation, extra thick black outlines on characters that pop off the page. Hyper-detailed background art with dramatic forced perspective and foreshortening. Intensely vivid oversaturated colors with hard cel-shading and deep black shadows. Extreme high contrast lighting with powerful directional light source, strong rim lighting, and glowing color bleeds. Screentone texture overlay for authentic print feeling. Over-the-top dynamic composition breaking panel boundaries. Extreme camera angles - ultra low angle looking up, severe dutch angle, exaggerated fish-eye distortion. Characters bursting out of frame toward viewer. Explosive speed lines filling entire background, dense impact lines radiating from action points, heavy motion blur streaks. Flying debris, shattering rocks, dust clouds, sparks, and energy particles everywhere. Shockwave ripples and impact craters. Exaggerated anatomy with dynamic impossible poses, muscles tensed at peak action, clothing and hair blown by intense force. Screaming expressions with wide eyes and intense emotion visible. Battle aura effects, glowing energy emanating from characters, light beam attacks, flame or lightning effects. Onomatopoeia sound effect aesthetics integrated into composition. Color palette with extreme complementary contrasts - hot orange against cool blue, vivid red against deep green. Background practically vibrating with energy. Character colors cranked to maximum saturation against darker dramatic backgrounds. Raw hand-drawn ink texture with visible brush strokes, confident and aggressive linework. Peak Weekly Shonen Jump double-page spread impact and intensity.' },
      { id: 3, name: '少女漫画風', desc: 'りぼん・なかよし風・セーラームーン/カードキャプターさくらのキラキラ世界', prompt: 'Japanese classic shoujo manga illustration style, full color magazine cover quality. Extremely delicate graceful linework with elegant flowing strokes, impossibly fine detailed lines for each individual hair strand flowing like silk in the wind. Overwhelmingly large sparkling eyes taking up half the face, filled with multiple layered star-shaped highlights, galaxy-like gradient irises with jewel-like depth, impossibly long dramatic eyelashes with individual strands visible. Eyes reflecting entire universes of emotion and light. Explosively dreamy backgrounds completely filled with floating roses, cherry blossoms, lilies cascading everywhere. Thousands of sparkles, glitter particles, and diamond dust filling every empty space. Soap bubbles with rainbow reflections, soft feathers floating, ribbons swirling through the air. Ultra soft ethereal pastel color palette - delicate pink, dreamy lavender, heavenly baby blue, pearl white with iridescent shimmer. Colors so soft they seem to glow from within. Extreme airbrush-style gradients melting seamlessly into each other. Overwhelming light effects - lens flares bursting like stars, soft focus bokeh everywhere, holy light rays streaming down, rainbow prism effects, glowing halos around characters. Everything bathed in magical golden hour lighting. Hair flowing in impossible dramatic waves defying gravity, each strand catching light individually, hair so detailed it looks like liquid silk or spun gold. Clothing billowing ethereally as if underwater or in zero gravity. Intensely emotional expressions - huge glistening tears like crystal jewels catching light, deep blushes spreading across cheeks with soft gradient, lips with glass-like shine and perfect highlights. Decorative elements overflowing - intricate lace patterns, satin ribbons, pearl accessories, crystal jewelry catching prismatic light. Ornate floral borders framing the scene. Screen tone texture with delicate flower patterns, soft dot gradients creating dreamy atmosphere. Peak Ribon or Nakayoshi magazine cover impact - overwhelmingly beautiful and romantic aesthetic that takes breath away.' },
      { id: 4, name: 'シンプル線画風', desc: '北欧ミニマルデザイン・無印良品/Apple UIのような極限シンプル', prompt: 'Ultra minimalist vector line art illustration style, extreme geometric simplification. Perfectly uniform clean black outlines with mathematically precise thickness, no variation or hand-drawn imperfection whatsoever. Radically simplified shapes - circles, rectangles, triangles only. Human figures reduced to essential geometric forms, faces with dot eyes and single line expressions or no facial features at all. Objects stripped down to absolute iconic silhouettes instantly recognizable with minimum detail. Completely flat solid colors with absolutely zero gradients, zero shadows, zero highlights, zero texture. Pure unmodulated color fills like digital paint bucket tool. Limited color palette - maximum 3-4 colors plus black and white. Extreme negative space utilization - bold empty areas as important as filled areas. Perfectly balanced asymmetrical composition. Every element placed with mathematical precision and intentional breathing room. Razor sharp vector edges, infinitely scalable appearance. Colors either bold primary palette or sophisticated muted Scandinavian tones - dusty pink, sage green, warm gray, mustard yellow. No decorative elements whatsoever - no patterns, no textures, no ornaments. If it can be removed without losing meaning, it is removed. Absolute economy of visual information. Clean modern tech company aesthetic meets Scandinavian design philosophy. Swiss graphic design precision. Museum of Modern Art poster quality minimalism.' },
      { id: 5, name: 'アメコミ風', desc: 'マーベル/DCコミックス・スパイダーマン/バットマン風のポップなアメリカン', prompt: 'Classic American superhero comic book illustration style, full color splash page quality. Extremely bold heavy black ink outlines with aggressive confident brushwork, thick to thin line variation showing hand-inked craftsmanship. Cross-hatching and feathering techniques for dramatic shadow rendering. Hyper-muscular heroic anatomy with exaggerated proportions - massive shoulders, impossibly broad chests, chiseled jawlines, dynamic impossible poses showing extreme foreshortening. Capes and costumes billowing dramatically with every fold and wrinkle rendered. Veins visible on tensed muscles. Intensely vibrant saturated colors - primary red, blue, yellow popping off the page. Bold complementary color clashes creating visual impact. Colors so vivid they practically glow. Heavy halftone Ben-Day dot patterns visible throughout - dots on skin tones, dots in shadows, dots creating gradients and atmospheric effects. Authentic vintage newsprint comic aesthetic with CMYK color separation feeling. Extreme dramatic lighting with stark noir-influenced shadows. Pure black shadow areas with sharp cutoffs, intense rim lighting outlining figures against dark backgrounds. Multiple dramatic light sources creating complex shadow interplay. Kirby Krackle cosmic energy effects - black dot clusters representing cosmic power and explosions. Energy beams, lightning bolts, power auras crackling around characters. Explosive impact bursts and starburst effects. Hyper-detailed urban destruction backgrounds - crumbling skyscrapers, shattered concrete, flying debris, billowing smoke clouds, cracked asphalt, bent steel girders. Epic sense of scale with tiny figures against massive destruction. Over-the-top action composition bursting beyond panel borders. Extreme camera angles - severe worm\'s eye view looking up at towering heroes, dramatic bird\'s eye capturing citywide chaos. Fists and feet punching directly toward viewer breaking the fourth wall. Sound effect aesthetic integrated - impact feels like visible POW, WHAM, KRACKOOM even without text. Visual noise and energy radiating from every action. Classic Marvel and DC bronze age aesthetic meets modern Image Comics intensity. Jack Kirby cosmic grandeur combined with Jim Lee hyper-detailed rendering. Print-ready newsstand comic book cover impact.' },
      { id: 6, name: '水彩イラスト風', desc: '絵本・水彩画風・ジブリ背景美術のような柔らかく温かい水彩タッチ', prompt: 'Traditional watercolor painting illustration style, fine art gallery exhibition quality. Extremely loose expressive brushwork with visible confident brush strokes dancing across the surface. Wet-on-wet technique creating magical unpredictable color blooms and bleeds spreading organically. Heavily visible cold-pressed watercolor paper texture - rough tooth surface catching pigment in valleys, creating beautiful granulation effects. Paper grain showing through transparent washes. Pure white of paper glowing through as brightest highlights, never covered with white paint. Dreamy soft edges melting into each other where colors meet, bleeding and feathering beautifully. Occasional crisp hard edges for contrast where wet meets dry. Cauliflower blooms and backruns embraced as happy accidents adding organic authenticity. Luminous transparent color layers built up through multiple glazing washes - colors glowing from within as light passes through pigment to paper and reflects back. Visible layering where previous washes peek through subsequent layers creating color depth impossible in opaque media. Pigment granulation and separation visible - heavier pigments settling into paper texture creating speckled effects. Sedimentary pigments like ultramarine and burnt sienna showing natural granular texture. Color separating into component pigments in wet washes. Water marks and tide lines where puddles dried, salt texture effects creating snowflake patterns, deliberate splatter and spray adding energy and movement. Drips running down occasionally left as artistic elements. Color palette either soft ethereal pastels with diluted washes or rich vibrant concentrated pigments pooling in shadows. Atmospheric perspective through increasingly diluted cooler washes for distant elements. Warm concentrated colors for foreground, pale cool hints for background. Loose gestural quality - suggesting rather than defining, leaving areas unfinished and breathing. Strategic unpainted white spaces as important design elements. Edges lost and found throughout composition guiding the eye. Authentic traditional watercolor aesthetic - handmade imperfection, organic unpredictability, luminosity only achievable through transparent water media. Fine art watercolor society exhibition quality, museum-worthy traditional painting appearance.' },
      { id: 7, name: 'レトロ漫画風', desc: '昭和レトロ漫画・ベルサイユのばら/キャンディキャンディの懐かしい雰囲気', prompt: 'Authentic vintage Japanese manga illustration style from 1970s-1980s golden age era, full color magazine illustration quality. Classic hand-drawn ink linework with visible pen nib texture - G-pen bold strokes for outlines, Maru-pen delicate lines for details, Kabura-pen for hair strands. Iconic retro character design - large sparkling eyes with dramatic star-shaped highlights and heavy black areas, distinctively thick eyebrows, pointed chins, impossibly long legs with exaggerated height proportions. Feathered hair with dramatic volume and wings, era-specific hairstyles reflecting 70s-80s fashion. Heavy authentic screen tone usage throughout - IC Screen and Letraset tone patterns visible. Mechanical dot tones for shading, gradient tones for atmospheric effects, decorative pattern tones for clothing and backgrounds. Sand tones, cross-hatch tones, sparkle effect tones layered for depth. Nostalgic vintage color palette limited by period printing technology - slightly misaligned CMYK registration creating subtle color bleeds. Warm yellowed paper undertone as if aged newsprint. Saturated but slightly muted colors - distinctive orange-reds, turquoise blues, mustard yellows, dusty pinks specific to era printing. Dramatic speed lines and effect lines hand-drawn with ruler precision. Beta-flash technique with white radiating from black. Emotion symbols - sweat drops, anger veins, sparkle backgrounds, flower frames for beautiful moments. Detailed realistic backgrounds contrasting with stylized characters - urban Japanese cityscapes, detailed interior rooms with period-accurate furniture and technology, school buildings, trains. Visible analog production artifacts - white-out correction marks, slight ink bleeding at line intersections, paste-up edges where tones were cut and applied by hand. Authentic pre-digital manga craftsmanship visible throughout. Emotional dramatic atmosphere with characteristic manga storytelling visual language. Style reminiscent of Shonen Sunday, Margaret, or Ribon magazine illustrations from the era. Museum of manga history exhibition quality, preserving authentic golden age aesthetic.' },
      { id: 8, name: 'Webtoon風', desc: '韓国ウェブトゥーン・俺だけレベルアップ/神之塔の現代的デジタル表現', prompt: 'Modern Korean webtoon illustration style, premium platform featured series quality. Immaculately clean digital linework with perfect smooth curves, crisp confident outlines with subtle thickness variation. Ultra-polished professional digital art finish with no visible brush texture. Stunning modern character designs reflecting Korean beauty standards - small perfectly proportioned faces, flawless porcelain skin with luminous glow, high nose bridges, delicate lips with glass-like shine, perfectly groomed eyebrows. Large expressive eyes but more realistic than Japanese manga - detailed iris patterns with multiple light reflections, natural double eyelids, subtle eye makeup visible. Impossibly beautiful hair rendered strand by strand with silky smooth highlights, perfectly styled K-drama worthy hairstyles catching light beautifully. Hair color ranging from natural blacks and browns to trendy Korean hair colors - ash gray, burgundy, honey brown with subtle highlights. Ultra-soft airbrushed shading with seamless gradient transitions, no hard cel-shading edges. Delicate blushing on cheeks, nose tips, and ears with soft pink diffusion. Subsurface scattering effect on skin creating lifelike translucency, especially on ears and fingertips catching backlight. Fashion-forward contemporary clothing with meticulous fabric rendering - designer brands, trendy Korean street fashion, perfectly fitted suits, flowing dresses with realistic fabric physics. Detailed accessories - luxury watches, earrings, necklaces, designer bags all rendered with care. Cinematic atmospheric backgrounds with intentional depth of field blur - sharp focused characters against dreamy bokeh backgrounds. Modern Korean urban settings - stylish cafes, luxury apartments, Seoul cityscape, university campuses, corporate offices all rendered with architectural accuracy. Sophisticated color palette with harmonious color theory - soft pastels for romance genres, moody desaturated tones for thriller/drama, vibrant saturated colors for fantasy. Characteristic soft purple, pink, and blue atmospheric color grading throughout. Dramatic cinematic lighting with multiple soft light sources - warm golden hour glow, cool blue moonlight, neon city reflections, soft window light. Rim lighting separating characters from backgrounds, lens flares and light leaks adding filmic quality. Vertical scroll composition optimized with dramatic reveals and pacing. Strategic use of extreme close-ups on emotional eyes and faces. Dynamic camera angles creating webtoon-specific visual storytelling impact. Peak Naver Webtoon or Kakao Page premium series quality. Production value rivaling top-tier series like "True Beauty", "Lore Olympus", or "Solo Leveling". Professional Korean digital illustration studio quality throughout.' },
      { id: 9, name: '絵本イラスト風', desc: 'ピーターラビット/こぐまちゃん/はらぺこあおむしの温かい絵本世界', prompt: 'Heartwarming children\'s picture book illustration style, award-winning Caldecott Medal quality. Impossibly soft rounded shapes with no sharp edges anywhere - every corner curved, every form pillowy and huggable. Characters designed to be maximally endearing and lovable. Extremely warm inviting color palette radiating comfort - soft buttercream yellows, cozy terracotta oranges, gentle sage greens, warm rosy pinks, comforting sky blues. Colors feel like a warm blanket, a cup of cocoa, a gentle hug from grandmother. Visible handcrafted traditional media texture throughout - soft colored pencil strokes with waxy buildup, gentle watercolor washes bleeding softly at edges, gouache opacity with subtle brushwork visible, crayon texture with paper grain showing through. Mixed media layering creating rich tactile depth. Adorable character designs with exaggerated cute proportions - oversized round heads on small bodies, huge sparkling innocent eyes full of wonder, tiny button noses, rosy chubby cheeks that beg to be pinched. Simplified rounded hands like mittens, stubby little legs. Expressions radiating pure joy, curiosity, and warmth. Whimsical fantastical backgrounds bursting with cozy details - tiny mushroom houses with smoking chimneys, rolling gentle hills like soft pillows, friendly trees with faces, winding paths inviting exploration. Every element anthropomorphized and friendly - smiling suns, sleepy moons, cheerful flowers waving hello. Rich storytelling details rewarding close inspection - tiny creatures hiding in corners, secret doorways, miniature scenes within scenes. Visual narrative depth encouraging repeated viewing and discovery. Magical golden hour lighting bathing everything in warmth - soft diffused light with no harsh shadows, gentle glowing highlights, everything lit as if by candlelight or sunset. Light itself feels cozy and safe. Nostalgic timeless quality evoking beloved childhood memories - style reminiscent of classic Beatrix Potter, Eric Carle tactile quality, Oliver Jeffers whimsy, Jon Klassen subtle humor. Museum of children\'s literature exhibition quality, destined to become treasured bedtime reading for generations.' },
      { id: 10, name: 'クール・スタイリッシュ風', desc: 'ファッション誌風・NANA/Paradise Kissのモノトーンでおしゃれな表現', prompt: 'Ultra-cool sophisticated Japanese manga illustration style, high-end fashion magazine editorial quality. Razor-sharp confident ink linework with extreme precision, bold black strokes with dramatic thick-to-thin variation. Heavy use of pure blacks creating striking silhouettes and noir-like contrast. Predominantly monochromatic palette - deep rich blacks, pure bright whites, and full spectrum of sophisticated grays. Strategic limited accent colors used sparingly for maximum visual impact - single striking red on lips or blood, electric blue on eyes or neon signs, vibrant orange on cigarette ember or sunset. Color so selective it becomes symbolic and meaningful. Impossibly stylish character designs with model-like proportions - tall lean figures, sharp angular facial features, high cheekbones, narrow intense eyes with piercing gaze. Cool detached expressions radiating effortless confidence and mysterious allure. Characters look like they belong on fashion runways or in indie film posters. Hyper-detailed contemporary fashion rendered with obsessive precision - designer leather jackets with every zipper and stitch visible, perfectly tailored black suits, flowing oversized coats, avant-garde streetwear. Fabric textures meticulously rendered - leather shine, denim weave, silk drape, knit patterns. Accessories as character statements - designer sunglasses, silver jewelry, expensive watches, statement earrings. Cinematic urban nightscape backgrounds dripping with atmosphere - rain-slicked Tokyo streets reflecting neon, towering skyscrapers disappearing into fog, underground club interiors with dramatic lighting, empty late-night train platforms, rooftop silhouettes against city lights. Architecture rendered with precise perspective and urban grit. Dramatic noir-influenced lighting creating extreme contrast - harsh single light sources casting deep black shadows, rim lighting outlining figures against darkness, neon glow painting colored light on faces, cigarette smoke catching beams of light. Shadows as important as lit areas. Heavy screen tone usage for sophisticated gray gradations - mechanical dot patterns creating smooth transitions, gradient tones for atmospheric depth, cross-hatch tones for textured shadows. Analog manga craftsmanship with modern aesthetic sensibility. Edgy artistic composition with unconventional framing - extreme close-ups on eyes and lips, figures cropped dramatically at frame edges, negative space used boldly, dutch angles creating tension and unease. Visual rhythm between dense detailed areas and stark empty spaces. Cool detached atmosphere with underlying emotional intensity - style reminiscent of "Nana", "Paradise Kiss", "Gangsta", "Tokyo Ghoul" aesthetic sophistication. Fashion editorial meets underground manga culture. Gallery exhibition quality art book appearance.' },
      { id: 99, name: '画像から参照', desc: '添付画像の雰囲気に合わせます', prompt: '' }
    ];

    var MODELS = [
      { id: '4k', name: '高品質 4K（有料）', model: 'gemini-3-pro-image-preview', price: 0.24, jpy: 36 },
      { id: '2k', name: '高品質 2K（有料）', model: 'gemini-3-pro-image-preview', price: 0.134, jpy: 20 },
      { id: 'free', name: '標準（無料）', model: 'gemini-2.5-flash-image', price: 0, jpy: 0 }
    ];

    var SAMPLES = [
      { id: 1, cat: 'ビジネス', title: 'ビジネス説明マンガ', style: 1 },
      { id: 2, cat: '教育', title: '教育系解説マンガ', style: 1 },
      { id: 3, cat: '商品紹介', title: '商品紹介マンガ', style: 8 },
      { id: 4, cat: 'ビジネス', title: '採用広報マンガ', style: 2 },
      { id: 5, cat: '教育', title: '歴史解説マンガ', style: 7 },
      { id: 6, cat: '商品紹介', title: 'サービス紹介', style: 3 }
    ];

    var HELP = {
      api: '【APIキー取得手順】\n\n1. https://aistudio.google.com/ にアクセス\n2. Googleアカウントでログイン\n3. 左メニュー「Get API Key」をクリック\n4. 「Create API Key」をクリック\n5. 表示されたキーをコピー（AIza...で始まる）\n6. このアプリに貼り付けて「保存」\n\n※キーは他人に共有しないでください',
      model: '【モデル選択】\n\n■ 高品質 4K（有料）\n$0.24/枚（約36円）最高品質\n\n■ 高品質 2K（有料）\n$0.134/枚（約20円）高品質\n\n■ 標準（無料）\n1日500枚まで無料',
      character: '【キャラクター設定】\n\n■ 説明者（必須）\nメインで話を進めるキャラ\n\n■ 相談者（任意）\n質問役。設定すると会話形式に\n\n■ 参考3・4（任意）\n漫画に登場させたい写真など',
      style: '【絵のテイスト】\n絵柄を選択できます。\n★でお気に入り登録すると上に表示。\n「画像から参照」で添付画像に合わせます。',
      story: '【入力のコツ】\n・100〜500文字程度が目安\n・箇条書きでもOK\n・感情を入れると表現豊かに'
    };

    var TUTORIAL = [
      { title: 'ようこそ！', content: 'このツールでは、ストーリーを入力するだけで\n4コマ漫画が自動生成されます。\n\nキャラクターや絵のスタイルを\n自由にカスタマイズできます。' },
      { title: 'STEP 1: APIキー設定', content: 'Google AI StudioでAPIキーを取得し、\n設定してください。\n\n無料で取得できます。\n詳しくは「?」マークをクリック！' },
      { title: 'STEP 2: キャラクター', content: '説明者（必須）と相談者（任意）の\n画像を設定します。\n\nライブラリに保存すると\n次回からワンクリックで使えます。' },
      { title: 'STEP 3: スタイル', content: '絵のテイストを10種類以上から選択。\n\nセリフの話し方（敬語/タメ口）も\n選べます。' },
      { title: 'STEP 4: 生成！', content: 'ストーリーを入力して\n「漫画を生成」ボタンをクリック！\n\n複数枚の同時生成もできます。\nさあ、始めましょう！' }
    ];

    // 認証フォーム
    function AuthForm() {
      var s1 = useState(false); var isSignUp = s1[0], setIsSignUp = s1[1];
      var s2 = useState(''); var email = s2[0], setEmail = s2[1];
      var s3 = useState(''); var password = s3[0], setPassword = s3[1];
      var s4 = useState(''); var fullName = s4[0], setFullName = s4[1];
      var s5 = useState(false); var loading = s5[0], setLoading = s5[1];
      var s6 = useState(''); var error = s6[0], setError = s6[1];

      async function handleSignUp() {
        if (!fullName || !email || !password) {
          setError('すべてのフィールドを入力してください');
          return;
        }
        if (password.length < 8) {
          setError('パスワードは8文字以上にしてください');
          return;
        }

        setLoading(true);
        setError('');

        var result = await supabase.auth.signUp({
          email: email,
          password: password,
          options: {
            data: { full_name: fullName }
          }
        });

        if (result.error) {
          setError(result.error.message);
        } else {
          alert('登録完了！ログインしてください。');
          setIsSignUp(false);
          setEmail('');
          setPassword('');
          setFullName('');
        }
        setLoading(false);
      }

      async function handleSignIn() {
        if (!email || !password) {
          setError('メールアドレスとパスワードを入力してください');
          return;
        }

        setLoading(true);
        setError('');

        var result = await supabase.auth.signInWithPassword({
          email: email,
          password: password
        });

        if (result.error) {
          setError(result.error.message);
        }
        setLoading(false);
      }

      return html`
        <div class="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
          <div class="bg-white rounded-2xl shadow-xl p-8 w-full max-w-md">
            <h1 class="text-3xl font-bold text-center mb-2 bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
              漫画生成ツール
            </h1>
            <p class="text-center text-gray-600 mb-8">
              ${isSignUp ? '新規登録' : 'ログイン'}
            </p>

            ${error && html`
              <div class="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
                ${error}
              </div>
            `}

            <div class="space-y-4">
              ${isSignUp && html`
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-2">お名前 *</label>
                  <input
                    type="text"
                    value=${fullName}
                    onInput=${(e) => setFullName(e.target.value)}
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="山田太郎"
                    required
                  />
                </div>
              `}

              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">メールアドレス *</label>
                <input
                  type="email"
                  value=${email}
                  onInput=${(e) => setEmail(e.target.value)}
                  class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="example@email.com"
                  required
                />
              </div>

              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">パスワード *</label>
                <input
                  type="password"
                  value=${password}
                  onInput=${(e) => setPassword(e.target.value)}
                  class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="8文字以上"
                  required
                />
                ${isSignUp && html`
                  <p class="text-xs text-gray-500 mt-1">8文字以上で入力してください</p>
                `}
              </div>

              <button
                onClick=${isSignUp ? handleSignUp : handleSignIn}
                disabled=${loading}
                class="w-full py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg font-semibold hover:from-blue-700 hover:to-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition"
              >
                ${loading ? '処理中...' : (isSignUp ? '登録する' : 'ログイン')}
              </button>

              <button
                onClick=${() => setIsSignUp(!isSignUp)}
                class="w-full text-sm text-gray-600 hover:text-gray-800"
              >
                ${isSignUp ? 'すでにアカウントをお持ちの方はこちら' : 'アカウントをお持ちでない方はこちら'}
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // ヘルプアイコン
    function HelpIcon(props) {
      return html`
        <div class="tooltip-trigger relative inline-block ml-2">
          <div class="w-5 h-5 bg-gray-200 rounded-full flex items-center justify-center cursor-help text-xs text-gray-600 font-bold hover:bg-gray-300">?</div>
          <div class="tooltip absolute z-50 w-72 p-3 bg-gray-800 text-white text-xs rounded-lg shadow-lg left-7 top-0 whitespace-pre-wrap">${props.text}</div>
        </div>
      `;
    }

    // モーダル
    function Modal(props) {
      if (!props.isOpen) return null;
      var sizes = { sm: 'max-w-md', md: 'max-w-2xl', lg: 'max-w-4xl', full: 'max-w-[95vw]' };
      return html`
        <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" onClick=${props.onClose}>
          <div class="bg-white rounded-xl w-full ${sizes[props.size] || sizes.md} max-h-[90vh] overflow-hidden flex flex-col" onClick=${function(e) { e.stopPropagation(); }}>
            <div class="flex justify-between items-center p-4 border-b">
              <h3 class="text-lg font-bold">${props.title}</h3>
              <button onClick=${props.onClose} class="text-gray-500 hover:text-gray-700 text-2xl leading-none">×</button>
            </div>
            <div class="overflow-y-auto flex-1 p-4">${props.children}</div>
          </div>
        </div>
      `;
    }

    // 漫画生成アプリ（ログイン後）
    function MangaApp(props) {
      var user = props.user;
      var onSignOut = props.onSignOut;
      var s1 = useState(''); var apiKey = s1[0], setApiKey = s1[1];
      var s2 = useState(false); var apiSaved = s2[0], setApiSaved = s2[1];
      var s3 = useState(false); var showApi = s3[0], setShowApi = s3[1];
      var s4 = useState([]); var chars = s4[0], setChars = s4[1];
      var s5 = useState([null, null, null, null]); var selChars = s5[0], setSelChars = s5[1];
      var s6 = useState(1); var style = s6[0], setStyle = s6[1];
      var s7 = useState(null); var styleRef = s7[0], setStyleRef = s7[1];
      var s8 = useState([]); var favStyles = s8[0], setFavStyles = s8[1];
      var s9 = useState('formal'); var speech = s9[0], setSpeech = s9[1];
      var s10 = useState('4k'); var model = s10[0], setModel = s10[1];
      var s11 = useState(''); var story = s11[0], setStory = s11[1];
      var s12 = useState(1); var genCount = s12[0], setGenCount = s12[1];
      var s13 = useState([]); var genImages = s13[0], setGenImages = s13[1];
      var s14 = useState(0); var curImg = s14[0], setCurImg = s14[1];
      var s15 = useState(false); var isGen = s15[0], setIsGen = s15[1];
      var s16 = useState(0); var genIdx = s16[0], setGenIdx = s16[1];
      var s17 = useState(''); var error = s17[0], setError = s17[1];
      var s18 = useState([]); var history = s18[0], setHistory = s18[1];
      var s19 = useState([]); var favHist = s19[0], setFavHist = s19[1];
      var s20 = useState([]); var projects = s20[0], setProjects = s20[1];
      var s21 = useState(null); var curProj = s21[0], setCurProj = s21[1];
      var s22 = useState({ monthly: [], total: { count: 0, cost: 0 } }); var usage = s22[0], setUsage = s22[1];
      var s23 = useState(false); var sidebar = s23[0], setSidebar = s23[1];
      var s24 = useState(['char', 'style']); var accord = s24[0], setAccord = s24[1];
      var s25 = useState(null); var lastSave = s25[0], setLastSave = s25[1];
      var s26 = useState(false); var showTut = s26[0], setShowTut = s26[1];
      var s27 = useState(0); var tutStep = s27[0], setTutStep = s27[1];
      var s28 = useState(false); var showSamp = s28[0], setShowSamp = s28[1];
      var s29 = useState(false); var showHist = s29[0], setShowHist = s29[1];
      var s30 = useState(false); var showUsage = s30[0], setShowUsage = s30[1];
      var s31 = useState(false); var showAddChar = s31[0], setShowAddChar = s31[1];
      var s32 = useState(false); var showAddProj = s32[0], setShowAddProj = s32[1];
      var s33 = useState(false); var showImg = s33[0], setShowImg = s33[1];
      var s34 = useState(null); var modalImg = s34[0], setModalImg = s34[1];
      var s35 = useState(false); var showHistDet = s35[0], setShowHistDet = s35[1];
      var s36 = useState(null); var histDet = s36[0], setHistDet = s36[1];
      var s37 = useState(false); var showDraft = s37[0], setShowDraft = s37[1];
      var s38 = useState(null); var draft = s38[0], setDraft = s38[1];
      var s39 = useState(''); var newCharName = s39[0], setNewCharName = s39[1];
      var s40 = useState(null); var newCharImg = s40[0], setNewCharImg = s40[1];
      var s41 = useState(''); var newProjName = s41[0], setNewProjName = s41[1];
      var s42 = useState([]); var promptSteps = s42[0], setPromptSteps = s42[1];
      var s43 = useState(0); var currentStep = s43[0], setCurrentStep = s43[1];
      var s44 = useState(0); var totalSteps = s44[0], setTotalSteps = s44[1];
      var s45 = useState('simple'); var genMode = s45[0], setGenMode = s45[1];
      var s46 = useState(0); var modalImgIdx = s46[0], setModalImgIdx = s46[1];
      var s47 = useState(1); var charAbsentCount = s47[0], setCharAbsentCount = s47[1];
      var s48 = useState([]); var customStyles = s48[0], setCustomStyles = s48[1];
      var s49 = useState(false); var showAddStyle = s49[0], setShowAddStyle = s49[1];
      var s50 = useState(''); var newStyleTitle = s50[0], setNewStyleTitle = s50[1];
      var s51 = useState(''); var newStyleDesc = s51[0], setNewStyleDesc = s51[1];
      var s52 = useState(''); var newStylePrompt = s52[0], setNewStylePrompt = s52[1];
      var s53 = useState(false); var enableSubChars = s53[0], setEnableSubChars = s53[1];
      var s54 = useState([{name: '', features: ''}, {name: '', features: ''}, {name: '', features: ''}, {name: '', features: ''}]); var charDetails = s54[0], setCharDetails = s54[1];
      var s55 = useState(false); var showCharDetail = s55[0], setShowCharDetail = s55[1];
      var s56 = useState(0); var charDetailIdx = s56[0], setCharDetailIdx = s56[1];
      var s57 = useState(false); var showPanelHelp = s57[0], setShowPanelHelp = s57[1];
      var s58 = useState(false); var showAdvancedSettings = s58[0], setShowAdvancedSettings = s58[1];
      var s59 = useState(false); var showUserMenu = s59[0], setShowUserMenu = s59[1];
      var s60 = useState(false); var showEditStyle = s60[0], setShowEditStyle = s60[1];
      var s61 = useState(null); var editingStyleId = s61[0], setEditingStyleId = s61[1];
      var s62 = useState(''); var editStyleTitle = s62[0], setEditStyleTitle = s62[1];
      var s63 = useState(''); var editStyleDesc = s63[0], setEditStyleDesc = s63[1];
      var s64 = useState(''); var editStylePrompt = s64[0], setEditStylePrompt = s64[1];
      var s65 = useState(null); var draggedStyle = s65[0], setDraggedStyle = s65[1];
      var s66 = useState([]); var styleOrder = s66[0], setStyleOrder = s66[1];

      var fileRef = useRef(null);
      var charRefs = useRef([null, null, null, null]);
      var styleRefInput = useRef(null);
      var cancelRef = useRef(false);

      // 初期化
      useEffect(function() {
        try {
          var k = localStorage.getItem('manga_api_key');
          if (k) { setApiKey(k); setApiSaved(true); }
          var c = localStorage.getItem('manga_chars');
          if (c) setChars(JSON.parse(c));
          var f = localStorage.getItem('manga_fav_styles');
          if (f) setFavStyles(JSON.parse(f));
          var h = localStorage.getItem('manga_history');
          if (h) {
            try {
              var histData = JSON.parse(h);
              // 履歴が10件を超えている場合は削減
              if (histData.length > 10) {
                histData = histData.slice(0, 10);
                localStorage.setItem('manga_history', JSON.stringify(histData));
                console.log('履歴を10件に削減しました');
              }
              setHistory(histData);
            } catch(e) {
              console.error('履歴読み込みエラー:', e);
              // 破損している場合は空にする
              localStorage.setItem('manga_history', '[]');
              setHistory([]);
            }
          }
          var fh = localStorage.getItem('manga_fav_hist');
          if (fh) setFavHist(JSON.parse(fh));
          var p = localStorage.getItem('manga_projects');
          if (p) setProjects(JSON.parse(p));
          var u = localStorage.getItem('manga_usage');
          if (u) setUsage(JSON.parse(u));
          var t = localStorage.getItem('manga_tut_seen');
          if (!t) setShowTut(true);
          var d = localStorage.getItem('manga_draft');
          if (d) {
            var dd = JSON.parse(d);
            if (dd.story && dd.story.length > 0) { setDraft(dd); setShowDraft(true); }
          }
          var m = localStorage.getItem('manga_gen_mode');
          if (m) setGenMode(m);
          var ca = localStorage.getItem('manga_char_absent_count');
          if (ca) setCharAbsentCount(parseInt(ca, 10));
          var sc = localStorage.getItem('manga_enable_sub_chars');
          if (sc) setEnableSubChars(sc === 'true');
          var cd = localStorage.getItem('manga_char_details');
          if (cd) setCharDetails(JSON.parse(cd));
        } catch(e) { console.error(e); }
      }, []);

      // カスタムスタイル読み込み
      useEffect(function() {
        if (!user) return;
        supabase
          .from('custom_styles')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .then(function(result) {
            if (result.error) {
              console.error('カスタムスタイル読み込みエラー:', result.error);
            } else {
              setCustomStyles(result.data || []);
            }
          });
      }, [user]);

      // スタイル並び順の読み込み
      useEffect(function() {
        try {
          var order = localStorage.getItem('manga_style_order');
          if (order) setStyleOrder(JSON.parse(order));
        } catch(e) { console.error(e); }
      }, []);

      // ファイル名パース: "01_分析_text.txt" → { order: 1, name: "分析", type: "text" }
      function parseFileName(filename) {
        var parts = filename.replace('.txt', '').split('_');
        if (parts.length < 3) return null;
        return {
          order: parseInt(parts[0], 10),
          name: parts.slice(1, -1).join('_'),
          type: parts[parts.length - 1]
        };
      }

      // グロブパターンで試すファイル名候補
      function generateFilePatterns(num) {
        var numStr = String(num).padStart(2, '0');
        var names = ['分析', '構成', '設計', '詳細', '画像生成', 'analysis', 'structure', 'design', 'detail', 'image', 'generation'];
        var types = ['text', 'image'];
        var patterns = [];

        names.forEach(function(name) {
          types.forEach(function(type) {
            patterns.push(numStr + '_' + name + '_' + type + '.txt');
          });
        });

        return patterns;
      }

      // 1つの番号で最初に見つかったファイルを読み込む
      function tryLoadOneNumber(num) {
        var patterns = generateFilePatterns(num);

        return Promise.race(
          patterns.map(function(filename) {
            return fetch('./prompts/' + filename)
              .then(function(res) {
                if (!res.ok) throw new Error('Not found');
                return res.text().then(function(txt) {
                  var parsed = parseFileName(filename);
                  return {
                    file: filename,
                    name: parsed.name,
                    type: parsed.type,
                    template: txt,
                    order: parsed.order
                  };
                });
              });
          })
        ).catch(function() {
          return null;
        });
      }

      // プロンプトテンプレート読み込み（簡易版）
      useEffect(function() {
        function loadPrompts() {
          // モードに応じてファイルを選択
          var mode = localStorage.getItem('manga_gen_mode') || 'simple';
          var knownFiles;

          if (mode === 'simple') {
            knownFiles = [
              { file: '01_簡易_image.txt', name: '簡易', type: 'image', order: 1 }
            ];
          } else {
            knownFiles = [
              { file: '01_分析_text.txt', name: '分析', type: 'text', order: 1 },
              { file: '02_画像生成_image.txt', name: '画像生成', type: 'image', order: 2 }
            ];
          }

          var promises = knownFiles.map(function(fileInfo) {
            return fetch('./prompts/' + fileInfo.file)
              .then(function(res) {
                if (!res.ok) throw new Error('Not found');
                return res.text();
              })
              .then(function(template) {
                return {
                  file: fileInfo.file,
                  name: fileInfo.name,
                  type: fileInfo.type,
                  order: fileInfo.order,
                  template: template
                };
              })
              .catch(function(err) {
                console.warn('ファイル読み込み失敗:', fileInfo.file, err.message);
                return null;
              });
          });

          Promise.all(promises)
            .then(function(results) {
              var foundSteps = results.filter(function(r) { return r !== null; });

              if (foundSteps.length === 0) {
                console.error('プロンプトファイルが見つかりません。デフォルトを使用します。');
                foundSteps = [
                  { file: '01_分析_text.txt', name: '分析', type: 'text', template: getDefaultPromptStep1(), order: 1 },
                  { file: '02_画像生成_image.txt', name: '画像生成', type: 'image', template: getDefaultPromptStep2(), order: 2 }
                ];
              }

              foundSteps.sort(function(a, b) { return a.order - b.order; });
              setPromptSteps(foundSteps);
              setTotalSteps(foundSteps.length);
              console.log('プロンプト読み込み完了:', foundSteps.length + 'ステップ');
              foundSteps.forEach(function(s) {
                console.log('  ✓ ' + s.file + ' (' + s.name + ', ' + s.type + ')');
              });
            });
        }

        loadPrompts();
      }, [genMode]);

      // 下書き自動保存
      useEffect(function() {
        var timer = setTimeout(function() {
          try {
            localStorage.setItem('manga_draft', JSON.stringify({ story: story, style: style, speech: speech, model: model, genCount: genCount, ts: new Date().toISOString() }));
            setLastSave(new Date());
          } catch(e) {}
        }, 3000);
        return function() { clearTimeout(timer); };
      }, [story, style, speech, model, genCount]);

      // プレビューモーダルでのキーボード操作
      useEffect(function() {
        if (!showImg) return;

        function handleKeyDown(e) {
          if (e.key === 'ArrowLeft' && modalImgIdx > 0) {
            setModalImgIdx(modalImgIdx - 1);
          } else if (e.key === 'ArrowRight' && modalImgIdx < genImages.length - 1) {
            setModalImgIdx(modalImgIdx + 1);
          } else if (e.key === 'Escape') {
            setShowImg(false);
          }
        }

        window.addEventListener('keydown', handleKeyDown);
        return function() {
          window.removeEventListener('keydown', handleKeyDown);
        };
      }, [showImg, modalImgIdx, genImages.length]);

      function restoreDraft() {
        if (draft) {
          setStory(draft.story || '');
          setStyle(draft.style || 1);
          setSpeech(draft.speech || 'formal');
          setModel(draft.model || '4k');
          setGenCount(draft.genCount || 1);
        }
        setShowDraft(false);
      }

      function saveApi() {
        localStorage.setItem('manga_api_key', apiKey);
        setApiSaved(true);
      }

      function toggleFavStyle(id) {
        var nf = favStyles.indexOf(id) >= 0 ? favStyles.filter(function(x) { return x !== id; }) : favStyles.concat([id]);
        setFavStyles(nf);
        localStorage.setItem('manga_fav_styles', JSON.stringify(nf));
      }

      // 画像圧縮関数
      function compressImage(dataUrl, maxWidth, quality) {
        return new Promise(function(resolve) {
          var img = new Image();
          img.onload = function() {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');

            // アスペクト比を保持してリサイズ
            var width = img.width;
            var height = img.height;

            if (width > maxWidth) {
              height = Math.round((height * maxWidth) / width);
              width = maxWidth;
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            // 圧縮して新しいData URLを取得
            var compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
            resolve(compressedDataUrl);
          };
          img.src = dataUrl;
        });
      }

      function addChar() {
        if (!newCharName || !newCharImg) return;
        // 画像を圧縮してから保存（最大幅400px、品質0.6）
        compressImage(newCharImg, 400, 0.6).then(function(compressedImg) {
          var nc = { id: 'c_' + Date.now(), name: newCharName, img: compressedImg };
          var ncs = chars.concat([nc]);
          setChars(ncs);
          localStorage.setItem('manga_chars', JSON.stringify(ncs));
          setShowAddChar(false);
          setNewCharName('');
          setNewCharImg(null);
        });
      }

      function addCustomStyle() {
        if (!newStyleTitle || !newStylePrompt) {
          alert('タイトルとプロンプトは必須です');
          return;
        }

        console.log('カスタムスタイル追加開始:', { title: newStyleTitle, user_id: user.id });

        supabase
          .from('custom_styles')
          .insert([{
            user_id: user.id,
            title: newStyleTitle,
            description: newStyleDesc,
            prompt: newStylePrompt
          }])
          .then(function(result) {
            console.log('Insert結果:', result);
            if (result.error) {
              console.error('カスタムスタイル保存エラー:', result.error);
              alert('保存に失敗しました:\n' + result.error.message + '\n\n【確認事項】\n1. Supabaseでcustom_stylesテーブルを作成しましたか？\n2. ブラウザのコンソール(F12)でエラーを確認してください');
              return;
            }
            // 再読み込み
            return supabase
              .from('custom_styles')
              .select('*')
              .eq('user_id', user.id)
              .order('created_at', { ascending: false });
          })
          .then(function(result) {
            if (result && !result.error) {
              console.log('カスタムスタイル読み込み成功:', result.data);
              setCustomStyles(result.data || []);
              setShowAddStyle(false);
              setNewStyleTitle('');
              setNewStyleDesc('');
              setNewStylePrompt('');
              alert('カスタムスタイルを追加しました');
            } else if (result && result.error) {
              console.error('読み込みエラー:', result.error);
            }
          })
          .catch(function(error) {
            console.error('予期しないエラー:', error);
            alert('予期しないエラーが発生しました:\n' + error.message);
          });
      }

      function delCustomStyle(id) {
        if (!confirm('このカスタムスタイルを削除しますか？')) return;

        supabase
          .from('custom_styles')
          .delete()
          .eq('id', id)
          .eq('user_id', user.id)
          .then(function(result) {
            if (result.error) {
              console.error('削除エラー:', result.error);
              alert('削除に失敗しました');
            } else {
              setCustomStyles(customStyles.filter(function(s) { return s.id !== id; }));
              // 削除したスタイルが選択されていた場合はデフォルトに戻す
              if (style === 'custom_' + id) {
                setStyle(1);
              }
            }
          });
      }

      function editCustomStyle(id) {
        var cs = customStyles.find(function(s) { return s.id === id; });
        if (!cs) return;

        setEditingStyleId(id);
        setEditStyleTitle(cs.title);
        setEditStyleDesc(cs.description || '');
        setEditStylePrompt(cs.prompt);
        setShowEditStyle(true);
      }

      function updateCustomStyle() {
        if (!editStyleTitle || !editStylePrompt) {
          alert('タイトルとプロンプトは必須です');
          return;
        }

        supabase
          .from('custom_styles')
          .update({
            title: editStyleTitle,
            description: editStyleDesc,
            prompt: editStylePrompt
          })
          .eq('id', editingStyleId)
          .eq('user_id', user.id)
          .then(function(result) {
            if (result.error) {
              console.error('更新エラー:', result.error);
              alert('更新に失敗しました');
              return;
            }
            // 再読み込み
            return supabase
              .from('custom_styles')
              .select('*')
              .eq('user_id', user.id)
              .order('created_at', { ascending: false });
          })
          .then(function(result) {
            if (result && !result.error) {
              setCustomStyles(result.data || []);
              setShowEditStyle(false);
              setEditingStyleId(null);
              setEditStyleTitle('');
              setEditStyleDesc('');
              setEditStylePrompt('');
              alert('カスタムスタイルを更新しました');
            } else if (result && result.error) {
              console.error('読み込みエラー:', result.error);
            }
          });
      }

      function handleDragStart(e, styleId) {
        setDraggedStyle(styleId);
        e.dataTransfer.effectAllowed = 'move';
      }

      function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }

      function handleDrop(e, targetStyleId) {
        e.preventDefault();
        if (!draggedStyle || draggedStyle === targetStyleId) return;

        var allStyles = getAllStyles();
        var currentOrder = styleOrder.length > 0 ? styleOrder : allStyles.map(function(s) { return s.id; });

        var draggedIdx = currentOrder.indexOf(draggedStyle);
        var targetIdx = currentOrder.indexOf(targetStyleId);

        if (draggedIdx === -1 || targetIdx === -1) return;

        var newOrder = currentOrder.slice();
        newOrder.splice(draggedIdx, 1);
        newOrder.splice(targetIdx, 0, draggedStyle);

        setStyleOrder(newOrder);
        localStorage.setItem('manga_style_order', JSON.stringify(newOrder));
        setDraggedStyle(null);
      }

      function delChar(id) {
        if (!confirm('削除しますか？')) return;
        var ncs = chars.filter(function(c) { return c.id !== id; });
        setChars(ncs);
        localStorage.setItem('manga_chars', JSON.stringify(ncs));
        setSelChars(selChars.map(function(c) { return c && c.id === id ? null : c; }));
      }

      function handleFile(e, idx) {
        var f = e.target.files[0];
        if (!f) return;
        var r = new FileReader();
        r.onload = function(ev) {
          // 一時キャラクターも圧縮してメモリ使用量を削減
          compressImage(ev.target.result, 500, 0.7).then(function(compressedImg) {
            var nc = selChars.slice();
            nc[idx] = { id: 't_' + Date.now(), name: f.name, img: compressedImg, temp: true };
            setSelChars(nc);
          });
        };
        r.readAsDataURL(f);
      }

      function openCharDetail(idx) {
        setCharDetailIdx(idx);
        setShowCharDetail(true);
      }

      function updateCharDetail(idx, field, value) {
        var newDetails = charDetails.slice();
        newDetails[idx] = Object.assign({}, newDetails[idx], { [field]: value });
        setCharDetails(newDetails);
        localStorage.setItem('manga_char_details', JSON.stringify(newDetails));
      }

      // コマ情報を抽出
      function extractPanelInfo(storyText) {
        var panelPattern = /【コマ(\d+)】([^【]*)/g;
        var panels = [];
        var match;

        while ((match = panelPattern.exec(storyText)) !== null) {
          var content = match[2].trim();

          var panel = {
            number: panels.length + 1, // 自動的に1から振り直す
            position: '',
            size: '',
            speech: '',
            background: '',
            character: '',
            expression: '',
            cameraAngle: '',
            cameraDistance: '',
            content: '' // 内容フィールドを追加
          };

          // 各項目を抽出
          var posMatch = content.match(/位置[：:]\s*([^\n]+)/);
          if (posMatch) panel.position = posMatch[1].trim();

          var sizeMatch = content.match(/サイズ[：:]\s*([^\n]+)/);
          if (sizeMatch) panel.size = sizeMatch[1].trim();

          var speechMatch = content.match(/セリフ[：:]\s*([^\n]+)/);
          if (speechMatch) panel.speech = speechMatch[1].trim();

          var bgMatch = content.match(/背景[：:]\s*([^\n]+)/);
          if (bgMatch) panel.background = bgMatch[1].trim();

          var charMatch = content.match(/キャラ[：:]\s*([^\n]+)/);
          if (charMatch) panel.character = charMatch[1].trim();

          var exprMatch = content.match(/表情[：:]\s*([^\n]+)/);
          if (exprMatch) panel.expression = exprMatch[1].trim();

          var angleMatch = content.match(/カメラアングル[：:]\s*([^\n]+)/);
          if (angleMatch) panel.cameraAngle = angleMatch[1].trim();

          var distMatch = content.match(/カメラ距離[：:]\s*([^\n]+)/);
          if (distMatch) panel.cameraDistance = distMatch[1].trim();

          var contentMatch = content.match(/内容[：:]\s*([^\n]+)/);
          if (contentMatch) panel.content = contentMatch[1].trim();

          panels.push(panel);
        }

        return panels;
      }

      // コマ情報からレイアウト指示を生成
      function generateLayoutInstructions(panels) {
        if (panels.length === 0) return '';

        var instructions = '\n\n🚨🚨🚨 CRITICAL OVERRIDE - CUSTOM PANEL LAYOUT 🚨🚨🚨\n\n';
        instructions += '⚠️ THIS IS A ' + panels.length + '-PANEL MANGA, NOT A 4-PANEL MANGA ⚠️\n';
        instructions += '⚠️ REPEAT: ' + panels.length + ' PANELS ONLY. DO NOT CREATE 4 PANELS. ⚠️\n';
        instructions += '⚠️ IF YOU CREATE ' + (panels.length === 2 ? '3 OR 4' : panels.length === 3 ? '2 OR 4' : '2 OR 3') + ' PANELS, IT IS WRONG. ⚠️\n\n';

        instructions += '■ ABSOLUTE PANEL COUNT: ' + panels.length + ' panels (NO MORE, NO LESS)\n';
        instructions += '■ This overrides any default 4-panel instructions elsewhere in the prompt\n';
        instructions += '■ Panel count is MANDATORY and NON-NEGOTIABLE\n\n';

        instructions += '【DETAILED PANEL SPECIFICATIONS】\n\n';

        panels.forEach(function(panel) {
          instructions += '━━━ Panel ' + panel.number + ' of ' + panels.length + ' ━━━\n';
          if (panel.position) instructions += '📍 Position: ' + panel.position + '\n';
          if (panel.size) instructions += '📏 Size: ' + panel.size + '\n';
          if (panel.content) instructions += '🎬 Content: ' + panel.content + '\n';
          if (panel.speech) instructions += '💬 Speech: ' + panel.speech + '\n';
          if (panel.background) instructions += '🖼️  Background: ' + panel.background + '\n';
          if (panel.character) instructions += '👤 Character: ' + panel.character + '\n';
          if (panel.expression) instructions += '😊 Expression: ' + panel.expression + '\n';
          if (panel.cameraAngle) instructions += '📷 Camera Angle: ' + panel.cameraAngle + '\n';
          if (panel.cameraDistance) instructions += '🔭 Camera Distance: ' + panel.cameraDistance + '\n';
          instructions += '\n';
        });

        instructions += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n';
        instructions += '🔴 CRITICAL REQUIREMENTS:\n';
        instructions += '✓ Create EXACTLY ' + panels.length + ' panels (count them before generating)\n';
        instructions += '✓ Follow the exact positions and sizes specified above\n';
        instructions += '✓ Use the speech bubbles and content specified for each panel\n';
        instructions += '✓ Maintain 2:3 vertical aspect ratio for the entire image\n';
        instructions += '✓ Draw clear panel borders between panels\n';
        instructions += '✓ Ensure all ' + panels.length + ' panels fit within a single vertical image\n\n';

        instructions += '❌ DO NOT:\n';
        instructions += '× Create 4 panels (this is a ' + panels.length + '-panel manga)\n';
        instructions += '× Add extra panels beyond the ' + panels.length + ' specified\n';
        instructions += '× Ignore the custom layout instructions\n';
        instructions += '× Use default 4-panel layout\n\n';

        instructions += '🚨 REMINDER: This is a ' + panels.length + '-panel manga. Count: ' + panels.length + '. Not 4. (' + panels.length + ' panels) 🚨\n';

        return instructions;
      }

      // デフォルトプロンプト
      function getDefaultPromptStep1() {
        return 'あなたは漫画制作のプロンプトエンジニアです。\n以下のストーリー内容を分析し、4コマ漫画を生成するための詳細な画像生成プロンプトを作成してください。\n\n【出力形式】\n各コマごとに詳細を明記してください。\n\n---\n【ストーリー内容】\n{{STORY}}';
      }

      function getDefaultPromptStep2() {
        return '以下の指示に従って4コマ漫画を生成してください。\n\n{{GENERATED_PROMPT}}\n\n【画像全体の条件】\n・縦長1枚画像、アスペクト比 2:3\n・4K高解像度、カラー漫画';
      }

      // 変数置換
      function replaceVars(template, vars) {
        var result = template;
        Object.keys(vars).forEach(function(key) {
          var regex = new RegExp('{{' + key + '}}', 'g');
          result = result.replace(regex, vars[key]);
        });
        return result;
      }

      // すべてのスタイル（既定 + カスタム）を取得
      function getAllStyles() {
        var customStylesFormatted = customStyles.map(function(cs) {
          return {
            id: 'custom_' + cs.id,
            name: cs.title,
            desc: cs.description || '',
            prompt: cs.prompt,
            custom: true,
            dbId: cs.id
          };
        });
        return STYLES.concat(customStylesFormatted);
      }

      function genPrompt() {
        var allStyles = getAllStyles();
        var st = allStyles.find(function(s) { return s.id === style; });
        var hasC = selChars[1] !== null;
        var spt = (style === 99 && styleRef) ? '添付された参照画像の絵柄・色使い・雰囲気に忠実に合わせてください。' : st.prompt;
        var spch = speech === 'formal' ? '敬語（です・ます調）を基本とし、同じ語尾が連続しないよう3種類以上使い分ける' : 'タメ口（カジュアル）を基本とし、親しみやすく、語尾を3種類以上使い分ける';
        var charRule = hasC ? '【キャラクター】2人構成。1枚目の画像が説明役、2枚目が相談役' : '【キャラクター】1人で読者に語りかける形式';
        var refTxt = (selChars[2] || selChars[3]) ? '【参考画像】追加の参考画像を漫画内で適切に使用してください。' : '';
        return (hasC ? '2人' : '1人') + 'のキャラクターが会話形式で語るマンガを生成してください。\n\n【絵のテイスト】\n' + spt + '\n\n【セリフスタイル】\n' + spch + '\n\n' + charRule + '\n\n' + refTxt + '\n\n【画像条件】\n・縦長1枚、アスペクト比 2:3\n・上から縦に4コマ構成\n・日本語は縦書き、右から左\n・カラーのみ\n\n---\n【記事内容】\n' + story;
      }

      // 共通変数を取得
      function getCommonVars() {
        var allStyles = getAllStyles();
        var st = allStyles.find(function(s) { return s.id === style; });
        var hasC = selChars[1] !== null;
        var spt = (style === 99 && styleRef) ? '添付された参照画像の絵柄・色使い・雰囲気に忠実に合わせてください。' : st.prompt;

        // キャラクター登場パネル数に応じた文字数ガイドライン
        var charPresentPanels = 4 - charAbsentCount;
        var charCountGuide = '';
        if (charAbsentCount === 0) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：4コマ全て\n・総セリフ文字数：90-120文字（理想：100-110文字）\n・1パネルあたり平均：22-30文字';
        } else if (charAbsentCount === 1) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：3コマ\n・総セリフ文字数：70-90文字（理想：75-85文字）\n・1パネルあたり平均：23-30文字';
        } else if (charAbsentCount === 2) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：2コマ\n・総セリフ文字数：50-70文字（理想：55-65文字）\n・1パネルあたり平均：25-35文字';
        }

        var spch = speech === 'formal'
          ? '【セリフ・語尾のバリエーション（重要）】\n・敬語（です・ます調）を基本とする\n・同じ語尾が連続しないようにする\n・4コマ内で最低3種類以上の語尾パターンを使い分ける\n・以下から自然に混ぜる：\n　問いかけ系（〜ですか？／〜でしょうか）\n　説明系（〜なんです／〜ております）\n　展開系（〜ですが、／実は〜／つまり〜）\n　強調系（〜なのです／〜と言えます）\n　締め系（〜しましょう／〜してみてください）' + charCountGuide
          : '【セリフ・語尾のバリエーション（重要）】\n・タメ口（だ・である調、カジュアル）を基本とする\n・同じ語尾が連続しないようにする\n・4コマ内で最低3種類以上の語尾パターンを使い分ける\n・以下から自然に混ぜる：\n　問いかけ系（〜だよね？／〜じゃない？／〜かな？）\n　説明系（〜なんだ／〜だよ／〜ってこと）\n　展開系（〜だけど、／実は〜／つまり〜）\n　強調系（〜なんだよ！／〜だって！）\n　締め系（〜しよう／〜してみて／〜だね）\n・親しみやすく、フレンドリーなトーンで' + charCountGuide;
        // キャラクター不在パネルのルールを作成
        var absentPanelRule = '';
        if (charAbsentCount === 0) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n⚠️ CRITICAL: DO NOT include any character-absent panels\n- ALL 4 panels MUST show characters\n- Every panel must have the character(s) visible and present\n- Do NOT create panels with only backgrounds, diagrams, infographics, or objects\n- Do NOT create concept visualization panels\n- Do NOT create landscape-only panels\n- Characters must appear in ALL FOUR panels without exception\n\n・キャラクター不在パネルは一切不要です\n・全4パネルに必ずキャラクターを登場させてください\n・背景のみ、図解のみ、物のみのパネルは作成禁止です\n・4コマ全てにキャラクターが登場している必要があります';
        } else if (charAbsentCount === 1) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n- MUST include exactly 1 character-absent panel (no more, no less)\n- Character-present panels: 3 panels\n- Character-absent panels: 1 panel\n- These panels tell the story visually without characters\n- NO speech bubbles in character-absent panels\n- Include title/heading (10 characters max) using story keywords\n- Reflect specific story content, NOT generic imagery\n\n・キャラクター登場パネル：3パネル\n・キャラクター不在パネル：1パネル（必須）\n・不在パネルでは図解・イメージ等でストーリーを視覚的に表現';
        } else if (charAbsentCount === 2) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n- MUST include exactly 2 character-absent panels (no more, no less)\n- Character-present panels: 2 panels\n- Character-absent panels: 2 panels\n- These panels tell the story visually without characters\n- NO speech bubbles in character-absent panels\n- Include title/heading (10 characters max) using story keywords\n- Reflect specific story content, NOT generic imagery\n\n・キャラクター登場パネル：2パネル\n・キャラクター不在パネル：2パネル（必須）\n・不在パネルでは図解・イメージ等でストーリーを視覚的に表現';
        }

        var charRule = hasC
          ? '【キャラクター人数ルール】\n・メインの登場人物は2人（デザインは参考画像に従う）\n・1枚目の画像のキャラクター：説明役\n・2枚目の画像のキャラクター：相談者役\n・相談者は絶対に説明をさせないでください\n・背景内の説明用イメージ人物（歴史的人物など）は別扱い\n\n【キャラクター登場ルール】\n・1コマに2人が登場しなくてもいい\n・1コマに説明者のみ、相談者のみでもいい' + absentPanelRule
          : '【キャラクター人数ルール】\n・登場人物は1人のみ（参考画像のキャラクター）\n・読者に語りかける形式で進行\n・独白・説明形式で内容を伝える' + absentPanelRule;
        var charCountText = hasC ? '2人のキャラクター' : '1人のキャラクター';

        // サブキャラクター指示
        var subCharInstructions = enableSubChars
          ? '\n\n⚠️ SUPPORTING CHARACTER GENERATION:\n\n■ Additional Characters in Story:\n- If the story mentions additional characters (customers, clerks, friends, family members, etc.), you MUST include them in the manga\n- Generate these supporting characters appropriately based on their role in the story\n- Examples: If story mentions "お客様" (customer), create a customer character and show them in conversation panels\n- Supporting characters should be designed to fit the story context (e.g., business customer in suit, cafe customer in casual clothes)\n- Maintain consistency of supporting characters across panels if they appear multiple times\n\n■ Supporting Character Design:\n- Create supporting characters that are DISTINCT from main characters (different appearance, clothing, hairstyle)\n- Supporting characters should look realistic for their role (customers, staff, strangers, etc.)\n- Use appropriate age, gender, and appearance based on story context\n- Supporting characters can have simpler designs than main characters but must be clearly visible\n\n■ Interaction Panels:\n- When main characters talk to supporting characters, show BOTH in the same panel\n- Use appropriate camera angles to show conversation (e.g., over-the-shoulder shots, two-shot compositions)\n- Speech bubbles should clearly indicate who is speaking\n- Supporting characters can have dialogue as specified in the story\n\n■ Examples:\n- Story: "（お客様）「無料だと思ってました」" → Show a customer character speaking this line, with main character also visible\n- Story: "店員に聞いてみた" → Include a staff/clerk character in that panel\n- Story: "友人と話していた" → Show the friend character alongside main character'
          : '';

        // キャラクター詳細情報を追加
        var charDetailText = '';
        var hasDetails = false;
        for (var i = 0; i < 4; i++) {
          if (selChars[i] && (charDetails[i].name || charDetails[i].features)) {
            hasDetails = true;
            var roleName = i === 0 ? '説明者 (Explainer)' : i === 1 ? '相談者 (Questioner)' : '参考' + (i + 1);
            charDetailText += '\n- ' + roleName + ':';
            if (charDetails[i].name) charDetailText += ' 名前: ' + charDetails[i].name;
            if (charDetails[i].features) charDetailText += ' | 特徴: ' + charDetails[i].features;
          }
        }
        if (hasDetails) {
          charDetailText = '\n\n■ Additional Character Details (参考情報):\nUse the following details to enhance character accuracy:' + charDetailText + '\n';
        }

        // キャラクター外見の詳細指示を作成
        var charDesc = hasC
          ? '⚠️ CRITICAL CHARACTER REFERENCE IMAGE REQUIREMENT - HIGHEST PRIORITY:\n\n■ Reference Image Order:\n- 1st image: Main Explainer character (説明者)\n- 2nd image: Questioner character (相談者)\n' + (selChars[2] ? '- 3rd image: Additional reference\n' : '') + (selChars[3] ? '- 4th image: Additional reference\n' : '') + charDetailText + '\n■ Character Reproduction Requirement:\nYou MUST reproduce the character design from reference images with 100% FIDELITY:\n- Facial features: Face shape, eye shape, eye color, nose, mouth - EXACTLY as shown\n- Hairstyle: Hair length, style, bangs, volume - EXACTLY as shown\n- Hair color: Exact color shade, highlights, gradients - EXACTLY as shown\n- Clothing: Style, color, patterns, accessories - EXACTLY as shown\n- Body proportions: Height, build, posture - EXACTLY as shown\n- Art style: Line weight, coloring technique, shading style - EXACTLY as shown\n\n■ Critical Instructions:\n- DO NOT modify or "improve" the character design\n- DO NOT change clothing between panels unless story requires it\n- DO NOT add or remove accessories\n- The reference images define the ABSOLUTE visual identity\n- Any deviation from reference images is considered a critical error\n- Maintain PERFECT consistency across all 4 panels\n\n■ Character Role Distribution:\n- Explainer (1st image character): ~70% of dialogue, provides main information\n- Questioner (2nd image character): ~30% of dialogue, asks questions and responds\n- Both characters must maintain their exact appearance from reference images throughout' + subCharInstructions
          : '⚠️ CRITICAL CHARACTER REFERENCE IMAGE REQUIREMENT - HIGHEST PRIORITY:\n\n■ Reference Image:\n- 1st image: The main character (登場人物)\n' + (selChars[2] ? '- 2nd image: Additional reference\n' : '') + (selChars[3] ? '- 3rd image: Additional reference\n' : '') + charDetailText + '\n■ Character Reproduction Requirement:\nYou MUST reproduce the character design from the reference image with 100% FIDELITY:\n- Facial features: Face shape, eye shape, eye color, nose, mouth - EXACTLY as shown\n- Hairstyle: Hair length, style, bangs, volume - EXACTLY as shown\n- Hair color: Exact color shade, highlights, gradients - EXACTLY as shown\n- Clothing: Style, color, patterns, accessories - EXACTLY as shown\n- Body proportions: Height, build, posture - EXACTLY as shown\n- Art style: Line weight, coloring technique, shading style - EXACTLY as shown\n\n■ Critical Instructions:\n- DO NOT modify or "improve" the character design\n- DO NOT change clothing between panels unless story requires it\n- DO NOT add or remove accessories\n- The reference image defines the ABSOLUTE visual identity\n- Any deviation from reference image is considered a critical error\n- Maintain PERFECT consistency across all 4 panels\n- This character speaks directly to the reader in explanatory style' + subCharInstructions;

        // カスタムレイアウト情報を抽出
        var panels = extractPanelInfo(story);
        var customLayout = panels.length > 0 ? generateLayoutInstructions(panels) : '';

        return {
          STORY: story,
          STYLE_PROMPT: spt,
          SPEECH_STYLE: spch,
          CHARACTER_RULE: charRule,
          CHARACTER_COUNT: charCountText,
          CHARACTER_DESCRIPTION: charDesc,
          CUSTOM_LAYOUT: customLayout,
          PANEL_COUNT: panels.length > 0 ? panels.length.toString() : '4'
        };
      }

      // 単一ステップの実行
      function executeStep(stepIndex, stepOutputs) {
        var step = promptSteps[stepIndex];
        var commonVars = getCommonVars();

        // 変数マップを作成
        var vars = Object.assign({}, commonVars);

        // 前ステップの出力を追加
        if (stepIndex > 0) {
          vars.PREV_OUTPUT = stepOutputs[stepIndex - 1] || '';
        }

        // 各ステップの出力を追加
        stepOutputs.forEach(function(output, idx) {
          vars['STEP' + (idx + 1) + '_OUTPUT'] = output;
        });

        // 最終ステップの出力を追加
        if (stepOutputs.length > 0) {
          vars.GENERATED_PROMPT = stepOutputs[stepOutputs.length - 1];
        }

        var promptText = replaceVars(step.template, vars);
        console.log('===== Step ' + (stepIndex + 1) + ': ' + step.name + ' =====');
        console.log(promptText);

        if (step.type === 'image') {
          // 画像生成
          return executeImageGeneration(promptText);
        } else {
          // テキスト生成
          return executeTextGeneration(promptText);
        }
      }

      // テキスト生成
      function executeTextGeneration(promptText) {
        var body = {
          contents: [{ parts: [{ text: promptText }] }]
        };

        return fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=' + apiKey, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(function(res) {
          if (!res.ok) return res.json().then(function(err) { throw new Error(err.error ? err.error.message : 'Text API error'); });
          return res.json();
        })
        .then(function(data) {
          var txt = '';
          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            txt = data.candidates[0].content.parts[0].text || '';
          }
          console.log('生成結果:', txt.substring(0, 200) + '...');
          return txt;
        });
      }

      // 画像生成
      function executeImageGeneration(promptText) {
        var m = MODELS.find(function(x) { return x.id === model; });
        var parts = [];

        selChars.forEach(function(c) {
          if (c && c.img) {
            var b = c.img.split(',')[1];
            parts.push({ inlineData: { mimeType: 'image/png', data: b } });
          }
        });
        if (style === 99 && styleRef && styleRef.img) {
          var b = styleRef.img.split(',')[1];
          parts.push({ inlineData: { mimeType: 'image/png', data: b } });
        }

        var body = {
          system_instruction: { parts: [{ text: promptText }] },
          contents: [{ parts: parts }],
          generationConfig: {
            responseModalities: ['IMAGE'],
            temperature: 0.4,      // 一貫性重視：低めに設定（0.3-0.5推奨）
            topP: 0.85,           // より予測可能な出力
            topK: 40,             // 候補を絞る
            candidateCount: 1     // 1つの結果のみ生成
          }
        };

        return fetch('https://generativelanguage.googleapis.com/v1beta/models/' + m.model + ':generateContent?key=' + apiKey, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(function(res) {
          if (!res.ok) return res.json().then(function(err) { throw new Error(err.error ? err.error.message : 'Image API error'); });
          return res.json();
        })
        .then(function(data) {
          var img = null;
          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            data.candidates[0].content.parts.forEach(function(p) {
              if (p.inlineData) img = 'data:' + p.inlineData.mimeType + ';base64,' + p.inlineData.data;
            });
          }
          return img;
        });
      }

      // メイン生成関数（複数ステップ対応）
      function generate() {
        if (!apiKey) { setError('APIキーを設定してください'); return; }
        if (!selChars[0]) { setError('説明者を選択してください'); return; }
        if (!story || story.length < 20) { setError('20文字以上入力してください'); return; }
        if (promptSteps.length === 0) { setError('プロンプトが読み込まれていません'); return; }

        setIsGen(true);
        setError('');
        setGenImages([]);
        setCurImg(0);
        cancelRef.current = false;
        setCurrentStep(0);

        var m = MODELS.find(function(x) { return x.id === model; });
        var currentImages = new Array(genCount);  // 固定サイズ配列で並列実行に対応

        function generateOne(imgIndex) {
          if (cancelRef.current) {
            return Promise.reject(new Error('キャンセルされました'));
          }
          setGenIdx(imgIndex);

          var stepOutputs = [];
          var finalOutput = null;  // 最終的な画像出力を保持

          function executeSteps(stepIndex) {
            if (stepIndex >= promptSteps.length || cancelRef.current) {
              if (cancelRef.current) throw new Error('キャンセルされました');
              return Promise.resolve();
            }

            setCurrentStep(stepIndex + 1);

            return executeStep(stepIndex, stepOutputs)
              .then(function(output) {
                if (promptSteps[stepIndex].type === 'image') {
                  // 画像生成の場合、結果を保存
                  if (!output) throw new Error('画像の生成に失敗しました');

                  finalOutput = output;  // 最終出力を保存
                  currentImages[imgIndex] = output;
                  var completedImages = currentImages.filter(function(img) { return img !== undefined; });
                  setGenImages(completedImages);
                  setCurImg(completedImages.length - 1);

                  // 画像を圧縮して履歴に保存（最大幅400px、品質0.6で中程度圧縮）
                  compressImage(output, 400, 0.6).then(function(compressedImg) {
                    var st = STYLES.find(function(s) { return s.id === style; });
                    var hi = { id: 'g_' + Date.now() + '_' + imgIndex, img: compressedImg, settings: { style: style, styleName: st ? st.name : '', speech: speech, model: model, modelName: m.name, story: story.substring(0, 80) + '...' }, ts: new Date().toISOString() };

                    try {
                      var savedHist = localStorage.getItem('manga_history');
                      var histArr = savedHist ? JSON.parse(savedHist) : [];
                      histArr.unshift(hi);
                      if (histArr.length > 10) histArr = histArr.slice(0, 10);
                      localStorage.setItem('manga_history', JSON.stringify(histArr));
                      setHistory(histArr);
                    } catch(e) {
                      // QuotaExceededError対策: 古い履歴を削除して再試行
                      if (e.name === 'QuotaExceededError') {
                        console.warn('容量超過: 履歴を5件に削減して再試行');
                        try {
                          var reducedHist = [hi].concat(histArr.slice(0, 4));
                          localStorage.setItem('manga_history', JSON.stringify(reducedHist));
                          setHistory(reducedHist);
                        } catch(e2) {
                          // それでも失敗したら履歴を完全クリア
                          console.error('履歴保存失敗: 履歴をクリアします');
                          localStorage.setItem('manga_history', JSON.stringify([hi]));
                          setHistory([hi]);
                          alert('履歴の容量が限界に達したため、古い履歴を削除しました。');
                        }
                      } else {
                        console.error('履歴保存エラー:', e);
                      }
                    }

                    // 使用量記録
                    try {
                      var now = new Date();
                      var mk = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
                      var savedUsage = localStorage.getItem('manga_usage');
                      var usageData = savedUsage ? JSON.parse(savedUsage) : { monthly: [], total: { count: 0, cost: 0 } };
                      if (!usageData.monthly) usageData.monthly = [];
                      var md = usageData.monthly.find(function(x) { return x.month === mk; });
                      if (!md) { md = { month: mk, items: [] }; usageData.monthly.push(md); }
                      md.items.push({ date: now.toISOString(), model: model, price: m.price });
                      usageData.total.count = (usageData.total.count || 0) + 1;
                      usageData.total.cost = (usageData.total.cost || 0) + m.price;
                      localStorage.setItem('manga_usage', JSON.stringify(usageData));
                      setUsage(usageData);
                    } catch(e) {
                      console.error('使用量記録エラー:', e);
                    }
                  }).catch(function(e) {
                    console.error('画像圧縮エラー:', e);
                  });
                } else {
                  // テキスト生成の場合、次のステップの入力として保存
                  stepOutputs.push(output);
                }

                return executeSteps(stepIndex + 1);
              });
          }

          return executeSteps(0)
            .then(function() {
              setCurrentStep(0);
              return finalOutput;  // 完了した画像を返す
            })
            .catch(function(e) {
              console.error('画像' + (imgIndex + 1) + '生成エラー:', e);
              throw e;
            });
        }

        // 並列生成: 全ての画像を同時に生成
        var promises = [];
        for (var i = 0; i < genCount; i++) {
          promises.push(generateOne(i));
        }

        Promise.all(promises)
          .then(function() {
            setIsGen(false);
            setCurrentStep(0);
            console.log('全' + genCount + '枚の生成が完了しました');
          })
          .catch(function(e) {
            setError('エラー: ' + e.message);
            setIsGen(false);
            setCurrentStep(0);
          });
      }

      function dl(img, i) {
        var a = document.createElement('a');
        a.href = img;
        a.download = 'manga_' + Date.now() + '_' + (i + 1) + '.png';
        a.click();
      }

      function toggleFavHist(id) {
        var nf = favHist.indexOf(id) >= 0 ? favHist.filter(function(x) { return x !== id; }) : favHist.concat([id]);
        setFavHist(nf);
        localStorage.setItem('manga_fav_hist', JSON.stringify(nf));
      }

      function saveProj() {
        if (!newProjName) return;
        var p = { id: 'p_' + Date.now(), name: newProjName, settings: { selChars: selChars, style: style, styleRef: styleRef, speech: speech, model: model, charAbsentCount: charAbsentCount, enableSubChars: enableSubChars }, ts: new Date().toISOString() };
        var np = projects.concat([p]);
        setProjects(np);
        localStorage.setItem('manga_projects', JSON.stringify(np));
        setCurProj(p);
        setShowAddProj(false);
        setNewProjName('');
      }

      function loadProj(p) {
        var s = p.settings;
        if (s.selChars) setSelChars(s.selChars);
        if (s.style) setStyle(s.style);
        if (s.styleRef) setStyleRef(s.styleRef);
        if (s.speech) setSpeech(s.speech);
        if (s.model) setModel(s.model);
        if (s.charAbsentCount !== undefined) setCharAbsentCount(s.charAbsentCount);
        if (s.enableSubChars !== undefined) setEnableSubChars(s.enableSubChars);
        setCurProj(p);
      }

      function delProj(id) {
        if (!confirm('削除しますか？')) return;
        var np = projects.filter(function(p) { return p.id !== id; });
        setProjects(np);
        localStorage.setItem('manga_projects', JSON.stringify(np));
        if (curProj && curProj.id === id) setCurProj(null);
      }

      function clearProj() {
        setCurProj(null);
      }

      function exportProj(p) {
        var json = JSON.stringify(p, null, 2);
        var blob = new Blob([json], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'project_' + p.name + '_' + Date.now() + '.json';
        a.click();
        URL.revokeObjectURL(url);
      }

      function importProj() {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function(e) {
          var file = e.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function(ev) {
            try {
              var imported = JSON.parse(ev.target.result);
              imported.id = 'p_' + Date.now();
              imported.name = imported.name + ' (インポート)';
              var np = projects.concat([imported]);
              setProjects(np);
              localStorage.setItem('manga_projects', JSON.stringify(np));
              alert('プロジェクトをインポートしました');
            } catch(e) {
              alert('ファイルの読み込みに失敗しました');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function compTut() { localStorage.setItem('manga_tut_seen', '1'); setShowTut(false); setTutStep(0); }
      function togAccord(k) { setAccord(accord.indexOf(k) >= 0 ? accord.filter(function(x) { return x !== k; }) : accord.concat([k])); }

      // カスタムスタイルをSTYLES形式に変換
      var customStylesFormatted = customStyles.map(function(cs) {
        return {
          id: 'custom_' + cs.id,
          name: cs.title,
          desc: cs.description || '',
          prompt: cs.prompt,
          custom: true,
          dbId: cs.id
        };
      });

      // すべてのスタイル（既定 + カスタム）
      var allStyles = STYLES.concat(customStylesFormatted);

      var sortedStyles = allStyles.slice();

      // styleOrderが存在する場合はそれに従ってソート、なければお気に入りでソート
      if (styleOrder.length > 0) {
        sortedStyles.sort(function(a, b) {
          var aIdx = styleOrder.indexOf(a.id);
          var bIdx = styleOrder.indexOf(b.id);
          // 両方がstyleOrderに存在する場合はその順序
          if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
          // aのみstyleOrderに存在する場合はaを先に
          if (aIdx !== -1) return -1;
          // bのみstyleOrderに存在する場合はbを先に
          if (bIdx !== -1) return 1;
          // どちらもstyleOrderに存在しない場合はIDで比較
          return 0;
        });
      } else {
        sortedStyles.sort(function(a, b) {
          var aF = favStyles.indexOf(a.id) >= 0, bF = favStyles.indexOf(b.id) >= 0;
          return aF && !bF ? -1 : !aF && bF ? 1 : 0;
        });
      }

      function calcUsage() {
        var now = new Date();
        var mk = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
        var md = usage.monthly ? usage.monthly.find(function(m) { return m.month === mk; }) : null;
        if (!md || !md.items) return { count: 0, cost: 0, by: {} };
        var by = {}, cost = 0;
        md.items.forEach(function(item) {
          if (!by[item.model]) by[item.model] = { count: 0, cost: 0 };
          by[item.model].count++;
          by[item.model].cost += item.price;
          cost += item.price;
        });
        return { count: md.items.length, cost: cost, by: by };
      }
      var mu = calcUsage();

      function est() {
        var m = MODELS.find(function(x) { return x.id === model; });
        return { usd: (m.price * genCount).toFixed(2), jpy: Math.round(m.jpy * genCount) };
      }

      return html`
        <div class="flex min-h-screen">
          ${sidebar && html`<div class="md:hidden fixed inset-0 bg-black/50 z-40" onClick=${function() { setSidebar(false); }}></div>`}
          
          <div class="sidebar w-96 bg-white border-r p-5 overflow-y-auto flex-shrink-0 ${sidebar ? 'open' : ''}">
            <div class="flex items-center justify-between mb-6">
              <h1 class="text-xl font-bold text-gray-800">漫画クリエイター</h1>
              <button class="md:hidden text-gray-500 text-2xl" onClick=${function() { setSidebar(false); }}>×</button>
            </div>

            <div class="mb-4 p-4 bg-gray-50 rounded-lg">
              <div class="flex items-center mb-3">
                <span class="text-sm font-semibold text-gray-700">API設定</span>
                <${HelpIcon} text=${HELP.api} />
              </div>
              <div class="relative mb-2">
                <input type=${showApi ? 'text' : 'password'} value=${apiKey} onInput=${function(e) { setApiKey(e.target.value); setApiSaved(false); }} placeholder="APIキーを入力" class="w-full px-3 py-2 pr-16 border rounded-lg text-sm" />
                <button onClick=${function() { setShowApi(!showApi); }} class="absolute right-2 top-1/2 -translate-y-1/2 text-xs text-gray-500">${showApi ? '隠す' : '表示'}</button>
              </div>
              <button onClick=${saveApi} class="w-full py-2 bg-blue-500 text-white text-sm rounded-lg hover:bg-blue-600">保存</button>
              <div class="mt-2 text-xs ${apiSaved ? 'text-green-600' : 'text-amber-600'}">${apiSaved ? '保存済み' : '未保存'}</div>
            </div>

            <div class="mb-4">
              <div class="flex items-center justify-between mb-2">
                <span class="text-sm font-semibold text-gray-700">プロジェクト</span>
                <div class="flex gap-1">
                  ${curProj && html`<button onClick=${clearProj} class="text-xs text-gray-500 hover:text-gray-700" title="選択解除">解除</button>`}
                  <button onClick=${importProj} class="text-xs text-blue-500 hover:text-blue-700" title="インポート">↓</button>
                </div>
              </div>
              <div class="flex gap-2 overflow-x-auto pb-2 scrollbar-thin">
                ${projects.map(function(p) {
                  return html`
                    <div key=${p.id} class="relative flex-shrink-0 group">
                      <button
                        onClick=${function() { loadProj(p); }}
                        class="px-3 py-2 text-xs rounded-lg border ${curProj && curProj.id === p.id ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                      >
                        ${p.name}
                      </button>
                      <div class="absolute -top-1 -right-1 hidden group-hover:flex gap-1">
                        <button
                          onClick=${function(e) { e.stopPropagation(); exportProj(p); }}
                          class="w-4 h-4 bg-green-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-green-600"
                          title="エクスポート"
                        >↑</button>
                        <button
                          onClick=${function(e) { e.stopPropagation(); delProj(p.id); }}
                          class="w-4 h-4 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600"
                          title="削除"
                        >×</button>
                      </div>
                    </div>
                  `;
                })}
                <button onClick=${function() { setShowAddProj(true); }} class="flex-shrink-0 px-3 py-2 text-xs rounded-lg border border-dashed border-gray-300 text-gray-400 hover:bg-gray-50">+ 新規</button>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('lib'); }} class="flex items-center justify-between w-full text-left">
                <span class="text-sm font-semibold text-gray-700">キャラクターライブラリ</span>
                <span class="text-gray-400">${accord.indexOf('lib') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('lib') >= 0 ? 'open' : ''}">
                <div class="flex gap-2 overflow-x-auto py-2 scrollbar-thin">
                  ${chars.map(function(c) { return html`<div key=${c.id} class="flex-shrink-0 w-14 cursor-pointer" onContextMenu=${function(e) { e.preventDefault(); delChar(c.id); }}><img src=${c.img} class="w-14 h-14 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400" onClick=${function() { var idx = selChars.findIndex(function(x) { return x === null; }); if (idx >= 0) { var nc = selChars.slice(); nc[idx] = c; setSelChars(nc); } }} /><div class="text-xs text-center mt-1 truncate">${c.name}</div></div>`; })}
                  <button onClick=${function() { setShowAddChar(true); }} class="flex-shrink-0 w-14 h-14 border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center text-gray-400">+</button>
                </div>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('char'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">今回のキャラクター</span><${HelpIcon} text=${HELP.character} /></div>
                <span class="text-gray-400">${accord.indexOf('char') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('char') >= 0 ? 'open' : ''}">
                <div class="grid grid-cols-4 gap-2 py-2">
                  ${['説明者*', '相談者', '参考3', '参考4'].map(function(label, idx) { return html`<div key=${idx} class="border-2 ${selChars[idx] ? 'border-blue-400' : 'border-dashed border-gray-300'} rounded-lg p-1"><div class="text-xs text-gray-500 text-center mb-1">${label}</div>${selChars[idx] ? html`<div><div class="relative cursor-pointer" onClick=${function() { openCharDetail(idx); }}><img src=${selChars[idx].img} class="w-full h-14 object-cover rounded" /><button onClick=${function(e) { e.stopPropagation(); var nc = selChars.slice(); nc[idx] = null; setSelChars(nc); }} class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs">×</button></div><button onClick=${function() { openCharDetail(idx); }} class="text-xs text-blue-500 mt-1 hover:text-blue-600 w-full text-center">詳細を編集</button></div>` : html`<div class="h-14 flex items-center justify-center bg-gray-50 rounded cursor-pointer hover:bg-gray-100" onClick=${function() { charRefs.current[idx] && charRefs.current[idx].click(); }}><span class="text-gray-400 text-xs">+</span></div>`}<input ref=${function(el) { charRefs.current[idx] = el; }} type="file" accept="image/*" class="hidden" onChange=${function(e) { handleFile(e, idx); }} /></div>`; })}
                </div>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('style'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">絵のテイスト</span><${HelpIcon} text=${HELP.style} /></div>
                <span class="text-gray-400">${accord.indexOf('style') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('style') >= 0 ? 'open' : ''}">
                <div class="max-h-64 overflow-y-auto py-2 scrollbar-thin">
                  ${sortedStyles.map(function(s) { return html`<div key=${s.id} draggable="true" onDragStart=${function(e) { handleDragStart(e, s.id); }} onDragOver=${handleDragOver} onDrop=${function(e) { handleDrop(e, s.id); }} class="flex items-center p-2 rounded-lg ${style === s.id ? 'bg-blue-50 border-l-4 border-blue-500' : 'hover:bg-gray-50'} ${draggedStyle === s.id ? 'opacity-50' : ''}"><div class="cursor-move mr-2 text-gray-400 hover:text-gray-600" onMouseDown=${function(e) { e.stopPropagation(); }}>☰</div><label class="flex items-center flex-1 cursor-pointer"><input type="radio" name="style" checked=${style === s.id} onChange=${function() { setStyle(s.id); }} class="mr-2" /><div class="flex-1"><div class="text-sm">${s.name}</div><div class="text-xs text-gray-500">${s.desc}</div></div></label>${s.custom ? html`<div class="flex gap-2"><button onClick=${function(e) { e.preventDefault(); e.stopPropagation(); editCustomStyle(s.dbId); }} class="text-blue-500 hover:text-blue-700 text-sm">編集</button><button onClick=${function(e) { e.preventDefault(); e.stopPropagation(); delCustomStyle(s.dbId); }} class="text-red-500 hover:text-red-700 text-sm">削除</button></div>` : s.id !== 99 && html`<button onClick=${function(e) { e.preventDefault(); toggleFavStyle(s.id); }} class="${favStyles.indexOf(s.id) >= 0 ? 'text-yellow-500' : 'text-gray-300'}">${favStyles.indexOf(s.id) >= 0 ? '★' : '☆'}</button>`}</div>`; })}
                </div>
                <button
                  onClick=${function() { setShowAddStyle(true); }}
                  class="w-full mt-2 p-2 border-2 border-dashed border-blue-300 rounded-lg text-blue-600 hover:bg-blue-50 transition-colors flex items-center justify-center gap-2"
                >
                  <span class="text-xl">+</span>
                  <span class="text-sm">カスタムスタイル追加</span>
                </button>
                ${style === 99 && html`<div class="mt-2 p-2 border border-dashed rounded-lg"><div class="text-xs text-gray-500 mb-2">参照画像</div>${styleRef ? html`<div class="relative inline-block"><img src=${styleRef.img} class="h-16 rounded" /><button onClick=${function() { setStyleRef(null); }} class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs">×</button></div>` : html`<button onClick=${function() { styleRefInput.current && styleRefInput.current.click(); }} class="text-sm text-blue-500">+ 画像選択</button>`}<input ref=${styleRefInput} type="file" accept="image/*" class="hidden" onChange=${function(e) { var f = e.target.files[0]; if (!f) return; var r = new FileReader(); r.onload = function(ev) { setStyleRef({ img: ev.target.result }); }; r.readAsDataURL(f); }} /></div>`}
              </div>
            </div>


            <div class="mb-4">
              <button onClick=${function() { togAccord('model'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">モデル選択</span><${HelpIcon} text=${HELP.model} /></div>
                <span class="text-gray-400">${accord.indexOf('model') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('model') >= 0 ? 'open' : ''}">
                <div class="space-y-1 py-2">
                  ${MODELS.map(function(m) { return html`<label key=${m.id} class="flex items-center p-2 rounded-lg cursor-pointer ${model === m.id ? 'bg-blue-50' : 'hover:bg-gray-50'}"><input type="radio" checked=${model === m.id} onChange=${function() { setModel(m.id); }} class="mr-2" /><div class="flex-1"><div class="text-sm">${m.name}</div><div class="text-xs text-gray-500">${m.price > 0 ? '$' + m.price + '/枚' : '無料'}</div></div></label>`; })}
                </div>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('genmode'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">生成モード</span></div>
                <span class="text-gray-400">${accord.indexOf('genmode') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('genmode') >= 0 ? 'open' : ''}">
                <div class="space-y-2 py-2">
                  <button
                    onClick=${function() {
                      setGenMode('simple');
                      localStorage.setItem('manga_gen_mode', 'simple');
                    }}
                    class="w-full p-3 rounded-lg border-2 text-left ${genMode === 'simple' ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                  >
                    <div class="font-semibold text-sm">簡易モード</div>
                    <div class="text-xs text-gray-600 mt-1">1ステップで高速生成（デフォルト）</div>
                  </button>
                  <button
                    onClick=${function() {
                      setGenMode('analyze');
                      localStorage.setItem('manga_gen_mode', 'analyze');
                    }}
                    class="w-full p-3 rounded-lg border-2 text-left ${genMode === 'analyze' ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                  >
                    <div class="font-semibold text-sm">詳細モード</div>
                    <div class="text-xs text-gray-600 mt-1">2ステップで精密生成</div>
                  </button>
                </div>
              </div>
            </div>

            <div class="mb-4 border-t pt-4">
              <button onClick=${function() { setShowAdvancedSettings(!showAdvancedSettings); }} class="flex items-center justify-between w-full text-left">
                <span class="text-sm font-semibold text-gray-700">詳細設定</span>
                <span class="text-gray-400">${showAdvancedSettings ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${showAdvancedSettings ? 'open' : ''}">
                <div class="py-2 space-y-4">

                  <div>
                    <div class="text-sm font-medium text-gray-700 mb-2">サブキャラクター自動生成</div>
                    <label class="flex items-center cursor-pointer hover:bg-gray-50 p-2 rounded-lg">
                      <input
                        type="checkbox"
                        checked=${enableSubChars}
                        onChange=${function(e) {
                          setEnableSubChars(e.target.checked);
                          localStorage.setItem('manga_enable_sub_chars', e.target.checked);
                        }}
                        class="mr-2"
                      />
                      <div class="flex-1">
                        <div class="text-xs text-gray-600">ストーリーに登場する追加キャラクター（お客様、店員など）をAIが自動生成して登場させます</div>
                      </div>
                    </label>
                  </div>

                  <div>
                    <div class="text-sm font-medium text-gray-700 mb-2">セリフスタイル</div>
                    <div class="flex gap-2">
                      <label class="flex-1 flex items-center justify-center p-2 rounded-lg cursor-pointer border-2 ${speech === 'formal' ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}">
                        <input type="radio" checked=${speech === 'formal'} onChange=${function() { setSpeech('formal'); }} class="sr-only" />
                        <span class="text-sm">敬語</span>
                      </label>
                      <label class="flex-1 flex items-center justify-center p-2 rounded-lg cursor-pointer border-2 ${speech === 'casual' ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}">
                        <input type="radio" checked=${speech === 'casual'} onChange=${function() { setSpeech('casual'); }} class="sr-only" />
                        <span class="text-sm">タメ口</span>
                      </label>
                    </div>
                  </div>

                  <div>
                    <div class="text-sm font-medium text-gray-700 mb-2">キャラクター不在パネル</div>
                    <div class="flex gap-2">
                      ${[0, 1, 2].map(function(count) {
                        return html`
                          <button
                            key=${count}
                            onClick=${function() {
                              setCharAbsentCount(count);
                              localStorage.setItem('manga_char_absent_count', count);
                            }}
                            class="flex-1 p-2 rounded-lg border-2 text-center ${charAbsentCount === count ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                          >
                            <div class="text-sm font-semibold">${count === 0 ? 'なし' : count + '回'}</div>
                            <div class="text-xs text-gray-500 mt-1">${count === 0 ? '全4コマ' : (4 - count) + 'コマ登場'}</div>
                          </button>
                        `;
                      })}
                    </div>
                    <div class="text-xs text-gray-500 mt-2">
                      キャラクター不在パネルでは、図解・イメージ・クローズアップなどで内容を視覚的に表現します。
                    </div>
                  </div>

                </div>
              </div>
            </div>
          </div>

          <div class="flex-1 p-4 md:p-6 overflow-y-auto">
            <div class="md:hidden flex items-center justify-between mb-4">
              <button onClick=${function() { setSidebar(true); }} class="text-2xl">☰</button>
              <h1 class="text-lg font-bold">漫画クリエイター</h1>
              <div class="relative">
                <button
                  onClick=${function() { setShowUserMenu(!showUserMenu); }}
                  class="w-9 h-9 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 text-white flex items-center justify-center text-sm font-bold hover:shadow-lg transition-shadow"
                >
                  ${(user.user_metadata?.full_name || user.email || 'U').charAt(0).toUpperCase()}
                </button>
                ${showUserMenu && html`
                  <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50">
                    <div class="px-4 py-2 border-b border-gray-100">
                      <div class="text-xs text-gray-500">ログイン中</div>
                      <div class="text-sm font-medium text-gray-800 truncate">${user.user_metadata?.full_name || user.email}</div>
                    </div>
                    <button onClick=${function() { setShowTut(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-2">
                      <span>📖</span>
                      <span>使い方</span>
                    </button>
                    <button onClick=${function() { setShowSamp(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-2">
                      <span>🎨</span>
                      <span>サンプル</span>
                    </button>
                    <button onClick=${function() { setShowUsage(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-2">
                      <span>📊</span>
                      <span>使用量</span>
                    </button>
                    <div class="border-t border-gray-100 mt-1"></div>
                    <button onClick=${function() { onSignOut(); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50 flex items-center gap-2">
                      <span>🚪</span>
                      <span>ログアウト</span>
                    </button>
                  </div>
                `}
              </div>
            </div>

            <div class="hidden md:flex items-center justify-end mb-4 px-2">
              <div class="relative">
                <button
                  onClick=${function() { setShowUserMenu(!showUserMenu); }}
                  class="w-10 h-10 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 text-white flex items-center justify-center text-base font-bold hover:shadow-lg transition-shadow"
                >
                  ${(user.user_metadata?.full_name || user.email || 'U').charAt(0).toUpperCase()}
                </button>
                ${showUserMenu && html`
                  <div class="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50">
                    <div class="px-4 py-3 border-b border-gray-100">
                      <div class="text-xs text-gray-500">ログイン中</div>
                      <div class="text-sm font-medium text-gray-800 truncate">${user.user_metadata?.full_name || user.email}</div>
                    </div>
                    <button onClick=${function() { setShowTut(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-3">
                      <span class="text-lg">📖</span>
                      <span>使い方</span>
                    </button>
                    <button onClick=${function() { setShowSamp(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-3">
                      <span class="text-lg">🎨</span>
                      <span>サンプル</span>
                    </button>
                    <button onClick=${function() { setShowUsage(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 flex items-center gap-3">
                      <span class="text-lg">📊</span>
                      <span>使用量</span>
                    </button>
                    <div class="border-t border-gray-100 my-1"></div>
                    <button onClick=${function() { onSignOut(); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50 flex items-center gap-3">
                      <span class="text-lg">🚪</span>
                      <span>ログアウト</span>
                    </button>
                  </div>
                `}
              </div>
            </div>

            <div class="mb-6">
              <div class="flex items-center mb-2"><span class="text-lg font-semibold text-gray-700">ストーリー・記事内容</span><${HelpIcon} text=${HELP.story} /></div>
              <textarea value=${story} onInput=${function(e) { setStory(e.target.value); }} placeholder="漫画にしたい内容を入力..." class="w-full h-40 p-4 border rounded-lg resize-y"></textarea>
              <div class="flex justify-between text-xs text-gray-500 mt-1">
                <span>${lastSave ? '自動保存 ' + lastSave.toLocaleTimeString() : ''}</span>
                <span>${story.length}文字</span>
              </div>
              <div class="text-xs text-gray-600 mt-2">
                詳細なコマ設定: 位置 / サイズ / 内容 / セリフ / 背景 / キャラ / 表情 / カメラアングル / カメラ距離
                <button onClick=${function() { setShowPanelHelp(true); }} class="text-blue-500 hover:text-blue-600 ml-2">
                  [詳細を見る]
                </button>
              </div>
            </div>

            <div class="mb-6 p-4 bg-gray-50 rounded-lg flex flex-wrap items-center gap-4">
              <span class="text-sm text-gray-700">生成枚数</span>
              <div class="flex gap-2">${[1, 2, 3, 4, 5].map(function(n) { return html`<button key=${n} onClick=${function() { setGenCount(n); }} class="w-10 h-10 rounded-lg border-2 ${genCount === n ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">${n}</button>`; })}</div>
              <div class="text-sm text-gray-600">予想: $${est().usd}（約${est().jpy}円）</div>
            </div>

            <div class="mb-6">
              ${isGen ? html`
                <div class="p-4 bg-blue-50 rounded-lg">
                  <div class="flex items-center justify-between mb-2">
                    <div>
                      <div class="font-semibold">生成中... ${genIdx + 1}/${genCount}枚</div>
                      ${currentStep > 0 && totalSteps > 0 && html`<div class="text-sm text-blue-700 mt-1">Step ${currentStep}/${totalSteps}: ${promptSteps[currentStep - 1] ? promptSteps[currentStep - 1].name : ''}中...</div>`}
                    </div>
                    <button onClick=${function() { cancelRef.current = true; }} class="px-4 py-2 bg-red-500 text-white text-sm rounded-lg">停止</button>
                  </div>
                  <div class="w-full bg-gray-200 rounded-full h-2"><div class="bg-blue-500 h-2 rounded-full transition-all" style=${{ width: ((genIdx + 1) / genCount * 100) + '%' }}></div></div>
                  ${currentStep > 0 && totalSteps > 0 && html`
                    <div class="mt-2 flex items-center gap-2 text-xs text-blue-600 overflow-x-auto">
                      ${promptSteps.map(function(step, idx) {
                        var stepNum = idx + 1;
                        var isActive = stepNum === currentStep;
                        var isDone = stepNum < currentStep;
                        return html`
                          <div key=${idx} class="flex items-center gap-1 flex-shrink-0">
                            <div class="w-2 h-2 rounded-full ${isActive ? 'bg-blue-500 animate-pulse' : isDone ? 'bg-green-500' : 'bg-gray-300'}"></div>
                            <span class="${isActive ? 'font-semibold' : ''}">${step.name}</span>
                          </div>
                          ${idx < promptSteps.length - 1 && html`<span class="flex-shrink-0">→</span>`}
                        `;
                      })}
                    </div>
                  `}
                  ${genImages.length > 0 && html`<div class="mt-4 flex gap-2 overflow-x-auto">${genImages.map(function(img, i) { return html`<img key=${i} src=${img} class="w-20 h-28 object-cover rounded-lg cursor-pointer border-2 ${curImg === i ? 'border-blue-500' : 'border-gray-200'}" onClick=${function() { setCurImg(i); }} />`; })}</div>`}
                </div>
              ` : html`<button onClick=${generate} disabled=${!apiSaved} class="w-full py-4 bg-gradient-to-r from-orange-500 to-orange-600 text-white text-lg font-bold rounded-lg disabled:opacity-50">漫画を生成（${genCount}枚）</button>`}
              ${error && html`<div class="text-red-600 text-sm mt-2 text-center">${error}</div>`}
            </div>

            <div class="mb-6">
              <div class="flex items-center justify-between mb-2">
                <span class="text-lg font-semibold text-gray-700">生成された漫画</span>
                ${genImages.length > 0 && html`<span class="text-sm text-gray-500">${curImg + 1}/${genImages.length}枚</span>`}
              </div>
              <div class="bg-gray-100 rounded-lg p-4 min-h-64 flex items-center justify-center relative">
                ${genImages.length > 0 ? html`
                  ${curImg > 0 && html`
                    <button
                      onClick=${function() { setCurImg(curImg - 1); }}
                      class="absolute left-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                    >
                      ←
                    </button>
                  `}
                  <img
                    src=${genImages[curImg]}
                    class="max-w-full max-h-[500px] rounded-lg shadow-lg cursor-pointer"
                    onClick=${function() { setModalImg(genImages[curImg]); setModalImgIdx(curImg); setShowImg(true); }}
                  />
                  ${curImg < genImages.length - 1 && html`
                    <button
                      onClick=${function() { setCurImg(curImg + 1); }}
                      class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                    >
                      →
                    </button>
                  `}
                ` : html`<div class="text-gray-400 text-center"><div class="text-4xl mb-2">○</div><div>ここに漫画が表示されます</div></div>`}
              </div>
              ${genImages.length > 1 && html`<div class="flex justify-center gap-2 mt-4">${genImages.map(function(_, i) { return html`<button key=${i} onClick=${function() { setCurImg(i); }} class="w-10 h-10 rounded-lg border-2 ${curImg === i ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">${i + 1}</button>`; })}</div>`}
              ${genImages.length > 0 && html`<div class="flex gap-3 mt-4 justify-center"><button onClick=${function() { dl(genImages[curImg], curImg); }} class="px-4 py-2 bg-blue-500 text-white text-sm rounded-lg">ダウンロード</button><button onClick=${function() { setGenImages([]); }} class="px-4 py-2 bg-gray-500 text-white text-sm rounded-lg">クリア</button></div>`}
            </div>

            ${history.length > 0 && html`
              <div>
                <div class="flex items-center justify-between mb-2"><span class="text-lg font-semibold text-gray-700">生成履歴</span><button onClick=${function() { setShowHist(true); }} class="text-sm text-blue-500">すべて見る</button></div>
                <div class="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">${history.slice(0, 5).map(function(h) { return html`<div key=${h.id} class="flex-shrink-0 cursor-pointer relative" onClick=${function() { setHistDet(h); setShowHistDet(true); }}>${favHist.indexOf(h.id) >= 0 && html`<div class="absolute top-1 left-1 text-yellow-500">★</div>`}<img src=${h.img} class="w-20 h-28 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400" /></div>`; })}</div>
              </div>
            `}
          </div>

          <${Modal} isOpen=${showTut} onClose=${function() {}} title="使い方" size="md">
            <div class="text-center">
              <div class="flex justify-center gap-1 mb-4">${TUTORIAL.map(function(_, i) { return html`<div key=${i} class="w-3 h-3 rounded-full ${i === tutStep ? 'bg-blue-500' : 'bg-gray-300'}"></div>`; })}</div>
              <h4 class="text-xl font-bold mb-4">${TUTORIAL[tutStep].title}</h4>
              <p class="text-gray-700 mb-6 min-h-24 whitespace-pre-wrap">${TUTORIAL[tutStep].content}</p>
              <div class="flex justify-between">
                <button onClick=${function() { setTutStep(Math.max(0, tutStep - 1)); }} class="px-4 py-2 text-gray-600" disabled=${tutStep === 0}>← 戻る</button>
                <button onClick=${compTut} class="px-4 py-2 text-gray-500">スキップ</button>
                ${tutStep < TUTORIAL.length - 1 ? html`<button onClick=${function() { setTutStep(tutStep + 1); }} class="px-4 py-2 bg-blue-500 text-white rounded-lg">次へ →</button>` : html`<button onClick=${compTut} class="px-4 py-2 bg-blue-500 text-white rounded-lg">始める</button>`}
              </div>
            </div>
          <//>

          <${Modal} isOpen=${showSamp} onClose=${function() { setShowSamp(false); }} title="サンプルギャラリー" size="lg">
            <p class="text-gray-600 mb-4">このツールで作成できる漫画の例です</p>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">${SAMPLES.map(function(s) { return html`<div key=${s.id} class="border rounded-lg p-3"><div class="bg-gray-200 h-32 rounded mb-2 flex items-center justify-center text-gray-400 text-sm">サンプル画像</div><div class="text-sm font-semibold">${s.title}</div><div class="text-xs text-gray-500">${s.cat}</div></div>`; })}</div>
          <//>

          <${Modal} isOpen=${showHist} onClose=${function() { setShowHist(false); }} title="生成履歴" size="lg">
            <div class="grid grid-cols-3 md:grid-cols-4 gap-3">${history.map(function(h) { return html`<div key=${h.id} class="cursor-pointer relative" onClick=${function() { setHistDet(h); setShowHistDet(true); setShowHist(false); }}>${favHist.indexOf(h.id) >= 0 && html`<div class="absolute top-1 left-1 text-yellow-500 z-10">★</div>`}<img src=${h.img} class="w-full h-32 object-cover rounded-lg border-2 border-gray-200" /></div>`; })}</div>
          <//>

          <${Modal} isOpen=${showHistDet} onClose=${function() { setShowHistDet(false); }} title="詳細" size="lg">
            ${histDet && html`<div class="flex flex-col md:flex-row gap-4"><div class="flex-1"><img src=${histDet.img} class="w-full rounded-lg cursor-pointer" onClick=${function() { setModalImg(histDet.img); setShowImg(true); }} /></div><div class="flex-1"><h4 class="font-semibold mb-2">生成設定</h4><div class="space-y-2 text-sm"><div>テイスト: ${histDet.settings ? histDet.settings.styleName : '-'}</div><div>セリフ: ${histDet.settings && histDet.settings.speech === 'formal' ? '敬語' : 'タメ口'}</div><div>モデル: ${histDet.settings ? histDet.settings.modelName : '-'}</div><div>日時: ${new Date(histDet.ts).toLocaleString()}</div></div><div class="flex gap-2 mt-4"><button onClick=${function() { toggleFavHist(histDet.id); }} class="px-3 py-2 border rounded-lg ${favHist.indexOf(histDet.id) >= 0 ? 'border-yellow-500 bg-yellow-50' : ''}">${favHist.indexOf(histDet.id) >= 0 ? '★ 解除' : '☆ 登録'}</button><button onClick=${function() { dl(histDet.img, 0); }} class="px-3 py-2 bg-blue-500 text-white rounded-lg">DL</button></div></div></div>`}
          <//>

          <${Modal} isOpen=${showUsage} onClose=${function() { setShowUsage(false); }} title="使用量" size="md">
            <div class="space-y-4">
              <div><h4 class="font-semibold mb-2">今月</h4><div class="bg-gray-50 rounded-lg p-4"><div class="text-2xl font-bold">${mu.count}枚</div><div class="text-gray-600">推定: $${mu.cost.toFixed(2)}</div></div></div>
              <div><h4 class="font-semibold mb-2">累計</h4><div class="bg-gray-50 rounded-lg p-4"><div class="flex justify-between"><span>総枚数</span><span class="font-bold">${usage.total ? usage.total.count : 0}枚</span></div><div class="flex justify-between"><span>累計</span><span class="font-bold">$${usage.total ? usage.total.cost.toFixed(2) : '0.00'}</span></div></div></div>
            </div>
          <//>

          <${Modal} isOpen=${showAddChar} onClose=${function() { setShowAddChar(false); setNewCharName(''); setNewCharImg(null); }} title="キャラクター追加" size="sm">
            <input type="text" value=${newCharName} onInput=${function(e) { setNewCharName(e.target.value); }} placeholder="名前" class="w-full px-3 py-2 border rounded-lg mb-4" />
            <div class="border-2 border-dashed rounded-lg p-4 mb-4 text-center cursor-pointer" onClick=${function() { fileRef.current && fileRef.current.click(); }}>${newCharImg ? html`<img src=${newCharImg} class="max-h-32 mx-auto rounded" />` : html`<div class="text-gray-400"><div class="text-3xl mb-2">+</div><div>画像を選択</div></div>`}</div>
            <input ref=${fileRef} type="file" accept="image/*" class="hidden" onChange=${function(e) { var f = e.target.files[0]; if (!f) return; var r = new FileReader(); r.onload = function(ev) { setNewCharImg(ev.target.result); }; r.readAsDataURL(f); }} />
            <div class="flex gap-3"><button onClick=${function() { setShowAddChar(false); setNewCharName(''); setNewCharImg(null); }} class="flex-1 py-2 border rounded-lg">キャンセル</button><button onClick=${addChar} disabled=${!newCharName || !newCharImg} class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50">追加</button></div>
          <//>

          <${Modal} isOpen=${showAddProj} onClose=${function() { setShowAddProj(false); setNewProjName(''); }} title="プロジェクト保存" size="sm">
            <p class="text-sm text-gray-600 mb-4">現在の設定を保存します</p>
            <input type="text" value=${newProjName} onInput=${function(e) { setNewProjName(e.target.value); }} placeholder="プロジェクト名" class="w-full px-3 py-2 border rounded-lg mb-4" />
            <div class="flex gap-3"><button onClick=${function() { setShowAddProj(false); setNewProjName(''); }} class="flex-1 py-2 border rounded-lg">キャンセル</button><button onClick=${saveProj} disabled=${!newProjName} class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50">保存</button></div>
          <//>

          <${Modal} isOpen=${showAddStyle} onClose=${function() { setShowAddStyle(false); setNewStyleTitle(''); setNewStyleDesc(''); setNewStylePrompt(''); }} title="カスタムスタイル追加" size="md">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">タイトル *</label>
                <input
                  type="text"
                  value=${newStyleTitle}
                  onInput=${function(e) { setNewStyleTitle(e.target.value); }}
                  placeholder="例: アニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="50"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">説明</label>
                <input
                  type="text"
                  value=${newStyleDesc}
                  onInput=${function(e) { setNewStyleDesc(e.target.value); }}
                  placeholder="例: ジブリ作品のような温かみのあるアニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="100"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">プロンプト *</label>
                <textarea
                  value=${newStylePrompt}
                  onInput=${function(e) { setNewStylePrompt(e.target.value); }}
                  placeholder="例: Studio Ghibli anime illustration style with warm watercolor backgrounds..."
                  class="w-full px-3 py-2 border rounded-lg h-32 resize-none"
                ></textarea>
                <p class="text-xs text-gray-500 mt-1">画像生成に使用されるプロンプトを入力してください</p>
              </div>
              <div class="flex gap-3">
                <button
                  onClick=${function() { setShowAddStyle(false); setNewStyleTitle(''); setNewStyleDesc(''); setNewStylePrompt(''); }}
                  class="flex-1 py-2 border rounded-lg hover:bg-gray-50"
                >
                  キャンセル
                </button>
                <button
                  onClick=${addCustomStyle}
                  disabled=${!newStyleTitle || !newStylePrompt}
                  class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600"
                >
                  追加
                </button>
              </div>
            </div>
          <//>

          <${Modal} isOpen=${showEditStyle} onClose=${function() { setShowEditStyle(false); setEditingStyleId(null); setEditStyleTitle(''); setEditStyleDesc(''); setEditStylePrompt(''); }} title="カスタムスタイル編集" size="md">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">タイトル *</label>
                <input
                  type="text"
                  value=${editStyleTitle}
                  onInput=${function(e) { setEditStyleTitle(e.target.value); }}
                  placeholder="例: アニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="50"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">説明</label>
                <input
                  type="text"
                  value=${editStyleDesc}
                  onInput=${function(e) { setEditStyleDesc(e.target.value); }}
                  placeholder="例: ジブリ作品のような温かみのあるアニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="100"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">プロンプト *</label>
                <textarea
                  value=${editStylePrompt}
                  onInput=${function(e) { setEditStylePrompt(e.target.value); }}
                  placeholder="例: Studio Ghibli anime illustration style with warm watercolor backgrounds..."
                  class="w-full px-3 py-2 border rounded-lg h-32 resize-none"
                ></textarea>
                <p class="text-xs text-gray-500 mt-1">画像生成に使用されるプロンプトを入力してください</p>
              </div>
              <div class="flex gap-3">
                <button
                  onClick=${function() { setShowEditStyle(false); setEditingStyleId(null); setEditStyleTitle(''); setEditStyleDesc(''); setEditStylePrompt(''); }}
                  class="flex-1 py-2 border rounded-lg hover:bg-gray-50"
                >
                  キャンセル
                </button>
                <button
                  onClick=${updateCustomStyle}
                  disabled=${!editStyleTitle || !editStylePrompt}
                  class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600"
                >
                  更新
                </button>
              </div>
            </div>
          <//>

          ${showImg && html`
            <div class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
              <div class="bg-white rounded-xl w-full max-w-7xl h-[90vh] overflow-hidden flex flex-col">
                <div class="flex justify-between items-center p-4 border-b">
                  <h3 class="text-lg font-bold">プレビュー</h3>
                  <button onClick=${function() { setShowImg(false); }} class="text-gray-500 hover:text-gray-700 text-2xl leading-none">×</button>
                </div>
                <div class="flex gap-4 flex-1 overflow-hidden">
                  <div class="flex-1 flex items-center justify-center bg-gray-900 p-4">
                    <img
                      src=${genImages[modalImgIdx]}
                      class="max-h-full max-w-full object-contain"
                    />
                  </div>
                  <div class="w-64 p-4 flex flex-col gap-4 overflow-y-auto">
                    <div class="flex flex-col gap-3">
                      ${modalImgIdx > 0 && html`
                        <button
                          onClick=${function() { setModalImgIdx(modalImgIdx - 1); }}
                          class="w-full py-3 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors text-center"
                        >
                          ← 前へ
                        </button>
                      `}
                      <div class="text-center text-gray-600 py-2">
                        ${modalImgIdx + 1} / ${genImages.length}
                      </div>
                      ${modalImgIdx < genImages.length - 1 && html`
                        <button
                          onClick=${function() { setModalImgIdx(modalImgIdx + 1); }}
                          class="w-full py-3 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors text-center"
                        >
                          次へ →
                        </button>
                      `}
                    </div>
                    <a
                      href=${genImages[modalImgIdx]}
                      download=${'manga_' + (modalImgIdx + 1) + '_' + Date.now() + '.png'}
                      class="w-full py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-center block"
                    >
                      ダウンロード
                    </a>
                    ${genImages.length > 1 && html`
                      <div class="border-t pt-4">
                        <div class="text-sm font-medium text-gray-700 mb-2">他の画像</div>
                        <div class="space-y-2">
                          ${genImages.map(function(img, i) {
                            return html`
                              <img
                                key=${i}
                                src=${img}
                                onClick=${function() { setModalImgIdx(i); }}
                                class="w-full h-32 object-cover rounded cursor-pointer border-2 ${modalImgIdx === i ? 'border-blue-500' : 'border-gray-300'} hover:border-blue-400 transition-all"
                              />
                            `;
                          })}
                        </div>
                      </div>
                    `}
                  </div>
                </div>
              </div>
            </div>
          `}

          <${Modal} isOpen=${showDraft} onClose=${function() { setShowDraft(false); }} title="下書きが見つかりました" size="sm">
            <p class="text-gray-600 mb-4">前回の作業内容を復元しますか？</p>
            ${draft && html`<div class="bg-gray-50 rounded-lg p-3 mb-4 text-sm"><div class="text-gray-500">保存: ${new Date(draft.ts).toLocaleString()}</div><div class="text-gray-700 mt-1 truncate">「${draft.story ? draft.story.substring(0, 50) : ''}...」</div></div>`}
            <div class="flex gap-3"><button onClick=${function() { setShowDraft(false); localStorage.removeItem('manga_draft'); }} class="flex-1 py-2 border rounded-lg">破棄</button><button onClick=${restoreDraft} class="flex-1 py-2 bg-blue-500 text-white rounded-lg">復元</button></div>
          <//>

          <${Modal} isOpen=${showCharDetail} onClose=${function() { setShowCharDetail(false); }} title="キャラクター詳細設定" size="md">
            <div class="flex flex-col items-center">
              ${selChars[charDetailIdx] && html`
                <img src=${selChars[charDetailIdx].img} class="w-48 h-48 object-cover rounded-lg mb-4 border-2 border-blue-400" />
                <div class="w-full space-y-3">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">キャラクター名（任意）</label>
                    <input
                      type="text"
                      placeholder="例: 美咲"
                      maxLength="10"
                      value=${charDetails[charDetailIdx].name}
                      onInput=${function(e) { updateCharDetail(charDetailIdx, 'name', e.target.value); }}
                      class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    />
                    <p class="text-xs text-gray-500 mt-1">最大10文字</p>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">キャラクター特徴（任意）</label>
                    <textarea
                      placeholder="例: 黒髪ロングヘア、青い瞳${'\n'}白いシャツに黒いスカート${'\n'}優しくて落ち着いた雰囲気"
                      maxLength="200"
                      value=${charDetails[charDetailIdx].features}
                      onInput=${function(e) { updateCharDetail(charDetailIdx, 'features', e.target.value); }}
                      class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none"
                      rows="5"
                    ></textarea>
                    <p class="text-xs text-gray-500 mt-1">最大200文字 | ${charDetails[charDetailIdx].features.length}/200</p>
                  </div>
                  <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600">※これらの情報は任意入力です。画像生成時にAIへのヒントとして使用されます。</p>
                  </div>
                </div>
              `}
            </div>
          <//>

          <${Modal} isOpen=${showPanelHelp} onClose=${function() { setShowPanelHelp(false); }} title="コマ別の詳細指定ガイド" size="lg">
            <div class="space-y-4">
              <div class="mb-4">
                <h4 class="font-semibold text-gray-800 mb-2">この機能について</h4>
                <p class="text-sm text-gray-700">
                  ストーリー入力欄で <strong>【コマN】</strong> の形式を使うと、各コマの詳細を個別に指定できます。<br />
                  2〜4コマの漫画を作る場合や、特定のコマだけ詳しく指定したい場合に便利です。
                </p>
              </div>

              <div class="space-y-4">
                <h4 class="font-semibold text-gray-800">使用例</h4>

                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <p class="text-sm font-medium text-gray-800 mb-2">複数の項目を組み合わせた例</p>
                  <div class="text-xs text-gray-700 bg-gray-50 p-3 rounded whitespace-pre-wrap">【コマ1】
位置: 上
サイズ: 大
背景: 明るいカフェ
セリフ: いい天気だね！
表情: 笑顔

【コマ2】
位置: 下
サイズ: 小
内容: 薄暗い部屋、窓から雨が見える
セリフ: ...急に雨が
表情: 困惑</div>
                </div>

                <div class="border-t pt-4">
                  <div class="space-y-3 text-sm">
                    <div>
                      <div class="font-medium text-gray-800">位置</div>
                      <div class="text-gray-600 ml-2">例: 左上、右上、中央、上、下</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">サイズ</div>
                      <div class="text-gray-600 ml-2">例: 大、小、中</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">内容</div>
                      <div class="text-gray-600 ml-2">例: 主人公が驚いた表情で本を落とす、薄暗い部屋でデスクライトだけが明るい</div>
                      <div class="text-xs text-gray-500 ml-2 mt-1">※照明・トーンもここで指定可能（例: 薄暗い、明るい日差し、夜の雰囲気）</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">セリフ</div>
                      <div class="text-gray-600 ml-2">例: えっ、これ本当？、もう少しで完成だ...</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">背景</div>
                      <div class="text-gray-600 ml-2">例: 明るいリビング、夜のオフィス、カフェの店内</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">キャラ</div>
                      <div class="text-gray-600 ml-2">例: 説明者のみ、説明者と相談者、相談者のみ</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">表情</div>
                      <div class="text-gray-600 ml-2">例: 驚き、真剣、笑顔、困惑、納得</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">カメラアングル</div>
                      <div class="text-gray-600 ml-2">例: 正面、斜め上から、横顔、俯瞰</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">カメラ距離</div>
                      <div class="text-gray-600 ml-2">例: クローズアップ、全身、バストショット</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          <//>
        </div>
      `;
    }

    // 認証ラッパー（メインApp）
    function App() {
      var s1 = useState(null); var user = s1[0], setUser = s1[1];
      var s2 = useState(true); var loading = s2[0], setLoading = s2[1];

      useEffect(function() {
        // 現在のセッションを確認
        supabase.auth.getSession().then(function(result) {
          setUser(result.data.session?.user || null);
          setLoading(false);
        });

        // 認証状態の変更を監視
        var subscription = supabase.auth.onAuthStateChange(function(_event, session) {
          setUser(session?.user || null);
        });

        return function() { subscription.data.subscription.unsubscribe(); };
      }, []);

      async function handleSignOut() {
        await supabase.auth.signOut();
      }

      // 読み込み中
      if (loading) {
        return html`
          <div class="min-h-screen flex items-center justify-center bg-gray-50">
            <div class="text-center">
              <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
              <p class="text-gray-600">読み込み中...</p>
            </div>
          </div>
        `;
      }

      // 未ログインの場合は認証画面を表示
      if (!user) {
        return html`<${AuthForm} />`;
      }

      // ログイン済みの場合は漫画生成アプリを表示
      return html`<${MangaApp} user=${user} onSignOut=${handleSignOut} />`;
    }

    ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App));
  </script>
</body>
</html>
