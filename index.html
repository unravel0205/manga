<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>漫画クリエイター</title>

  <!-- セキュリティヘッダー -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://unpkg.com https://cdn.jsdelivr.net https://generativelanguage.googleapis.com; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data: blob: https://*.supabase.co; connect-src 'self' https://*.supabase.co https://generativelanguage.googleapis.com;">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">

  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* デザインシステム - CSS変数定義 */
    :root {
      /* カラーパレット - B案: モダン&プロフェッショナル */
      --color-primary: #0066CC;
      --color-secondary: #00A3E0;
      --color-accent: #4A9EFF;
      --color-bg-base: #FFFFFF;
      --color-bg-subtle: #F8FBFF;
      --color-bg-muted: #E8F1F8;
      --color-text-primary: #1A2332;
      --color-text-secondary: #64748B;
      --color-text-muted: #94A3B8;
      --color-border: #E8F1F8;
      --color-white: #FFFFFF;

      /* グラデーション */
      --gradient-primary: linear-gradient(135deg, #0066CC 0%, #00A3E0 100%);
      --gradient-subtle: linear-gradient(180deg, rgba(255,255,255,0.95) 0%, rgba(248,251,255,0.95) 100%);

      /* シャドウ - B案: 柔らかく大きめ */
      --shadow-sm: 0 2px 8px rgba(0, 102, 204, 0.06);
      --shadow-md: 0 4px 16px rgba(0, 102, 204, 0.08);
      --shadow-lg: 0 8px 32px rgba(0, 102, 204, 0.12);
      --shadow-xl: 0 16px 48px rgba(0, 102, 204, 0.16);

      /* 角丸 - B案: 大きめ */
      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-full: 9999px;

      /* スペーシング */
      --spacing-xs: 8px;
      --spacing-sm: 12px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;

      /* フォント */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP", sans-serif;

      /* セマンティックカラー */
      --color-success: #10B981;
      --color-success-light: #D1FAE5;
      --color-warning: #F59E0B;
      --color-warning-light: #FEF3C7;
      --color-error: #EF4444;
      --color-error-light: #FEE2E2;
      --color-info: #3B82F6;
      --color-info-light: #DBEAFE;

      /* アニメーション */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-base: 300ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
      --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
      --ease-out: cubic-bezier(0, 0, 0.2, 1);
      --ease-in: cubic-bezier(0.4, 0, 1, 1);

      /* グラスモルフィズム拡張 */
      --glass-bg: rgba(255, 255, 255, 0.7);
      --glass-bg-dark: rgba(255, 255, 255, 0.5);
      --glass-border: rgba(255, 255, 255, 0.3);
      --glass-blur: blur(12px);
      --glass-blur-strong: blur(20px);

      /* タイポグラフィスケール - 8段階 */
      --font-size-xs: 0.75rem;    /* 12px */
      --font-size-sm: 0.875rem;   /* 14px */
      --font-size-base: 1rem;     /* 16px */
      --font-size-lg: 1.125rem;   /* 18px */
      --font-size-xl: 1.25rem;    /* 20px */
      --font-size-2xl: 1.5rem;    /* 24px */
      --font-size-3xl: 1.875rem;  /* 30px */
      --font-size-4xl: 2.25rem;   /* 36px */

      /* 行の高さ */
      --line-height-tight: 1.25;
      --line-height-normal: 1.5;
      --line-height-relaxed: 1.75;

      /* フォントウェイト */
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;

      /* 8pxグリッドスペーシングシステム（完全版） */
      --spacing-0: 0;
      --spacing-1: 4px;   /* 0.5 unit */
      --spacing-2: 8px;   /* 1 unit */
      --spacing-3: 12px;  /* 1.5 units */
      --spacing-4: 16px;  /* 2 units */
      --spacing-5: 20px;  /* 2.5 units */
      --spacing-6: 24px;  /* 3 units */
      --spacing-8: 32px;  /* 4 units */
      --spacing-10: 40px; /* 5 units */
      --spacing-12: 48px; /* 6 units */
      --spacing-16: 64px; /* 8 units */
      --spacing-20: 80px; /* 10 units */

      /* カラーシステム - 状態別バリエーション */
      --color-primary-hover: #0052A3;
      --color-primary-active: #003D7A;
      --color-primary-disabled: #B3D9FF;

      --color-secondary-hover: #0082B8;
      --color-secondary-active: #00628A;

      --color-success-hover: #059669;
      --color-success-active: #047857;

      --color-error-hover: #DC2626;
      --color-error-active: #B91C1C;

      /* 影システム - 5段階に細分化 */
      --shadow-xs: 0 1px 2px rgba(0, 102, 204, 0.04);
      --shadow-sm: 0 2px 8px rgba(0, 102, 204, 0.06);
      --shadow-md: 0 4px 16px rgba(0, 102, 204, 0.08);
      --shadow-lg: 0 8px 32px rgba(0, 102, 204, 0.12);
      --shadow-xl: 0 16px 48px rgba(0, 102, 204, 0.16);
      --shadow-2xl: 0 24px 64px rgba(0, 102, 204, 0.20);

      /* Z-indexシステム */
      --z-index-dropdown: 1000;
      --z-index-sticky: 1020;
      --z-index-fixed: 1030;
      --z-index-modal-backdrop: 1040;
      --z-index-modal: 1050;
      --z-index-popover: 1060;
      --z-index-tooltip: 1070;

      /* タッチターゲットサイズ（アクセシビリティ） */
      --touch-target-min: 44px;

      /* コンテンツ幅 */
      --content-width-sm: 640px;
      --content-width-md: 768px;
      --content-width-lg: 1024px;
      --content-width-xl: 1280px;
    }

    /* グローバルスタイル */
    body {
      font-family: var(--font-family);
      background: var(--color-bg-subtle);
      color: var(--color-text-primary);
      transition: background var(--transition-base);
    }

    /* スムーズスクロール */
    html {
      scroll-behavior: smooth;
    }

    /* フォーカス可視化の改善 */
    *:focus-visible {
      outline: 2px solid var(--color-primary);
      outline-offset: 2px;
    }

    /* カードスタイル - B案（強化版） */
    .card {
      background: var(--color-bg-base);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      padding: var(--spacing-lg);
      transition: all var(--transition-base);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity var(--transition-base);
    }

    .card:hover {
      box-shadow: var(--shadow-lg);
      transform: translateY(-4px);
    }

    .card:hover::before {
      opacity: 1;
    }

    /* ガラスモルフィズム効果（強化版） */
    .glass {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      box-shadow: 0 8px 32px rgba(0, 102, 204, 0.1);
      transition: all var(--transition-base);
    }

    .glass:hover {
      background: var(--glass-bg-dark);
      backdrop-filter: var(--glass-blur-strong);
      -webkit-backdrop-filter: var(--glass-blur-strong);
      box-shadow: 0 12px 48px rgba(0, 102, 204, 0.15);
    }

    /* ガラスカード（カード+ガラス効果） */
    .glass-card {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-xl);
      transition: all var(--transition-base);
    }

    .glass-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 60px rgba(0, 102, 204, 0.2);
    }

    /* ボタンスタイル - B案（強化版） */
    .btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      border-radius: var(--radius-md);
      padding: 12px 24px;
      font-weight: 600;
      box-shadow: var(--shadow-md);
      transition: all var(--transition-base);
      border: none;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .btn-primary::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width var(--transition-slow), height var(--transition-slow);
    }

    .btn-primary:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn-primary:hover {
      box-shadow: var(--shadow-lg);
      transform: translateY(-2px) scale(1.02);
    }

    .btn-primary:active {
      transform: translateY(0) scale(0.98);
    }

    .btn-secondary {
      background: var(--color-bg-base);
      color: var(--color-primary);
      border: 2px solid var(--color-primary);
      border-radius: var(--radius-md);
      padding: 10px 22px;
      font-weight: 600;
      transition: all var(--transition-base);
      cursor: pointer;
      position: relative;
    }

    .btn-secondary:hover {
      background: var(--color-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .btn-secondary:active {
      transform: translateY(0);
    }

    /* 入力フィールド（強化版） */
    .input-field {
      border: 2px solid var(--color-border);
      border-radius: var(--radius-md);
      padding: 12px 16px;
      transition: all var(--transition-base);
      font-family: var(--font-family);
      background: var(--color-bg-base);
    }

    .input-field:hover {
      border-color: var(--color-accent);
    }

    .input-field:focus {
      outline: none;
      border-color: var(--color-primary);
      box-shadow: 0 0 0 4px rgba(0, 102, 204, 0.1);
      transform: translateY(-1px);
    }

    .input-field::placeholder {
      color: var(--color-text-muted);
      transition: color var(--transition-base);
    }

    .input-field:focus::placeholder {
      color: transparent;
    }

    /* ユーティリティクラス */
    .tooltip {
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .tooltip-trigger:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 6px;
      width: 6px;
    }

    .scrollbar-thin::-webkit-scrollbar-track {
      background: var(--color-bg-muted);
      border-radius: var(--radius-sm);
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: var(--color-text-muted);
      border-radius: var(--radius-sm);
    }

    .scrollbar-thin::-webkit-scrollbar-thumb:hover {
      background: var(--color-text-secondary);
    }

    .accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    .accordion-content.open {
      max-height: 2000px;
    }

    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: -100%;
        top: 0;
        height: 100vh;
        z-index: 50;
        transition: left 0.3s ease;
        width: 85%;
        max-width: 360px;
      }
      .sidebar.open {
        left: 0;
      }
    }

    /* アニメーションクラス */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(-20px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -1000px 0;
      }
      100% {
        background-position: 1000px 0;
      }
    }

    .animate-fadeIn {
      animation: fadeIn var(--transition-base) var(--ease-out);
    }

    .animate-slideIn {
      animation: slideIn var(--transition-base) var(--ease-out);
    }

    .animate-pulse {
      animation: pulse 2s var(--ease-in-out) infinite;
    }

    /* フィードバック用クラス */
    .alert {
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      border-left: 4px solid;
      animation: fadeIn var(--transition-base);
    }

    .alert-success {
      background: var(--color-success-light);
      border-color: var(--color-success);
      color: #065F46;
    }

    .alert-warning {
      background: var(--color-warning-light);
      border-color: var(--color-warning);
      color: #92400E;
    }

    .alert-error {
      background: var(--color-error-light);
      border-color: var(--color-error);
      color: #991B1B;
    }

    .alert-info {
      background: var(--color-info-light);
      border-color: var(--color-info);
      color: #1E40AF;
    }

    /* ローディングスピナー */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 102, 204, 0.1);
      border-top-color: var(--color-primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* スケルトンローディング */
    .skeleton {
      background: linear-gradient(
        90deg,
        var(--color-bg-muted) 0%,
        var(--color-bg-base) 50%,
        var(--color-bg-muted) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
      border-radius: var(--radius-md);
    }

    /* ホバーリフト効果 */
    .hover-lift {
      transition: transform var(--transition-base), box-shadow var(--transition-base);
    }

    .hover-lift:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }

    /* スムーズフェード */
    .fade-enter {
      opacity: 0;
    }

    .fade-enter-active {
      opacity: 1;
      transition: opacity var(--transition-base);
    }

    /* デザインプリセット切り替え用（将来の拡張用） */
    [data-design="plan-a"] {
      /* A案: クリーン&ミニマル */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 2px 4px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 4px 8px rgba(0, 0, 0, 0.08);
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
    }

    [data-design="plan-c"] {
      /* C案: テック企業風 */
      --color-bg-base: #FFFFFF;
      --color-bg-subtle: #F8FAFC;
      --color-text-primary: #0A1929;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
      --shadow-md: 0 2px 6px rgba(0, 0, 0, 0.15);
      --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.18);
      --radius-sm: 2px;
      --radius-md: 4px;
      --radius-lg: 6px;
    }

    /* タイポグラフィユーティリティクラス */
    .text-xs { font-size: var(--font-size-xs) !important; }
    .text-sm { font-size: var(--font-size-sm) !important; }
    .text-base { font-size: var(--font-size-base) !important; }
    .text-lg { font-size: var(--font-size-lg) !important; }
    .text-xl { font-size: var(--font-size-xl) !important; }
    .text-2xl { font-size: var(--font-size-2xl) !important; }
    .text-3xl { font-size: var(--font-size-3xl) !important; }
    .text-4xl { font-size: var(--font-size-4xl) !important; }

    /* スペーシングユーティリティクラス - マージン */
    .m-0 { margin: var(--spacing-0) !important; }
    .m-1 { margin: var(--spacing-1) !important; }
    .m-2 { margin: var(--spacing-2) !important; }
    .m-3 { margin: var(--spacing-3) !important; }
    .m-4 { margin: var(--spacing-4) !important; }
    .m-6 { margin: var(--spacing-6) !important; }
    .m-8 { margin: var(--spacing-8) !important; }

    .mt-1 { margin-top: var(--spacing-1) !important; }
    .mt-2 { margin-top: var(--spacing-2) !important; }
    .mt-3 { margin-top: var(--spacing-3) !important; }
    .mt-4 { margin-top: var(--spacing-4) !important; }
    .mt-6 { margin-top: var(--spacing-6) !important; }
    .mt-8 { margin-top: var(--spacing-8) !important; }

    .mb-1 { margin-bottom: var(--spacing-1) !important; }
    .mb-2 { margin-bottom: var(--spacing-2) !important; }
    .mb-3 { margin-bottom: var(--spacing-3) !important; }
    .mb-4 { margin-bottom: var(--spacing-4) !important; }
    .mb-6 { margin-bottom: var(--spacing-6) !important; }
    .mb-8 { margin-bottom: var(--spacing-8) !important; }

    .ml-2 { margin-left: var(--spacing-2) !important; }
    .ml-4 { margin-left: var(--spacing-4) !important; }
    .mr-2 { margin-right: var(--spacing-2) !important; }
    .mr-4 { margin-right: var(--spacing-4) !important; }

    /* スペーシングユーティリティクラス - パディング */
    .p-0 { padding: var(--spacing-0) !important; }
    .p-1 { padding: var(--spacing-1) !important; }
    .p-2 { padding: var(--spacing-2) !important; }
    .p-3 { padding: var(--spacing-3) !important; }
    .p-4 { padding: var(--spacing-4) !important; }
    .p-5 { padding: var(--spacing-5) !important; }
    .p-6 { padding: var(--spacing-6) !important; }
    .p-8 { padding: var(--spacing-8) !important; }

    .pt-1 { padding-top: var(--spacing-1) !important; }
    .pt-2 { padding-top: var(--spacing-2) !important; }
    .pt-3 { padding-top: var(--spacing-3) !important; }
    .pt-4 { padding-top: var(--spacing-4) !important; }
    .pt-6 { padding-top: var(--spacing-6) !important; }

    .pb-1 { padding-bottom: var(--spacing-1) !important; }
    .pb-2 { padding-bottom: var(--spacing-2) !important; }
    .pb-3 { padding-bottom: var(--spacing-3) !important; }
    .pb-4 { padding-bottom: var(--spacing-4) !important; }

    .px-3 { padding-left: var(--spacing-3) !important; padding-right: var(--spacing-3) !important; }
    .px-4 { padding-left: var(--spacing-4) !important; padding-right: var(--spacing-4) !important; }
    .py-2 { padding-top: var(--spacing-2) !important; padding-bottom: var(--spacing-2) !important; }
    .py-3 { padding-top: var(--spacing-3) !important; padding-bottom: var(--spacing-3) !important; }
    .py-4 { padding-top: var(--spacing-4) !important; padding-bottom: var(--spacing-4) !important; }

    /* ギャップユーティリティ */
    .gap-1 { gap: var(--spacing-1) !important; }
    .gap-2 { gap: var(--spacing-2) !important; }
    .gap-3 { gap: var(--spacing-3) !important; }
    .gap-4 { gap: var(--spacing-4) !important; }

    /* マイクロインタラクション強化 */
    .hover-scale {
      transition: transform var(--transition-base), box-shadow var(--transition-base);
    }

    .hover-scale:hover {
      transform: scale(1.02);
      box-shadow: var(--shadow-lg);
    }

    .hover-scale:active {
      transform: scale(0.98);
    }

    /* 状態別ボタンスタイル */
    .btn-primary:hover {
      background: linear-gradient(135deg, var(--color-primary-hover) 0%, var(--color-secondary-hover) 100%);
    }

    .btn-primary:active {
      background: linear-gradient(135deg, var(--color-primary-active) 0%, var(--color-secondary-active) 100%);
    }

    .btn-primary:disabled {
      background: var(--color-primary-disabled);
      cursor: not-allowed;
      box-shadow: none;
    }

    /* レスポンシブタイポグラフィ */
    @media (max-width: 768px) {
      :root {
        --font-size-3xl: 1.5rem;   /* 24px instead of 30px */
        --font-size-2xl: 1.25rem;  /* 20px instead of 24px */
      }
    }

    /* スムーズなスクロールスナップ */
    .scroll-snap-x {
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }

    .scroll-snap-x > * {
      scroll-snap-align: start;
    }

    /* アニメーション強化 - スライドアップ */
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-slideUp {
      animation: slideUp var(--transition-base) var(--ease-out);
    }

    /* カードホバーエフェクト強化 */
    .card-interactive {
      transition: all var(--transition-base);
      cursor: pointer;
    }

    .card-interactive:hover {
      transform: translateY(-4px) scale(1.01);
      box-shadow: var(--shadow-xl);
    }

    .card-interactive:active {
      transform: translateY(-2px) scale(1.005);
    }
  </style>
</head>
<body class="min-h-screen" style="background: var(--color-bg-subtle);" data-design="plan-b">
  <div id="app"></div>

  <script type="module">
    import { html, render, useState, useEffect, useRef } from 'https://unpkg.com/htm/preact/standalone.module.js';

    // セキュリティ関数：入力値のサニタイゼーション
    function sanitizeInput(input, maxLength) {
      if (typeof input !== 'string') return '';
      return input
        .replace(/[<>]/g, '') // XSS対策：HTMLタグ削除
        .trim()
        .slice(0, maxLength || 10000); // 長さ制限
    }

    // セキュリティ関数：APIキーの暗号化・復号化
    function encryptApiKey(apiKey) {
      if (!apiKey) return '';
      try {
        // Base64エンコード + 簡易的な文字列変換
        var encoded = btoa(apiKey);
        var scrambled = encoded.split('').reverse().join('');
        return scrambled;
      } catch (e) {
        console.error('暗号化エラー:', e);
        return apiKey; // エラー時は元の値を返す
      }
    }

    function decryptApiKey(encrypted) {
      if (!encrypted) return '';
      try {
        // 復号化
        var unscrambled = encrypted.split('').reverse().join('');
        var decoded = atob(unscrambled);
        return decoded;
      } catch (e) {
        console.error('復号化エラー:', e);
        return ''; // エラー時は空文字を返す
      }
    }

    // セキュリティ関数：レート制限
    var lastGenerateTime = 0;
    var MIN_GENERATE_INTERVAL = 5000; // 5秒

    function checkRateLimit() {
      var now = Date.now();
      var timeSinceLastGenerate = now - lastGenerateTime;

      if (timeSinceLastGenerate < MIN_GENERATE_INTERVAL) {
        var waitSeconds = Math.ceil((MIN_GENERATE_INTERVAL - timeSinceLastGenerate) / 1000);
        throw new Error('生成リクエストが多すぎます。' + waitSeconds + '秒後に再試行してください。');
      }

      lastGenerateTime = now;
    }

    // セキュリティ関数：画像ファイル検証
    function validateImageFile(file) {
      if (!file) {
        throw new Error('ファイルが選択されていません。');
      }

      // 1. ファイルタイプチェック（MIMEタイプ）
      var allowedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/webp'];
      if (!allowedTypes.includes(file.type)) {
        throw new Error('PNG、JPEG、またはWebP形式の画像のみアップロード可能です。\n選択されたファイル形式: ' + (file.type || '不明'));
      }

      // 2. SVG禁止（XSS対策）
      if (file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')) {
        throw new Error('セキュリティ上の理由により、SVG形式は使用できません。');
      }

      // 3. ファイルサイズチェック（5MB制限）
      var MAX_SIZE = 5 * 1024 * 1024; // 5MB
      if (file.size > MAX_SIZE) {
        var sizeMB = (file.size / 1024 / 1024).toFixed(2);
        throw new Error('ファイルサイズが大きすぎます（' + sizeMB + 'MB）。\n5MB以下の画像を選択してください。');
      }

      // 4. ファイル名チェック（拡張子偽装対策）
      var fileName = file.name.toLowerCase();
      var validExtensions = ['.png', '.jpg', '.jpeg', '.webp'];
      var hasValidExtension = validExtensions.some(function(ext) {
        return fileName.endsWith(ext);
      });

      if (!hasValidExtension) {
        throw new Error('無効なファイル拡張子です。\nPNG、JPEG、またはWebP形式の画像を選択してください。');
      }

      // 5. 最小サイズチェック（破損ファイル対策）
      if (file.size < 100) {
        throw new Error('ファイルが破損している可能性があります。\n別の画像を選択してください。');
      }

      return true;
    }

    // Supabase設定
    var SUPABASE_URL = 'https://twhhrgcksstikdoyroto.supabase.co';
    var SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3aGhyZ2Nrc3N0aWtkb3lyb3RvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwMzk3MzIsImV4cCI6MjA4NjYxNTczMn0.grPvawJNNXoikE7tLVf-Fq3rglXJjwdfpYGjdmYlL7s';
    var supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // 定数
    var STYLES = [
      { id: 1, name: 'ビジネス説明マンガ風', desc: '企業向けビジネス書・まんがでわかる○○シリーズの優しいタッチ', prompt: 'Japanese josei manga illustration style for business books. Soft natural color palette with warm beige skin tones and natural brown hair. Delicate thin linework with subtle line weight variation. Soft gradient shading, not cel-shaded. Realistic proportions with slightly large but natural-looking eyes. Clean, professional, and approachable atmosphere. Detailed hair strands with natural flow. Gentle highlights and minimal shadows. Style similar to "manga de wakaru" business book illustrations.' },
      { id: 2, name: '少年漫画風', desc: '週刊少年ジャンプ風・ワンピース/ドラゴンボールのような迫力バトル', prompt: 'Japanese Weekly Shonen Jump manga illustration style, full color spread page quality. Extremely bold heavy ink linework with exaggerated line weight variation, extra thick black outlines on characters that pop off the page. Hyper-detailed background art with dramatic forced perspective and foreshortening. Intensely vivid oversaturated colors with hard cel-shading and deep black shadows. Extreme high contrast lighting with powerful directional light source, strong rim lighting, and glowing color bleeds. Screentone texture overlay for authentic print feeling. Over-the-top dynamic composition breaking panel boundaries. Extreme camera angles - ultra low angle looking up, severe dutch angle, exaggerated fish-eye distortion. Characters bursting out of frame toward viewer. Explosive speed lines filling entire background, dense impact lines radiating from action points, heavy motion blur streaks. Flying debris, shattering rocks, dust clouds, sparks, and energy particles everywhere. Shockwave ripples and impact craters. Exaggerated anatomy with dynamic impossible poses, muscles tensed at peak action, clothing and hair blown by intense force. Screaming expressions with wide eyes and intense emotion visible. Battle aura effects, glowing energy emanating from characters, light beam attacks, flame or lightning effects. Onomatopoeia sound effect aesthetics integrated into composition. Color palette with extreme complementary contrasts - hot orange against cool blue, vivid red against deep green. Background practically vibrating with energy. Character colors cranked to maximum saturation against darker dramatic backgrounds. Raw hand-drawn ink texture with visible brush strokes, confident and aggressive linework. Peak Weekly Shonen Jump double-page spread impact and intensity.' },
      { id: 3, name: '少女漫画風', desc: 'りぼん・なかよし風・セーラームーン/カードキャプターさくらのキラキラ世界', prompt: 'Japanese classic shoujo manga illustration style, full color magazine cover quality. Extremely delicate graceful linework with elegant flowing strokes, impossibly fine detailed lines for each individual hair strand flowing like silk in the wind. Overwhelmingly large sparkling eyes taking up half the face, filled with multiple layered star-shaped highlights, galaxy-like gradient irises with jewel-like depth, impossibly long dramatic eyelashes with individual strands visible. Eyes reflecting entire universes of emotion and light. Explosively dreamy backgrounds completely filled with floating roses, cherry blossoms, lilies cascading everywhere. Thousands of sparkles, glitter particles, and diamond dust filling every empty space. Soap bubbles with rainbow reflections, soft feathers floating, ribbons swirling through the air. Ultra soft ethereal pastel color palette - delicate pink, dreamy lavender, heavenly baby blue, pearl white with iridescent shimmer. Colors so soft they seem to glow from within. Extreme airbrush-style gradients melting seamlessly into each other. Overwhelming light effects - lens flares bursting like stars, soft focus bokeh everywhere, holy light rays streaming down, rainbow prism effects, glowing halos around characters. Everything bathed in magical golden hour lighting. Hair flowing in impossible dramatic waves defying gravity, each strand catching light individually, hair so detailed it looks like liquid silk or spun gold. Clothing billowing ethereally as if underwater or in zero gravity. Intensely emotional expressions - huge glistening tears like crystal jewels catching light, deep blushes spreading across cheeks with soft gradient, lips with glass-like shine and perfect highlights. Decorative elements overflowing - intricate lace patterns, satin ribbons, pearl accessories, crystal jewelry catching prismatic light. Ornate floral borders framing the scene. Screen tone texture with delicate flower patterns, soft dot gradients creating dreamy atmosphere. Peak Ribon or Nakayoshi magazine cover impact - overwhelmingly beautiful and romantic aesthetic that takes breath away.' },
      { id: 4, name: 'シンプル線画風', desc: '北欧ミニマルデザイン・無印良品/Apple UIのような極限シンプル', prompt: 'Ultra minimalist vector line art illustration style, extreme geometric simplification. Perfectly uniform clean black outlines with mathematically precise thickness, no variation or hand-drawn imperfection whatsoever. Radically simplified shapes - circles, rectangles, triangles only. Human figures reduced to essential geometric forms, faces with dot eyes and single line expressions or no facial features at all. Objects stripped down to absolute iconic silhouettes instantly recognizable with minimum detail. Completely flat solid colors with absolutely zero gradients, zero shadows, zero highlights, zero texture. Pure unmodulated color fills like digital paint bucket tool. Limited color palette - maximum 3-4 colors plus black and white. Extreme negative space utilization - bold empty areas as important as filled areas. Perfectly balanced asymmetrical composition. Every element placed with mathematical precision and intentional breathing room. Razor sharp vector edges, infinitely scalable appearance. Colors either bold primary palette or sophisticated muted Scandinavian tones - dusty pink, sage green, warm gray, mustard yellow. No decorative elements whatsoever - no patterns, no textures, no ornaments. If it can be removed without losing meaning, it is removed. Absolute economy of visual information. Clean modern tech company aesthetic meets Scandinavian design philosophy. Swiss graphic design precision. Museum of Modern Art poster quality minimalism.' },
      { id: 5, name: 'アメコミ風', desc: 'マーベル/DCコミックス・スパイダーマン/バットマン風のポップなアメリカン', prompt: 'Classic American superhero comic book illustration style, full color splash page quality. Extremely bold heavy black ink outlines with aggressive confident brushwork, thick to thin line variation showing hand-inked craftsmanship. Cross-hatching and feathering techniques for dramatic shadow rendering. Hyper-muscular heroic anatomy with exaggerated proportions - massive shoulders, impossibly broad chests, chiseled jawlines, dynamic impossible poses showing extreme foreshortening. Capes and costumes billowing dramatically with every fold and wrinkle rendered. Veins visible on tensed muscles. Intensely vibrant saturated colors - primary red, blue, yellow popping off the page. Bold complementary color clashes creating visual impact. Colors so vivid they practically glow. Heavy halftone Ben-Day dot patterns visible throughout - dots on skin tones, dots in shadows, dots creating gradients and atmospheric effects. Authentic vintage newsprint comic aesthetic with CMYK color separation feeling. Extreme dramatic lighting with stark noir-influenced shadows. Pure black shadow areas with sharp cutoffs, intense rim lighting outlining figures against dark backgrounds. Multiple dramatic light sources creating complex shadow interplay. Kirby Krackle cosmic energy effects - black dot clusters representing cosmic power and explosions. Energy beams, lightning bolts, power auras crackling around characters. Explosive impact bursts and starburst effects. Hyper-detailed urban destruction backgrounds - crumbling skyscrapers, shattered concrete, flying debris, billowing smoke clouds, cracked asphalt, bent steel girders. Epic sense of scale with tiny figures against massive destruction. Over-the-top action composition bursting beyond panel borders. Extreme camera angles - severe worm\'s eye view looking up at towering heroes, dramatic bird\'s eye capturing citywide chaos. Fists and feet punching directly toward viewer breaking the fourth wall. Sound effect aesthetic integrated - impact feels like visible POW, WHAM, KRACKOOM even without text. Visual noise and energy radiating from every action. Classic Marvel and DC bronze age aesthetic meets modern Image Comics intensity. Jack Kirby cosmic grandeur combined with Jim Lee hyper-detailed rendering. Print-ready newsstand comic book cover impact.' },
      { id: 6, name: '水彩イラスト風', desc: '絵本・水彩画風・ジブリ背景美術のような柔らかく温かい水彩タッチ', prompt: 'Traditional watercolor painting illustration style, fine art gallery exhibition quality. Extremely loose expressive brushwork with visible confident brush strokes dancing across the surface. Wet-on-wet technique creating magical unpredictable color blooms and bleeds spreading organically. Heavily visible cold-pressed watercolor paper texture - rough tooth surface catching pigment in valleys, creating beautiful granulation effects. Paper grain showing through transparent washes. Pure white of paper glowing through as brightest highlights, never covered with white paint. Dreamy soft edges melting into each other where colors meet, bleeding and feathering beautifully. Occasional crisp hard edges for contrast where wet meets dry. Cauliflower blooms and backruns embraced as happy accidents adding organic authenticity. Luminous transparent color layers built up through multiple glazing washes - colors glowing from within as light passes through pigment to paper and reflects back. Visible layering where previous washes peek through subsequent layers creating color depth impossible in opaque media. Pigment granulation and separation visible - heavier pigments settling into paper texture creating speckled effects. Sedimentary pigments like ultramarine and burnt sienna showing natural granular texture. Color separating into component pigments in wet washes. Water marks and tide lines where puddles dried, salt texture effects creating snowflake patterns, deliberate splatter and spray adding energy and movement. Drips running down occasionally left as artistic elements. Color palette either soft ethereal pastels with diluted washes or rich vibrant concentrated pigments pooling in shadows. Atmospheric perspective through increasingly diluted cooler washes for distant elements. Warm concentrated colors for foreground, pale cool hints for background. Loose gestural quality - suggesting rather than defining, leaving areas unfinished and breathing. Strategic unpainted white spaces as important design elements. Edges lost and found throughout composition guiding the eye. Authentic traditional watercolor aesthetic - handmade imperfection, organic unpredictability, luminosity only achievable through transparent water media. Fine art watercolor society exhibition quality, museum-worthy traditional painting appearance.' },
      { id: 7, name: 'レトロ漫画風', desc: '昭和レトロ漫画・ベルサイユのばら/キャンディキャンディの懐かしい雰囲気', prompt: 'Authentic vintage Japanese manga illustration style from 1970s-1980s golden age era, full color magazine illustration quality. Classic hand-drawn ink linework with visible pen nib texture - G-pen bold strokes for outlines, Maru-pen delicate lines for details, Kabura-pen for hair strands. Iconic retro character design - large sparkling eyes with dramatic star-shaped highlights and heavy black areas, distinctively thick eyebrows, pointed chins, impossibly long legs with exaggerated height proportions. Feathered hair with dramatic volume and wings, era-specific hairstyles reflecting 70s-80s fashion. Heavy authentic screen tone usage throughout - IC Screen and Letraset tone patterns visible. Mechanical dot tones for shading, gradient tones for atmospheric effects, decorative pattern tones for clothing and backgrounds. Sand tones, cross-hatch tones, sparkle effect tones layered for depth. Nostalgic vintage color palette limited by period printing technology - slightly misaligned CMYK registration creating subtle color bleeds. Warm yellowed paper undertone as if aged newsprint. Saturated but slightly muted colors - distinctive orange-reds, turquoise blues, mustard yellows, dusty pinks specific to era printing. Dramatic speed lines and effect lines hand-drawn with ruler precision. Beta-flash technique with white radiating from black. Emotion symbols - sweat drops, anger veins, sparkle backgrounds, flower frames for beautiful moments. Detailed realistic backgrounds contrasting with stylized characters - urban Japanese cityscapes, detailed interior rooms with period-accurate furniture and technology, school buildings, trains. Visible analog production artifacts - white-out correction marks, slight ink bleeding at line intersections, paste-up edges where tones were cut and applied by hand. Authentic pre-digital manga craftsmanship visible throughout. Emotional dramatic atmosphere with characteristic manga storytelling visual language. Style reminiscent of Shonen Sunday, Margaret, or Ribon magazine illustrations from the era. Museum of manga history exhibition quality, preserving authentic golden age aesthetic.' },
      { id: 8, name: 'Webtoon風', desc: '韓国ウェブトゥーン・俺だけレベルアップ/神之塔の現代的デジタル表現', prompt: 'Modern Korean webtoon illustration style, premium platform featured series quality. Immaculately clean digital linework with perfect smooth curves, crisp confident outlines with subtle thickness variation. Ultra-polished professional digital art finish with no visible brush texture. Stunning modern character designs reflecting Korean beauty standards - small perfectly proportioned faces, flawless porcelain skin with luminous glow, high nose bridges, delicate lips with glass-like shine, perfectly groomed eyebrows. Large expressive eyes but more realistic than Japanese manga - detailed iris patterns with multiple light reflections, natural double eyelids, subtle eye makeup visible. Impossibly beautiful hair rendered strand by strand with silky smooth highlights, perfectly styled K-drama worthy hairstyles catching light beautifully. Hair color ranging from natural blacks and browns to trendy Korean hair colors - ash gray, burgundy, honey brown with subtle highlights. Ultra-soft airbrushed shading with seamless gradient transitions, no hard cel-shading edges. Delicate blushing on cheeks, nose tips, and ears with soft pink diffusion. Subsurface scattering effect on skin creating lifelike translucency, especially on ears and fingertips catching backlight. Fashion-forward contemporary clothing with meticulous fabric rendering - designer brands, trendy Korean street fashion, perfectly fitted suits, flowing dresses with realistic fabric physics. Detailed accessories - luxury watches, earrings, necklaces, designer bags all rendered with care. Cinematic atmospheric backgrounds with intentional depth of field blur - sharp focused characters against dreamy bokeh backgrounds. Modern Korean urban settings - stylish cafes, luxury apartments, Seoul cityscape, university campuses, corporate offices all rendered with architectural accuracy. Sophisticated color palette with harmonious color theory - soft pastels for romance genres, moody desaturated tones for thriller/drama, vibrant saturated colors for fantasy. Characteristic soft purple, pink, and blue atmospheric color grading throughout. Dramatic cinematic lighting with multiple soft light sources - warm golden hour glow, cool blue moonlight, neon city reflections, soft window light. Rim lighting separating characters from backgrounds, lens flares and light leaks adding filmic quality. Vertical scroll composition optimized with dramatic reveals and pacing. Strategic use of extreme close-ups on emotional eyes and faces. Dynamic camera angles creating webtoon-specific visual storytelling impact. Peak Naver Webtoon or Kakao Page premium series quality. Production value rivaling top-tier series like "True Beauty", "Lore Olympus", or "Solo Leveling". Professional Korean digital illustration studio quality throughout.' },
      { id: 9, name: '絵本イラスト風', desc: 'ピーターラビット/こぐまちゃん/はらぺこあおむしの温かい絵本世界', prompt: 'Heartwarming children\'s picture book illustration style, award-winning Caldecott Medal quality. Impossibly soft rounded shapes with no sharp edges anywhere - every corner curved, every form pillowy and huggable. Characters designed to be maximally endearing and lovable. Extremely warm inviting color palette radiating comfort - soft buttercream yellows, cozy terracotta oranges, gentle sage greens, warm rosy pinks, comforting sky blues. Colors feel like a warm blanket, a cup of cocoa, a gentle hug from grandmother. Visible handcrafted traditional media texture throughout - soft colored pencil strokes with waxy buildup, gentle watercolor washes bleeding softly at edges, gouache opacity with subtle brushwork visible, crayon texture with paper grain showing through. Mixed media layering creating rich tactile depth. Adorable character designs with exaggerated cute proportions - oversized round heads on small bodies, huge sparkling innocent eyes full of wonder, tiny button noses, rosy chubby cheeks that beg to be pinched. Simplified rounded hands like mittens, stubby little legs. Expressions radiating pure joy, curiosity, and warmth. Whimsical fantastical backgrounds bursting with cozy details - tiny mushroom houses with smoking chimneys, rolling gentle hills like soft pillows, friendly trees with faces, winding paths inviting exploration. Every element anthropomorphized and friendly - smiling suns, sleepy moons, cheerful flowers waving hello. Rich storytelling details rewarding close inspection - tiny creatures hiding in corners, secret doorways, miniature scenes within scenes. Visual narrative depth encouraging repeated viewing and discovery. Magical golden hour lighting bathing everything in warmth - soft diffused light with no harsh shadows, gentle glowing highlights, everything lit as if by candlelight or sunset. Light itself feels cozy and safe. Nostalgic timeless quality evoking beloved childhood memories - style reminiscent of classic Beatrix Potter, Eric Carle tactile quality, Oliver Jeffers whimsy, Jon Klassen subtle humor. Museum of children\'s literature exhibition quality, destined to become treasured bedtime reading for generations.' },
      { id: 10, name: 'クール・スタイリッシュ風', desc: 'ファッション誌風・NANA/Paradise Kissのモノトーンでおしゃれな表現', prompt: 'Ultra-cool sophisticated Japanese manga illustration style, high-end fashion magazine editorial quality. Razor-sharp confident ink linework with extreme precision, bold black strokes with dramatic thick-to-thin variation. Heavy use of pure blacks creating striking silhouettes and noir-like contrast. Predominantly monochromatic palette - deep rich blacks, pure bright whites, and full spectrum of sophisticated grays. Strategic limited accent colors used sparingly for maximum visual impact - single striking red on lips or blood, electric blue on eyes or neon signs, vibrant orange on cigarette ember or sunset. Color so selective it becomes symbolic and meaningful. Impossibly stylish character designs with model-like proportions - tall lean figures, sharp angular facial features, high cheekbones, narrow intense eyes with piercing gaze. Cool detached expressions radiating effortless confidence and mysterious allure. Characters look like they belong on fashion runways or in indie film posters. Hyper-detailed contemporary fashion rendered with obsessive precision - designer leather jackets with every zipper and stitch visible, perfectly tailored black suits, flowing oversized coats, avant-garde streetwear. Fabric textures meticulously rendered - leather shine, denim weave, silk drape, knit patterns. Accessories as character statements - designer sunglasses, silver jewelry, expensive watches, statement earrings. Cinematic urban nightscape backgrounds dripping with atmosphere - rain-slicked Tokyo streets reflecting neon, towering skyscrapers disappearing into fog, underground club interiors with dramatic lighting, empty late-night train platforms, rooftop silhouettes against city lights. Architecture rendered with precise perspective and urban grit. Dramatic noir-influenced lighting creating extreme contrast - harsh single light sources casting deep black shadows, rim lighting outlining figures against darkness, neon glow painting colored light on faces, cigarette smoke catching beams of light. Shadows as important as lit areas. Heavy screen tone usage for sophisticated gray gradations - mechanical dot patterns creating smooth transitions, gradient tones for atmospheric depth, cross-hatch tones for textured shadows. Analog manga craftsmanship with modern aesthetic sensibility. Edgy artistic composition with unconventional framing - extreme close-ups on eyes and lips, figures cropped dramatically at frame edges, negative space used boldly, dutch angles creating tension and unease. Visual rhythm between dense detailed areas and stark empty spaces. Cool detached atmosphere with underlying emotional intensity - style reminiscent of "Nana", "Paradise Kiss", "Gangsta", "Tokyo Ghoul" aesthetic sophistication. Fashion editorial meets underground manga culture. Gallery exhibition quality art book appearance.' },
      { id: 11, name: 'Webtoon (Full Screen)', desc: 'スマホ縦スクロール特化・俺だけレベルアップ風の没入感ある全画面表現', prompt: 'ULTRA-PREMIUM KOREAN WEBTOON - SOLO LEVELING TIER QUALITY - ABSOLUTE MAXIMUM EFFORT: HYPER-REALISTIC modern Korean webtoon illustration pushing boundaries of digital art excellence. CRITICAL VERTICAL WEBTOON FORMAT - Image MUST fill entire width edge-to-edge with ZERO left/right margins - illustration bleeds completely to borders. ULTRA-DRAMATIC cinematic presentation optimized for vertical smartphone scrolling with MAXIMUM visual impact. REVOLUTIONARY character designs - IMPOSSIBLY PERFECT proportions reflecting peak Korean beauty standards taken to extreme. Faces like porcelain dolls with SUPERNATURAL luminous skin glow, razor-sharp jawlines, impossibly high nose bridges creating statuesque profiles. Eyes EXPLOSIVELY expressive - MASSIVE detailed iris rendering with crystalline reflections creating jewel-like intensity, natural double eyelids with subtle gradient shading, professionally applied eye makeup visible in microscopic detail. Hair rendered at OBSESSIVE strand-by-strand precision with photorealistic shine physics, perfectly coiffed K-drama hairstyles defying gravity with artistic flair, trendy Korean colors (ash platinum, wine burgundy, honey caramel) with complex multi-tone highlights and lowlights. EXAGGERATED AIRBRUSHED SHADING - skin rendered like CGI movie quality with flawless gradient transitions smoother than humanly possible, zero visible brush strokes, subsurface scattering creating translucent glow on ears/fingertips/nose catching dramatic backlighting. Blushing effects like soft pink watercolor diffusion on cheeks. ULTRA-DETAILED fashion rendering - every fabric fold, every stitch, every texture fiber visible. Designer clothing with brand-accurate details, leather with realistic creasing, silk with light-catching sheen, denim with visible weave patterns. Accessories rendered like product photography - luxury watches with functioning mechanisms visible, jewelry with light refraction, designer bags with logo precision. CINEMATIC ATMOSPHERIC LIGHTING MASTERY - multiple dramatic light sources creating complex interplay. Rim lighting AGGRESSIVELY separating characters from backgrounds with glowing halos. Lens flares, light bloom, atmospheric haze, volumetric god rays, neon reflections, all pushed to MAXIMUM cinematic drama. Backgrounds with INTENTIONAL depth-of-field blur - sharp detailed foreground characters against DREAMY bokeh backgrounds creating professional camera depth. Modern Korean settings rendered with ARCHITECTURAL PRECISION - Seoul cityscapes, luxury penthouses, stylish cafes, corporate towers, all with perspective accuracy and environmental storytelling details. COLOR GRADING like premium streaming drama - sophisticated purple/pink/blue atmospheric tones, harmonious color theory creating mood-appropriate palettes (soft pastels for romance, desaturated moody tones for thriller, vibrant saturated for action/fantasy). DRAMATIC COMPOSITION - extreme close-ups on INTENSELY emotional eyes showing micro-expressions, dynamic camera angles (dutch tilts, worms-eye views, birds-eye perspectives), strategic negative space, rule-of-thirds mastery. PEAK production value matching top-tier series Solo Leveling, Tower of God season 2, Omniscient Reader, The Beginning After The End. THIS IS PREMIUM PAID WEBTOON QUALITY - NOT free amateur work. Professional Korean studio output with MAXIMUM polish and dramatic flair designed for addictive vertical scrolling mobile experience.' },
      { id: 99, name: '画像から参照', desc: '添付画像の雰囲気に合わせます', prompt: '' }
    ];

    var MODELS = [
      { id: '4k', name: '高品質 4K（有料）', model: 'gemini-3-pro-image-preview', price: 0.24, jpy: 36 },
      { id: '2k', name: '高品質 2K（有料）', model: 'gemini-3-pro-image-preview', price: 0.134, jpy: 20 },
      { id: 'free', name: '標準（無料）', model: 'gemini-2.5-flash-image', price: 0, jpy: 0 }
    ];

    var SAMPLES = [
      { id: 1, cat: 'ビジネス', title: 'ビジネス説明マンガ', style: 1 },
      { id: 2, cat: '教育', title: '教育系解説マンガ', style: 1 },
      { id: 3, cat: '商品紹介', title: '商品紹介マンガ', style: 8 },
      { id: 4, cat: 'ビジネス', title: '採用広報マンガ', style: 2 },
      { id: 5, cat: '教育', title: '歴史解説マンガ', style: 7 },
      { id: 6, cat: '商品紹介', title: 'サービス紹介', style: 3 }
    ];

    var HELP = {
      api: '【APIキー取得手順】\n\n1. https://aistudio.google.com/ にアクセス\n2. Googleアカウントでログイン\n3. 左メニュー「Get API Key」をクリック\n4. 「Create API Key」をクリック\n5. 表示されたキーをコピー（AIza...で始まる）\n6. このアプリに貼り付けて「保存」\n\n※キーは他人に共有しないでください',
      model: '【モデル選択】\n\n■ 高品質 4K（有料）\n$0.24/枚（約36円）最高品質\n\n■ 高品質 2K（有料）\n$0.134/枚（約20円）高品質\n\n■ 標準（無料）\n1日500枚まで無料',
      project: '【プロジェクト】\n\nキャラクター・スタイル・設定を\nまとめて保存できます。\n\n■ 保存方法\n設定後、右上メニューから\n「プロジェクト保存」\n\n■ 操作\n・クリック：読み込み\n・ホバー：エクスポート・削除\n・↓：ファイルから読み込み',
      library: '【キャラクターライブラリ】\n\n登録したキャラクターを\n保存・管理できます。\n\n■ 登録方法\n+ボタンから画像をアップロード\n\n■ 使い方\nクリックで「今回のキャラクター」に追加\n\n■ 編集・削除\nキャラクターにホバーで表示',
      character: '【キャラクター設定】\n\n■ 説明者（必須）\nメインで話を進めるキャラ\n\n■ 相談者（任意）\n質問役。設定すると会話形式に\n\n■ 参考3・4（任意）\n漫画に登場させたい写真など',
      style: '【絵のテイスト】\n絵柄を選択できます。\nドラッグで並び替え可能。\n「画像から参照」で添付画像に合わせます。',
      story: '【入力のコツ】\n・100〜500文字程度が目安\n・箇条書きでもOK\n・感情を入れると表現豊かに'
    };

    var TUTORIAL = [
      { title: 'ステップ1: Google AI Studioにアクセス', content: 'まず、Google AI StudioでAPIキーを取得します。\n\n1. https://aistudio.google.com/apikey にアクセス\n2. Googleアカウントでログイン\n   （Gmail等のアカウントが必要です）\n3. 利用規約に同意\n\n※初めての方でも5分程度で完了します' },
      { title: 'ステップ2: APIキーを作成', content: '画面の指示に従ってAPIキーを作成します。\n\n1. 「Get API key」ボタンをクリック\n2. 「Create API key」を選択\n3. プロジェクトを選択（新規の場合は「Create new project」）\n4. APIキーが表示されます\n5. 「Copy」ボタンでコピー\n\n※このキーは一度しか表示されないので、必ずコピーしてください' },
      { title: 'ステップ3: クレジットカード登録', content: '課金設定を行います（無料枠でも必須）。\n\n1. Google Cloud Console（https://console.cloud.google.com/）にアクセス\n2. 左上のプロジェクト名をクリックして、先ほど作成したプロジェクトを選択\n3. 左メニューの「お支払い」→「アカウントを管理」\n4. 「お支払い方法を追加」をクリック\n5. クレジットカード情報を入力して保存\n\n300ドルまで無料で使用できます（無料クレジット）\n使い切るまでは課金されません' },
      { title: 'ステップ4: APIキーを設定', content: '取得したAPIキーをこのアプリに設定します。\n\n1. 左サイドバーの「API設定」にAPIキーを貼り付け\n2. 「保存」ボタンをクリック\n3. 「保存済み」と表示されることを確認\n\nAPIキーは暗号化されてブラウザに安全に保存されます\nサーバーには送信されません' },
      { title: 'ステップ5: 費用について', content: '画像生成には費用がかかります。\n\n推定費用（画面に表示されます）:\n- 標準: 約$0.XX/枚\n- 高品質2K: 約$0.XX/枚\n- 超高品質4K: 約$0.XX/枚\n\n重要:\n・表示される金額はあくまで推定値です\n・正確な費用は必ずGoogle AI Studioで確認してください\n・https://aistudio.google.com/ の「Usage」タブで確認できます\n・300ドルの無料クレジットを使い切ると課金が開始されます' },
      { title: 'ステップ6: 漫画を生成してみよう', content: 'さっそく漫画を作ってみましょう！\n\n1. 「ストーリー・記事内容」にテキストを入力\n2. 「絵のテイスト」を選択（左メニュー）\n3. 生成枚数を選択（1-5枚）\n4. 「漫画を生成」ボタンをクリック\n\n初めての方は1枚から試すのがおすすめです' }
    ];

    // 認証フォーム
    function AuthForm() {
      var s1 = useState(false); var isSignUp = s1[0], setIsSignUp = s1[1];
      var s2 = useState(''); var email = s2[0], setEmail = s2[1];
      var s3 = useState(''); var password = s3[0], setPassword = s3[1];
      var s4 = useState(''); var fullName = s4[0], setFullName = s4[1];
      var s5 = useState(false); var loading = s5[0], setLoading = s5[1];
      var s6 = useState(''); var error = s6[0], setError = s6[1];

      async function handleSignUp() {
        if (!fullName || !email || !password) {
          setError('すべてのフィールドを入力してください');
          return;
        }
        if (password.length < 8) {
          setError('パスワードは8文字以上にしてください');
          return;
        }

        setLoading(true);
        setError('');

        var result = await supabase.auth.signUp({
          email: email,
          password: password,
          options: {
            data: { full_name: fullName }
          }
        });

        if (result.error) {
          setError(result.error.message);
        } else {
          alert('登録完了！ログインしてください。');
          setIsSignUp(false);
          setEmail('');
          setPassword('');
          setFullName('');
        }
        setLoading(false);
      }

      async function handleSignIn() {
        if (!email || !password) {
          setError('メールアドレスとパスワードを入力してください');
          return;
        }

        setLoading(true);
        setError('');

        var result = await supabase.auth.signInWithPassword({
          email: email,
          password: password
        });

        if (result.error) {
          setError(result.error.message);
        }
        setLoading(false);
      }

      return html`
        <div class="min-h-screen flex items-center justify-center p-4" style="background: var(--color-bg-subtle);">
          <div class="card w-full max-w-md" style="border-radius: var(--radius-lg); box-shadow: var(--shadow-xl);">
            <h1 class="font-bold text-center" style="font-size: var(--font-size-3xl); line-height: var(--line-height-tight); margin-bottom: var(--spacing-2); background: var(--gradient-primary); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
              漫画生成ツール
            </h1>
            <p class="text-center" style="font-size: var(--font-size-base); color: var(--color-text-secondary); margin-bottom: var(--spacing-8);">
              ${isSignUp ? '新規登録' : 'ログイン'}
            </p>

            ${error && html`
              <div class="alert alert-error" style="margin-bottom: var(--spacing-4); padding: var(--spacing-3); font-size: var(--font-size-sm);">
                ${error}
              </div>
            `}

            <div class="space-y-4">
              ${isSignUp && html`
                <div>
                  <label class="block font-medium" style="font-size: var(--font-size-sm); color: var(--color-text-primary); margin-bottom: var(--spacing-2);">お名前 *</label>
                  <input
                    type="text"
                    value=${fullName}
                    onInput=${(e) => setFullName(e.target.value)}
                    class="input-field w-full"
                    placeholder="山田太郎"
                    required
                  />
                </div>
              `}

              <div>
                <label class="block font-medium" style="font-size: var(--font-size-sm); color: var(--color-text-primary); margin-bottom: var(--spacing-2);">メールアドレス *</label>
                <input
                  type="email"
                  value=${email}
                  onInput=${(e) => setEmail(e.target.value)}
                  class="input-field w-full"
                  placeholder="example@email.com"
                  required
                />
              </div>

              <div>
                <label class="block font-medium" style="font-size: var(--font-size-sm); color: var(--color-text-primary); margin-bottom: var(--spacing-2);">パスワード *</label>
                <input
                  type="password"
                  value=${password}
                  onInput=${(e) => setPassword(e.target.value)}
                  class="input-field w-full"
                  placeholder="8文字以上"
                  required
                />
                ${isSignUp && html`
                  <p style="font-size: var(--font-size-xs); color: var(--color-text-muted); margin-top: var(--spacing-1);">8文字以上で入力してください</p>
                `}
              </div>

              <button
                onClick=${isSignUp ? handleSignUp : handleSignIn}
                disabled=${loading}
                class="btn-primary w-full disabled:opacity-50 disabled:cursor-not-allowed"
              >
                ${loading ? '処理中...' : (isSignUp ? '登録する' : 'ログイン')}
              </button>

              <button
                onClick=${() => setIsSignUp(!isSignUp)}
                class="w-full transition-colors"
                style="font-size: var(--font-size-sm); color: var(--color-text-secondary); padding: var(--spacing-2);"
                onMouseEnter=${(e) => e.target.style.color = 'var(--color-text-primary)'}
                onMouseLeave=${(e) => e.target.style.color = 'var(--color-text-secondary)'}
              >
                ${isSignUp ? 'すでにアカウントをお持ちの方はこちら' : 'アカウントをお持ちでない方はこちら'}
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // ヘルプアイコン
    function HelpIcon(props) {
      return html`
        <div class="tooltip-trigger relative inline-block" style="margin-left: var(--spacing-2);">
          <div class="w-5 h-5 bg-gray-200 rounded-full flex items-center justify-center cursor-help font-bold hover:bg-gray-300 transition-colors" style="font-size: var(--font-size-xs); color: var(--color-text-secondary); transition: all var(--transition-base);">?</div>
          <div class="tooltip absolute w-72 bg-gray-800 text-white rounded-lg shadow-lg left-7 top-0 whitespace-pre-wrap" style="z-index: var(--z-index-tooltip); padding: var(--spacing-3); font-size: var(--font-size-xs);">${props.text}</div>
        </div>
      `;
    }

    // モーダル
    function Modal(props) {
      if (!props.isOpen) return null;
      var sizes = { sm: 'max-w-md', md: 'max-w-2xl', lg: 'max-w-4xl', full: 'max-w-[95vw]' };
      var heights = { sm: 'max-h-[90vh]', md: 'max-h-[90vh]', lg: 'max-h-[90vh]', full: 'max-h-[95vh]' };
      return html`
        <div class="fixed inset-0 flex items-center justify-center p-4" style="z-index: var(--z-index-modal-backdrop); background: rgba(26, 35, 50, 0.5); backdrop-filter: blur(4px);" onClick=${props.onClose}>
          <div class="w-full ${sizes[props.size] || sizes.md} ${heights[props.size] || heights.md} overflow-hidden flex flex-col" style="z-index: var(--z-index-modal); background: var(--color-bg-base); border-radius: var(--radius-lg); box-shadow: var(--shadow-2xl);" onClick=${function(e) { e.stopPropagation(); }}>
            <div class="flex justify-between items-center" style="padding: var(--spacing-4); border-bottom: 1px solid var(--color-border);">
              <h3 class="font-bold" style="font-size: var(--font-size-lg); color: var(--color-text-primary);">${props.title}</h3>
              <button onClick=${props.onClose} class="leading-none transition-colors" style="font-size: var(--font-size-2xl); color: var(--color-text-muted); transition: all var(--transition-base);" onMouseEnter=${(e) => e.target.style.color = 'var(--color-text-primary)'} onMouseLeave=${(e) => e.target.style.color = 'var(--color-text-muted)'}>×</button>
            </div>
            <div class="overflow-y-auto flex-1" style="padding: var(--spacing-4);">${props.children}</div>
          </div>
        </div>
      `;
    }

    // 漫画生成アプリ（ログイン後）
    function MangaApp(props) {
      var user = props.user;
      var onSignOut = props.onSignOut;
      var s1 = useState(''); var apiKey = s1[0], setApiKey = s1[1];
      var s2 = useState(false); var apiSaved = s2[0], setApiSaved = s2[1];
      var s3 = useState(false); var showApi = s3[0], setShowApi = s3[1];
      var s4 = useState([]); var chars = s4[0], setChars = s4[1];
      var s5 = useState([null, null, null, null]); var selChars = s5[0], setSelChars = s5[1];
      var s6 = useState(1); var style = s6[0], setStyle = s6[1];
      var s7 = useState(null); var styleRef = s7[0], setStyleRef = s7[1];
      var s8 = useState('formal'); var speech = s8[0], setSpeech = s8[1];
      var s9 = useState('4k'); var model = s9[0], setModel = s9[1];
      var s11 = useState(''); var story = s11[0], setStory = s11[1];
      var s12 = useState(1); var genCount = s12[0], setGenCount = s12[1];
      var s13 = useState([]); var genImages = s13[0], setGenImages = s13[1];
      var s14 = useState(0); var curImg = s14[0], setCurImg = s14[1];
      var s15 = useState(false); var isGen = s15[0], setIsGen = s15[1];
      var s16 = useState(0); var genIdx = s16[0], setGenIdx = s16[1];
      var s17 = useState(''); var error = s17[0], setError = s17[1];
      var s18 = useState([]); var history = s18[0], setHistory = s18[1];
      var s19 = useState([]); var favHist = s19[0], setFavHist = s19[1];
      var s20 = useState([]); var projects = s20[0], setProjects = s20[1];
      var s21 = useState(null); var curProj = s21[0], setCurProj = s21[1];
      var s22 = useState({ monthly: [], total: { count: 0, cost: 0 } }); var usage = s22[0], setUsage = s22[1];
      var s23 = useState(false); var sidebar = s23[0], setSidebar = s23[1];
      var s24 = useState(['char', 'style']); var accord = s24[0], setAccord = s24[1];
      var s25 = useState(null); var lastSave = s25[0], setLastSave = s25[1];
      var s26 = useState(false); var showTut = s26[0], setShowTut = s26[1];
      var s27 = useState(0); var tutStep = s27[0], setTutStep = s27[1];
      var s28 = useState(false); var showSamp = s28[0], setShowSamp = s28[1];
      var s29 = useState(false); var showHist = s29[0], setShowHist = s29[1];
      var s30 = useState(false); var showUsage = s30[0], setShowUsage = s30[1];
      var s31 = useState(false); var showAddChar = s31[0], setShowAddChar = s31[1];
      var s32 = useState(false); var showAddProj = s32[0], setShowAddProj = s32[1];
      var s33 = useState(false); var showImg = s33[0], setShowImg = s33[1];
      var s34 = useState(null); var modalImg = s34[0], setModalImg = s34[1];
      var s35 = useState(false); var showHistDet = s35[0], setShowHistDet = s35[1];
      var s36 = useState(null); var histDet = s36[0], setHistDet = s36[1];
      var s37 = useState(false); var showDraft = s37[0], setShowDraft = s37[1];
      var s38 = useState(null); var draft = s38[0], setDraft = s38[1];
      var s39 = useState(''); var newCharName = s39[0], setNewCharName = s39[1];
      var s40 = useState(null); var newCharImg = s40[0], setNewCharImg = s40[1];
      var s41 = useState(''); var newProjName = s41[0], setNewProjName = s41[1];
      var s42 = useState([]); var promptSteps = s42[0], setPromptSteps = s42[1];
      var s43 = useState(0); var currentStep = s43[0], setCurrentStep = s43[1];
      var s44 = useState(0); var totalSteps = s44[0], setTotalSteps = s44[1];
      var s45 = useState('simple'); var genMode = s45[0], setGenMode = s45[1];
      var s46 = useState(0); var modalImgIdx = s46[0], setModalImgIdx = s46[1];
      var s47 = useState(1); var charAbsentCount = s47[0], setCharAbsentCount = s47[1];
      var s48 = useState([]); var customStyles = s48[0], setCustomStyles = s48[1];
      var s49 = useState(false); var showAddStyle = s49[0], setShowAddStyle = s49[1];
      var s50 = useState(''); var newStyleTitle = s50[0], setNewStyleTitle = s50[1];
      var s51 = useState(''); var newStyleDesc = s51[0], setNewStyleDesc = s51[1];
      var s52 = useState(''); var newStylePrompt = s52[0], setNewStylePrompt = s52[1];
      var s53 = useState(true); var enableSubChars = s53[0], setEnableSubChars = s53[1];
      var s54 = useState([{name: '', features: ''}, {name: '', features: ''}, {name: '', features: ''}, {name: '', features: ''}]); var charDetails = s54[0], setCharDetails = s54[1];
      var s55 = useState(false); var showCharDetail = s55[0], setShowCharDetail = s55[1];
      var s56 = useState(0); var charDetailIdx = s56[0], setCharDetailIdx = s56[1];
      var s57 = useState(false); var showPanelHelp = s57[0], setShowPanelHelp = s57[1];
      var s58 = useState(false); var showAdvancedSettings = s58[0], setShowAdvancedSettings = s58[1];
      var s59 = useState(false); var showUserMenu = s59[0], setShowUserMenu = s59[1];
      var s60 = useState(false); var showEditStyle = s60[0], setShowEditStyle = s60[1];
      var s61 = useState(null); var editingStyleId = s61[0], setEditingStyleId = s61[1];
      var s62 = useState(''); var editStyleTitle = s62[0], setEditStyleTitle = s62[1];
      var s63 = useState(''); var editStyleDesc = s63[0], setEditStyleDesc = s63[1];
      var s64 = useState(''); var editStylePrompt = s64[0], setEditStylePrompt = s64[1];
      var s65 = useState(null); var draggedStyle = s65[0], setDraggedStyle = s65[1];
      var s66 = useState([]); var styleOrder = s66[0], setStyleOrder = s66[1];
      var s67 = useState(false); var showEditChar = s67[0], setShowEditChar = s67[1];
      var s68 = useState(null); var editingCharId = s68[0], setEditingCharId = s68[1];
      var s69 = useState(''); var editCharName = s69[0], setEditCharName = s69[1];
      var s70 = useState(null); var editCharImg = s70[0], setEditCharImg = s70[1];
      var s71 = useState(0); var elapsedTime = s71[0], setElapsedTime = s71[1];
      var s72 = useState(null); var genStartTime = s72[0], setGenStartTime = s72[1];

      // キャラクターシート生成関連
      var s73 = useState('manga'); var activeTab = s73[0], setActiveTab = s73[1];
      var s74 = useState(0); var curCharSheet = s74[0], setCurCharSheet = s74[1];
      var s75 = useState(''); var charSheetName = s75[0], setCharSheetName = s75[1];
      var s76 = useState(''); var charSheetDesc = s76[0], setCharSheetDesc = s76[1];
      var s77 = useState(null); var charSheetBaseImg = s77[0], setCharSheetBaseImg = s77[1];
      var s78 = useState(1); var charSheetCount = s78[0], setCharSheetCount = s78[1];
      var s79 = useState(0); var charSheetGenStep = s79[0], setCharSheetGenStep = s79[1];
      var s80 = useState([]); var generatedCharSheets = s80[0], setGeneratedCharSheets = s80[1];
      var s81 = useState([]); var charSheetSaved = s81[0], setCharSheetSaved = s81[1];
      var s82 = useState(''); var charSheetSaveMsg = s82[0], setCharSheetSaveMsg = s82[1];
      var s83 = useState([]); var characterSheets = s83[0], setCharacterSheets = s83[1];
      var s84 = useState(false); var showApiEdit = s84[0], setShowApiEdit = s84[1];

      var fileRef = useRef(null);
      var editFileRef = useRef(null);
      var charRefs = useRef([null, null, null, null]);
      var styleRefInput = useRef(null);
      var charSheetFileRef = useRef(null);
      var cancelRef = useRef(false);

      // 初期化
      useEffect(function() {
        try {
          // セキュリティ強化：暗号化されたAPIキーを復号化
          var encryptedKey = localStorage.getItem('manga_api_key');
          if (encryptedKey) {
            var decryptedKey = decryptApiKey(encryptedKey);
            setApiKey(decryptedKey);
            setApiSaved(true);
          }
          var c = localStorage.getItem('manga_chars');
          if (c) setChars(JSON.parse(c));
          // Supabaseから履歴を読み込み
          supabase
            .from('mangas')
            .select('*')
            .eq('user_id', user.id)
            .order('created_at', { ascending: false })
            .limit(10)
            .then(function(result) {
              if (result.error) {
                console.error('履歴読み込みエラー:', result.error);
                setHistory([]);
              } else {
                var histArr = result.data.map(function(item) {
                  return {
                    id: item.id,
                    img: item.image_url,
                    settings: {
                      style: item.style_id,
                      styleName: item.style_name,
                      speech: item.settings?.speech,
                      model: item.settings?.model,
                      modelName: item.settings?.modelName,
                      story: (item.story || '').substring(0, 80) + '...'
                    },
                    ts: item.created_at
                  };
                });
                setHistory(histArr);
              }
            });
          var fh = localStorage.getItem('manga_fav_hist');
          if (fh) setFavHist(JSON.parse(fh));
          var p = localStorage.getItem('manga_projects');
          if (p) setProjects(JSON.parse(p));
          var u = localStorage.getItem('manga_usage');
          if (u) setUsage(JSON.parse(u));
          var t = localStorage.getItem('manga_tut_seen');
          if (!t) setShowTut(true);
          var d = localStorage.getItem('manga_draft');
          if (d) {
            var dd = JSON.parse(d);
            if (dd.story && dd.story.length > 0) { setDraft(dd); setShowDraft(true); }
          }
          var m = localStorage.getItem('manga_gen_mode');
          if (m) setGenMode(m);
          var ca = localStorage.getItem('manga_char_absent_count');
          if (ca) setCharAbsentCount(parseInt(ca, 10));
          var cd = localStorage.getItem('manga_char_details');
          if (cd) setCharDetails(JSON.parse(cd));
        } catch(e) { console.error(e); }
      }, []);

      // カスタムスタイル読み込み
      useEffect(function() {
        if (!user) return;
        supabase
          .from('custom_styles')
          .select('*')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .then(function(result) {
            if (result.error) {
              console.error('カスタムスタイル読み込みエラー:', result.error);
            } else {
              setCustomStyles(result.data || []);
            }
          });
      }, [user]);

      // スタイル並び順の読み込み
      useEffect(function() {
        try {
          var order = localStorage.getItem('manga_style_order');
          if (order) setStyleOrder(JSON.parse(order));
        } catch(e) { console.error(e); }
      }, []);

      // キャラクターシート読み込み
      useEffect(function() {
        if (user) {
          loadCharacterSheets();
        }
      }, [user]);

      // ドロップダウンメニューの外側クリックで閉じる
      useEffect(function() {
        if (!showUserMenu) return;

        function handleClickOutside(e) {
          var userMenuBtn = e.target.closest('.user-menu-button');
          var userMenuDropdown = e.target.closest('.user-menu-dropdown');

          if (!userMenuBtn && !userMenuDropdown) {
            setShowUserMenu(false);
          }
        }

        setTimeout(function() {
          document.addEventListener('click', handleClickOutside);
        }, 0);

        return function() {
          document.removeEventListener('click', handleClickOutside);
        };
      }, [showUserMenu]);

      // ファイル名パース: "01_分析_text.txt" → { order: 1, name: "分析", type: "text" }
      function parseFileName(filename) {
        var parts = filename.replace('.txt', '').split('_');
        if (parts.length < 3) return null;
        return {
          order: parseInt(parts[0], 10),
          name: parts.slice(1, -1).join('_'),
          type: parts[parts.length - 1]
        };
      }

      // グロブパターンで試すファイル名候補
      function generateFilePatterns(num) {
        var numStr = String(num).padStart(2, '0');
        var names = ['分析', '構成', '設計', '詳細', '画像生成', 'analysis', 'structure', 'design', 'detail', 'image', 'generation'];
        var types = ['text', 'image'];
        var patterns = [];

        names.forEach(function(name) {
          types.forEach(function(type) {
            patterns.push(numStr + '_' + name + '_' + type + '.txt');
          });
        });

        return patterns;
      }

      // 1つの番号で最初に見つかったファイルを読み込む
      function tryLoadOneNumber(num) {
        var patterns = generateFilePatterns(num);

        return Promise.race(
          patterns.map(function(filename) {
            return fetch('./prompts/' + filename)
              .then(function(res) {
                if (!res.ok) throw new Error('Not found');
                return res.text().then(function(txt) {
                  var parsed = parseFileName(filename);
                  return {
                    file: filename,
                    name: parsed.name,
                    type: parsed.type,
                    template: txt,
                    order: parsed.order
                  };
                });
              });
          })
        ).catch(function() {
          return null;
        });
      }

      // プロンプトテンプレート読み込み（簡易モード）
      useEffect(function() {
        function loadPrompts() {
          // 簡易モードを使用（UI上では「生成」と表示）
          var knownFiles = [
            { file: '01_簡易_image.txt', name: '生成', type: 'image', order: 1 }
          ];

          var promises = knownFiles.map(function(fileInfo) {
            return fetch('./prompts/' + fileInfo.file)
              .then(function(res) {
                if (!res.ok) throw new Error('Not found');
                return res.text();
              })
              .then(function(template) {
                return {
                  file: fileInfo.file,
                  name: fileInfo.name,
                  type: fileInfo.type,
                  order: fileInfo.order,
                  template: template
                };
              })
              .catch(function(err) {
                console.warn('ファイル読み込み失敗:', fileInfo.file, err.message);
                return null;
              });
          });

          Promise.all(promises)
            .then(function(results) {
              var foundSteps = results.filter(function(r) { return r !== null; });

              if (foundSteps.length === 0) {
                console.error('プロンプトファイルが見つかりません。デフォルトを使用します。');
                foundSteps = [
                  { file: '01_簡易_image.txt', name: '生成', type: 'image', template: getDefaultPrompt(), order: 1 }
                ];
              }

              foundSteps.sort(function(a, b) { return a.order - b.order; });
              setPromptSteps(foundSteps);
              setTotalSteps(foundSteps.length);
              console.log('プロンプト読み込み完了:', foundSteps.length + 'ステップ');
              foundSteps.forEach(function(s) {
                console.log('  ✓ ' + s.file + ' (' + s.name + ', ' + s.type + ')');
              });
            });
        }

        loadPrompts();
      }, [genMode]);

      // 下書き自動保存
      useEffect(function() {
        var timer = setTimeout(function() {
          try {
            localStorage.setItem('manga_draft', JSON.stringify({ story: story, style: style, speech: speech, model: model, genCount: genCount, ts: new Date().toISOString() }));
            setLastSave(new Date());
          } catch(e) {}
        }, 3000);
        return function() { clearTimeout(timer); };
      }, [story, style, speech, model, genCount]);

      // プレビューモーダルでのキーボード操作
      useEffect(function() {
        if (!showImg) return;

        function handleKeyDown(e) {
          if (e.key === 'ArrowLeft' && modalImgIdx > 0) {
            setModalImgIdx(modalImgIdx - 1);
          } else if (e.key === 'ArrowRight' && modalImgIdx < genImages.length - 1) {
            setModalImgIdx(modalImgIdx + 1);
          } else if (e.key === 'Escape') {
            setShowImg(false);
          }
        }

        window.addEventListener('keydown', handleKeyDown);
        return function() {
          window.removeEventListener('keydown', handleKeyDown);
        };
      }, [showImg, modalImgIdx, genImages.length]);

      // 経過時間の更新
      useEffect(function() {
        if (!isGen) {
          setElapsedTime(0);
          return;
        }

        var timer = setInterval(function() {
          if (genStartTime) {
            var elapsed = Math.floor((Date.now() - genStartTime) / 1000);
            setElapsedTime(elapsed);
          }
        }, 1000);

        return function() {
          clearInterval(timer);
        };
      }, [isGen, genStartTime]);

      // 履歴詳細モーダルでのキーボード操作
      useEffect(function() {
        if (!showHistDet || !histDet) return;

        function handleKeyDown(e) {
          var currentIndex = history.findIndex(function(h) { return h.id === histDet.id; });

          if (e.key === 'ArrowLeft' && currentIndex < history.length - 1) {
            // 前へ
            setHistDet(history[currentIndex + 1]);
          } else if (e.key === 'ArrowRight' && currentIndex > 0) {
            // 次へ
            setHistDet(history[currentIndex - 1]);
          } else if (e.key === 'Escape') {
            setShowHistDet(false);
          }
        }

        window.addEventListener('keydown', handleKeyDown);
        return function() {
          window.removeEventListener('keydown', handleKeyDown);
        };
      }, [showHistDet, histDet, history]);

      function restoreDraft() {
        if (draft) {
          setStory(draft.story || '');
          setStyle(draft.style || 1);
          setSpeech(draft.speech || 'formal');
          setModel(draft.model || '4k');
          setGenCount(draft.genCount || 1);
        }
        setShowDraft(false);
      }

      function saveApi() {
        // APIキーのバリデーション
        if (!apiKey || apiKey.trim().length === 0) {
          alert('APIキーを入力してください');
          return;
        }

        // Google AI StudioのAPIキー形式チェック
        // 通常「AIza」で始まり、30文字以上の英数字、ハイフン、アンダースコア
        var isValidFormat = /^AIza[A-Za-z0-9_-]{35,}$/.test(apiKey.trim());

        if (!isValidFormat) {
          alert('APIキーの形式が正しくありません。\n\nGoogle AI StudioのAPIキーは「AIza」で始まる39文字の文字列です。\n正しいAPIキーを入力してください。');
          setApiSaved(false);
          return;
        }

        // セキュリティ強化：APIキーを暗号化して保存
        var encrypted = encryptApiKey(apiKey.trim());
        localStorage.setItem('manga_api_key', encrypted);
        setApiSaved(true);
        setShowApiEdit(false); // 編集モードを閉じる
      }

      // 画像圧縮関数
      function compressImage(dataUrl, maxWidth, quality) {
        return new Promise(function(resolve) {
          var img = new Image();
          img.onload = function() {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');

            // アスペクト比を保持してリサイズ
            var width = img.width;
            var height = img.height;

            if (width > maxWidth) {
              height = Math.round((height * maxWidth) / width);
              width = maxWidth;
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            // 圧縮して新しいData URLを取得
            var compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
            resolve(compressedDataUrl);
          };
          img.src = dataUrl;
        });
      }

      function addChar() {
        if (!newCharName || !newCharImg) return;
        // 画像を圧縮してから保存（最大幅400px、品質0.6）
        compressImage(newCharImg, 400, 0.6).then(function(compressedImg) {
          var nc = { id: 'c_' + Date.now(), name: newCharName, img: compressedImg, source: 'local' };
          var ncs = chars.concat([nc]);
          setChars(ncs);

          // localStorageにはローカルキャラクターのみ保存
          var localChars = ncs.filter(function(c) { return c.source !== 'supabase'; });
          localStorage.setItem('manga_chars', JSON.stringify(localChars));

          setShowAddChar(false);
          setNewCharName('');
          setNewCharImg(null);
        });
      }

      function addCustomStyle() {
        if (!newStyleTitle || !newStylePrompt) {
          alert('タイトルとプロンプトは必須です');
          return;
        }

        console.log('カスタムスタイル追加開始:', { title: newStyleTitle, user_id: user.id });

        supabase
          .from('custom_styles')
          .insert([{
            user_id: user.id,
            title: newStyleTitle,
            description: newStyleDesc,
            prompt: newStylePrompt
          }])
          .then(function(result) {
            console.log('Insert結果:', result);
            if (result.error) {
              console.error('カスタムスタイル保存エラー:', result.error);
              alert('保存に失敗しました:\n' + result.error.message + '\n\n【確認事項】\n1. Supabaseでcustom_stylesテーブルを作成しましたか？\n2. ブラウザのコンソール(F12)でエラーを確認してください');
              return;
            }
            // 再読み込み
            return supabase
              .from('custom_styles')
              .select('*')
              .eq('user_id', user.id)
              .order('created_at', { ascending: false });
          })
          .then(function(result) {
            if (result && !result.error) {
              console.log('カスタムスタイル読み込み成功:', result.data);
              setCustomStyles(result.data || []);
              setShowAddStyle(false);
              setNewStyleTitle('');
              setNewStyleDesc('');
              setNewStylePrompt('');
              alert('カスタムスタイルを追加しました');
            } else if (result && result.error) {
              console.error('読み込みエラー:', result.error);
            }
          })
          .catch(function(error) {
            console.error('予期しないエラー:', error);
            alert('予期しないエラーが発生しました:\n' + error.message);
          });
      }

      function delCustomStyle(id) {
        if (!confirm('このカスタムスタイルを削除しますか？')) return;

        supabase
          .from('custom_styles')
          .delete()
          .eq('id', id)
          .eq('user_id', user.id)
          .then(function(result) {
            if (result.error) {
              console.error('削除エラー:', result.error);
              alert('削除に失敗しました');
            } else {
              setCustomStyles(customStyles.filter(function(s) { return s.id !== id; }));
              // 削除したスタイルが選択されていた場合はデフォルトに戻す
              if (style === 'custom_' + id) {
                setStyle(1);
              }
            }
          });
      }

      function editCustomStyle(id) {
        var cs = customStyles.find(function(s) { return s.id === id; });
        if (!cs) return;

        setEditingStyleId(id);
        setEditStyleTitle(cs.title);
        setEditStyleDesc(cs.description || '');
        setEditStylePrompt(cs.prompt);
        setShowEditStyle(true);
      }

      function updateCustomStyle() {
        if (!editStyleTitle || !editStylePrompt) {
          alert('タイトルとプロンプトは必須です');
          return;
        }

        supabase
          .from('custom_styles')
          .update({
            title: editStyleTitle,
            description: editStyleDesc,
            prompt: editStylePrompt
          })
          .eq('id', editingStyleId)
          .eq('user_id', user.id)
          .then(function(result) {
            if (result.error) {
              console.error('更新エラー:', result.error);
              alert('更新に失敗しました');
              return;
            }
            // 再読み込み
            return supabase
              .from('custom_styles')
              .select('*')
              .eq('user_id', user.id)
              .order('created_at', { ascending: false });
          })
          .then(function(result) {
            if (result && !result.error) {
              setCustomStyles(result.data || []);
              setShowEditStyle(false);
              setEditingStyleId(null);
              setEditStyleTitle('');
              setEditStyleDesc('');
              setEditStylePrompt('');
              alert('カスタムスタイルを更新しました');
            } else if (result && result.error) {
              console.error('読み込みエラー:', result.error);
            }
          });
      }

      function handleDragStart(e, styleId) {
        setDraggedStyle(styleId);
        e.dataTransfer.effectAllowed = 'move';
      }

      function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }

      function handleDrop(e, targetStyleId) {
        e.preventDefault();
        if (!draggedStyle || draggedStyle === targetStyleId) return;

        var allStyles = getAllStyles();
        var currentOrder = styleOrder.length > 0 ? styleOrder.slice() : allStyles.map(function(s) { return s.id; });

        // styleOrderに含まれていない新しいスタイルを自動的に追加
        allStyles.forEach(function(s) {
          if (currentOrder.indexOf(s.id) === -1) {
            currentOrder.push(s.id);
          }
        });

        var draggedIdx = currentOrder.indexOf(draggedStyle);
        var targetIdx = currentOrder.indexOf(targetStyleId);

        if (draggedIdx === -1 || targetIdx === -1) return;

        var newOrder = currentOrder.slice();
        newOrder.splice(draggedIdx, 1);
        newOrder.splice(targetIdx, 0, draggedStyle);

        setStyleOrder(newOrder);
        localStorage.setItem('manga_style_order', JSON.stringify(newOrder));
        setDraggedStyle(null);
      }

      async function delChar(id) {
        if (!confirm('削除しますか？')) return;

        var char = chars.find(function(c) { return c.id === id; });
        if (!char) return;

        // Supabaseのキャラクターの場合
        if (char.source === 'supabase') {
          try {
            var realId = id.replace('supabase_', '');

            // Storageのファイルを削除
            if (char.img) {
              var match = char.img.match(/manga-images\/([^?]+)/);
              if (match) {
                var filePath = match[1];
                var storageResult = await supabase.storage
                  .from('manga-images')
                  .remove([filePath]);
                if (storageResult.error) {
                  console.warn('Storage削除エラー:', storageResult.error);
                }
              }
            }

            // DBのレコードを削除
            await supabase
              .from('character_sheets')
              .delete()
              .eq('id', realId)
              .eq('user_id', user.id);

            // 再読み込み
            loadCharacterSheets();
          } catch (err) {
            console.error('削除エラー:', err);
            alert('削除に失敗しました');
          }
        } else {
          // ローカルキャラクターの場合
          var ncs = chars.filter(function(c) { return c.id !== id; });
          setChars(ncs);

          var localChars = ncs.filter(function(c) { return c.source !== 'supabase'; });
          localStorage.setItem('manga_chars', JSON.stringify(localChars));
        }

        setSelChars(selChars.map(function(c) { return c && c.id === id ? null : c; }));
      }

      function editChar(c) {
        setEditingCharId(c.id);
        setEditCharName(c.name);
        setEditCharImg(c.img);
        setShowEditChar(true);
      }

      function updateChar() {
        if (!editCharName.trim()) {
          alert('キャラクター名を入力してください');
          return;
        }
        if (!editCharImg) {
          alert('画像を選択してください');
          return;
        }

        var ncs = chars.map(function(c) {
          if (c.id === editingCharId) {
            return { id: c.id, name: editCharName, img: editCharImg, source: c.source };
          }
          return c;
        });
        setChars(ncs);

        // localStorageにはローカルキャラクターのみ保存
        var localChars = ncs.filter(function(c) { return c.source !== 'supabase'; });
        localStorage.setItem('manga_chars', JSON.stringify(localChars));

        // 選択中のキャラクターも更新
        setSelChars(selChars.map(function(c) {
          if (c && c.id === editingCharId) {
            return { id: editingCharId, name: editCharName, img: editCharImg };
          }
          return c;
        }));

        setShowEditChar(false);
        setEditingCharId(null);
        setEditCharName('');
        setEditCharImg(null);
      }

      function handleFile(e, idx) {
        var f = e.target.files[0];
        if (!f) return;

        // セキュリティ：画像ファイル検証
        try {
          validateImageFile(f);
        } catch (err) {
          alert(err.message);
          e.target.value = '';
          return;
        }

        var r = new FileReader();
        r.onload = function(ev) {
          // 一時キャラクターも圧縮してメモリ使用量を削減
          compressImage(ev.target.result, 500, 0.7).then(function(compressedImg) {
            var nc = selChars.slice();
            nc[idx] = { id: 't_' + Date.now(), name: f.name, img: compressedImg, temp: true };
            setSelChars(nc);
          });
        };
        r.readAsDataURL(f);
      }

      function openCharDetail(idx) {
        setCharDetailIdx(idx);
        setShowCharDetail(true);
      }

      function updateCharDetail(idx, field, value) {
        var newDetails = charDetails.slice();
        // セキュリティ：入力値をサニタイズ
        var sanitizedValue = sanitizeInput(value, field === 'name' ? 50 : 200);
        newDetails[idx] = Object.assign({}, newDetails[idx], { [field]: sanitizedValue });
        setCharDetails(newDetails);
        localStorage.setItem('manga_char_details', JSON.stringify(newDetails));
      }

      // コマ情報を抽出
      function extractPanelInfo(storyText) {
        var panelPattern = /【コマ(\d+)】([^【]*)/g;
        var panels = [];
        var match;

        while ((match = panelPattern.exec(storyText)) !== null) {
          var content = match[2].trim();

          var panel = {
            number: panels.length + 1, // 自動的に1から振り直す
            position: '',
            size: '',
            speech: '',
            background: '',
            character: '',
            expression: '',
            cameraAngle: '',
            cameraDistance: '',
            content: '' // 内容フィールドを追加
          };

          // 各項目を抽出
          var posMatch = content.match(/位置[：:]\s*([^\n]+)/);
          if (posMatch) panel.position = posMatch[1].trim();

          var sizeMatch = content.match(/サイズ[：:]\s*([^\n]+)/);
          if (sizeMatch) panel.size = sizeMatch[1].trim();

          var speechMatch = content.match(/セリフ[：:]\s*([^\n]+)/);
          if (speechMatch) panel.speech = speechMatch[1].trim();

          var bgMatch = content.match(/背景[：:]\s*([^\n]+)/);
          if (bgMatch) panel.background = bgMatch[1].trim();

          var charMatch = content.match(/キャラ[：:]\s*([^\n]+)/);
          if (charMatch) panel.character = charMatch[1].trim();

          var exprMatch = content.match(/表情[：:]\s*([^\n]+)/);
          if (exprMatch) panel.expression = exprMatch[1].trim();

          var angleMatch = content.match(/カメラアングル[：:]\s*([^\n]+)/);
          if (angleMatch) panel.cameraAngle = angleMatch[1].trim();

          var distMatch = content.match(/カメラ距離[：:]\s*([^\n]+)/);
          if (distMatch) panel.cameraDistance = distMatch[1].trim();

          var contentMatch = content.match(/内容[：:]\s*([^\n]+)/);
          if (contentMatch) panel.content = contentMatch[1].trim();

          panels.push(panel);
        }

        return panels;
      }

      // コマ情報からレイアウト指示を生成
      function generateLayoutInstructions(panels) {
        if (panels.length === 0) return '';

        var instructions = '\n\n🚨🚨🚨 CRITICAL OVERRIDE - CUSTOM PANEL LAYOUT 🚨🚨🚨\n\n';
        instructions += '⚠️ THIS IS A ' + panels.length + '-PANEL MANGA, NOT A 4-PANEL MANGA ⚠️\n';
        instructions += '⚠️ REPEAT: ' + panels.length + ' PANELS ONLY. DO NOT CREATE 4 PANELS. ⚠️\n';
        instructions += '⚠️ IF YOU CREATE ' + (panels.length === 2 ? '3 OR 4' : panels.length === 3 ? '2 OR 4' : '2 OR 3') + ' PANELS, IT IS WRONG. ⚠️\n\n';

        instructions += '■ ABSOLUTE PANEL COUNT: ' + panels.length + ' panels (NO MORE, NO LESS)\n';
        instructions += '■ This overrides any default 4-panel instructions elsewhere in the prompt\n';
        instructions += '■ Panel count is MANDATORY and NON-NEGOTIABLE\n\n';

        instructions += '【DETAILED PANEL SPECIFICATIONS】\n\n';

        panels.forEach(function(panel) {
          instructions += '━━━ Panel ' + panel.number + ' of ' + panels.length + ' ━━━\n';
          if (panel.position) instructions += '📍 Position: ' + panel.position + '\n';
          if (panel.size) instructions += '📏 Size: ' + panel.size + '\n';
          if (panel.content) instructions += '🎬 Content: ' + panel.content + '\n';
          if (panel.speech) instructions += '💬 Speech: ' + panel.speech + '\n';
          if (panel.background) instructions += '🖼️  Background: ' + panel.background + '\n';
          if (panel.character) instructions += '👤 Character: ' + panel.character + '\n';
          if (panel.expression) instructions += '😊 Expression: ' + panel.expression + '\n';
          if (panel.cameraAngle) instructions += '📷 Camera Angle: ' + panel.cameraAngle + '\n';
          if (panel.cameraDistance) instructions += '🔭 Camera Distance: ' + panel.cameraDistance + '\n';
          instructions += '\n';
        });

        instructions += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n';
        instructions += '🔴 CRITICAL REQUIREMENTS:\n';
        instructions += '✓ Create EXACTLY ' + panels.length + ' panels (count them before generating)\n';
        instructions += '✓ Follow the exact positions and sizes specified above\n';
        instructions += '✓ Use the speech bubbles and content specified for each panel\n';
        instructions += '✓ Maintain 2:3 vertical aspect ratio for the entire image\n';
        instructions += '✓ Draw clear panel borders between panels\n';
        instructions += '✓ Ensure all ' + panels.length + ' panels fit within a single vertical image\n\n';

        instructions += '❌ DO NOT:\n';
        instructions += '× Create 4 panels (this is a ' + panels.length + '-panel manga)\n';
        instructions += '× Add extra panels beyond the ' + panels.length + ' specified\n';
        instructions += '× Ignore the custom layout instructions\n';
        instructions += '× Use default 4-panel layout\n\n';

        instructions += '🚨 REMINDER: This is a ' + panels.length + '-panel manga. Count: ' + panels.length + '. Not 4. (' + panels.length + ' panels) 🚨\n';

        return instructions;
      }

      // 高さ情報を抽出（Webtoonスタイル用）
      function extractHeightInfo(storyText) {
        var heightMatch = storyText.match(/高さ[：:]\s*(ショート|ミディアム|トール|フルスクリーン)/i);
        if (!heightMatch) return null;
        return heightMatch[1];
      }

      // 高さ指示を生成（Webtoonスタイル用）
      function generateHeightInstruction(heightType) {
        if (!heightType) return '';

        var heightMap = {
          'ショート': {
            range: '約800〜900px',
            ratio: '3:2程度',
            usage: 'セリフだけのコマ、リアクションショット、ちょっとした会話',
            instruction: 'COMPACT VERTICAL COMPOSITION - Short height (aspect ratio approximately 3:2). Concise scene focusing on facial expressions, quick reactions, or brief dialogue. Tight framing with minimal vertical space. Suitable for transitional moments or short exchanges.'
          },
          'ミディアム': {
            range: '約1440〜1620px',
            ratio: '3:4程度',
            usage: '標準的なシーン、通常の会話、日常描写',
            instruction: 'STANDARD VERTICAL COMPOSITION - Medium height (aspect ratio approximately 3:4). Balanced scene composition showing characters in typical interactions, everyday situations, or standard dialogue exchanges. Moderate vertical space allowing for comfortable character placement and environmental context.'
          },
          'トール': {
            range: '約2160〜2400px',
            ratio: '1:2程度',
            usage: '重要なシーン、縦の動きを強調、立ち姿の全身',
            instruction: 'EXTENDED VERTICAL COMPOSITION - Tall height (aspect ratio approximately 1:2). Emphasized vertical space perfect for showcasing full-body standing poses, vertical motion (jumping, falling, rising), or important dramatic moments. Extended composition creating strong visual impact and emphasizing character presence.'
          },
          'フルスクリーン': {
            range: '約2700px以上',
            ratio: '1:2.5以上',
            usage: 'クライマックス、見開き的演出、圧倒的な迫力シーン',
            instruction: 'FULL SCREEN VERTICAL COMPOSITION - Maximum height (aspect ratio 1:2.5 or greater). Overwhelming dramatic scene designed for climactic moments, spread-page level impact, or breathtaking visual spectacle. Extra-long vertical space creating immersive cinematic experience with maximum emotional and visual intensity.'
          }
        };

        var info = heightMap[heightType];
        if (!info) return '';

        return '\n\n【WEBTOON HEIGHT SPECIFICATION - CRITICAL】\n\n' +
               '■ Specified Height Type: ' + heightType + ' (' + info.range + ', ' + info.ratio + ')\n' +
               '■ Usage: ' + info.usage + '\n\n' +
               '⚠️ COMPOSITION INSTRUCTION:\n' +
               info.instruction + '\n\n' +
               '✓ Generate image with appropriate vertical dimension matching the specified height type\n' +
               '✓ Width remains fixed at 1080px\n' +
               '✓ Adjust composition and framing to suit the vertical space available\n';
      }

      // 余白情報を抽出（Webtoonスタイル用）
      function extractMarginInfo(storyText) {
        // フォーマット: 余白：上5% / #A0A0A0 ／ 下8% / #909090
        var marginMatch = storyText.match(/余白[：:]\s*上(\d+)%\s*\/\s*(#[0-9A-Fa-f]{6})\s*[／/]\s*下(\d+)%\s*\/\s*(#[0-9A-Fa-f]{6})/);
        if (!marginMatch) return null;

        return {
          top: parseInt(marginMatch[1]),
          topColor: marginMatch[2],
          bottom: parseInt(marginMatch[3]),
          bottomColor: marginMatch[4]
        };
      }

      // 余白指示を生成（Webtoonスタイル用）
      function generateMarginInstruction(marginInfo) {
        if (!marginInfo) return '';

        return '\n\n【WEBTOON MARGIN SPECIFICATION - CRITICAL REQUIREMENT】\n\n' +
               '⚠️ ABSOLUTE PRIORITY: This image MUST include top and bottom margin bars:\n\n' +
               '■ TOP MARGIN BAR:\n' +
               '- Height: ' + marginInfo.top + '% of total image height\n' +
               '- Color: ' + marginInfo.topColor + ' (solid fill, no gradients)\n' +
               '- Position: Absolute top of image (y=0)\n' +
               '- Width: 100% (full 1080px width)\n' +
               '- NO content, NO text, NO decorations in this area\n\n' +
               '■ BOTTOM MARGIN BAR:\n' +
               '- Height: ' + marginInfo.bottom + '% of total image height\n' +
               '- Color: ' + marginInfo.bottomColor + ' (solid fill, no gradients)\n' +
               '- Position: Absolute bottom of image\n' +
               '- Width: 100% (full 1080px width)\n' +
               '- NO content, NO text, NO decorations in this area\n\n' +
               '■ MAIN CONTENT AREA:\n' +
               '- Positioned between top and bottom margin bars\n' +
               '- Available height: ' + (100 - marginInfo.top - marginInfo.bottom) + '% of total image\n' +
               '- All illustration content (characters, backgrounds, effects) MUST stay within this middle area\n' +
               '- Content must NOT overlap or bleed into margin bars\n\n' +
               '⚠️ IMPLEMENTATION REQUIREMENTS:\n' +
               '✓ Create solid color bars at exact positions and sizes specified\n' +
               '✓ Margin bars are MANDATORY - do not skip or forget them\n' +
               '✓ Use EXACT hex colors specified (no approximations)\n' +
               '✓ Margin bars must be completely solid (no transparency, no gradients)\n' +
               '✓ Main illustration content must be carefully composed to fit within the middle ' + (100 - marginInfo.top - marginInfo.bottom) + '% area\n' +
               '✓ Think of margin bars as letterboxing for cinematic effect\n\n' +
               '🎬 VISUAL STRUCTURE:\n' +
               '┌─────────────────────────────┐\n' +
               '│ TOP MARGIN (' + marginInfo.topColor + ')    │ ← ' + marginInfo.top + '%\n' +
               '├─────────────────────────────┤\n' +
               '│                             │\n' +
               '│   MAIN CONTENT AREA         │ ← ' + (100 - marginInfo.top - marginInfo.bottom) + '%\n' +
               '│   (Characters, BG, etc.)    │\n' +
               '│                             │\n' +
               '├─────────────────────────────┤\n' +
               '│ BOTTOM MARGIN (' + marginInfo.bottomColor + ') │ ← ' + marginInfo.bottom + '%\n' +
               '└─────────────────────────────┘\n';
      }

      // デフォルトプロンプト
      function getDefaultPromptStep1() {
        return 'あなたは漫画制作のプロンプトエンジニアです。\n以下のストーリー内容を分析し、4コマ漫画を生成するための詳細な画像生成プロンプトを作成してください。\n\n【出力形式】\n各コマごとに詳細を明記してください。\n\n---\n【ストーリー内容】\n{{STORY}}{{HEIGHT_INSTRUCTION}}{{MARGIN_INSTRUCTION}}';
      }

      function getDefaultPromptStep2() {
        return '以下の指示に従って4コマ漫画を生成してください。\n\n{{GENERATED_PROMPT}}\n\n【画像全体の条件】\n・縦長1枚画像、アスペクト比 2:3\n・4K高解像度、カラー漫画{{HEIGHT_INSTRUCTION}}{{MARGIN_INSTRUCTION}}';
      }

      // 簡易モード用デフォルトプロンプト
      function getDefaultPrompt() {
        return '以下のストーリーを元に、縦型4コマ漫画を1枚の画像として生成してください。\n\n【ストーリー】\n{{STORY}}\n\n【画像仕様】\n・アスペクト比: 2:3（縦長）\n・4コマ漫画形式\n・カラー\n・高解像度（4K）\n・日本語の吹き出しテキスト{{HEIGHT_INSTRUCTION}}{{MARGIN_INSTRUCTION}}';
      }

      // 変数置換
      function replaceVars(template, vars) {
        var result = template;
        Object.keys(vars).forEach(function(key) {
          var regex = new RegExp('{{' + key + '}}', 'g');
          result = result.replace(regex, vars[key]);
        });
        return result;
      }

      // すべてのスタイル（既定 + カスタム）を取得
      function getAllStyles() {
        var customStylesFormatted = customStyles.map(function(cs) {
          return {
            id: 'custom_' + cs.id,
            name: cs.title,
            desc: cs.description || '',
            prompt: cs.prompt,
            custom: true,
            dbId: cs.id
          };
        });
        return STYLES.concat(customStylesFormatted);
      }

      function genPrompt() {
        var allStyles = getAllStyles();
        var st = allStyles.find(function(s) { return s.id === style; });
        var hasC = selChars[1] !== null;
        var spt = (style === 99 && styleRef) ? '添付された参照画像の絵柄・色使い・雰囲気に忠実に合わせてください。' : st.prompt;
        var spch = speech === 'formal' ? '敬語（です・ます調）を基本とし、同じ語尾が連続しないよう3種類以上使い分ける' : 'タメ口（カジュアル）を基本とし、親しみやすく、語尾を3種類以上使い分ける';
        var charRule = hasC ? '【キャラクター】2人構成。1枚目の画像が説明役、2枚目が相談役' : '【キャラクター】1人で読者に語りかける形式';
        var refTxt = (selChars[2] || selChars[3]) ? '【参考画像】追加の参考画像を漫画内で適切に使用してください。' : '';
        return (hasC ? '2人' : '1人') + 'のキャラクターが会話形式で語るマンガを生成してください。\n\n【絵のテイスト】\n' + spt + '\n\n【セリフスタイル】\n' + spch + '\n\n' + charRule + '\n\n' + refTxt + '\n\n【画像条件】\n・縦長1枚、アスペクト比 2:3\n・上から縦に4コマ構成\n・日本語は縦書き、右から左\n・カラーのみ\n\n---\n【記事内容】\n' + story;
      }

      // 共通変数を取得
      function getCommonVars() {
        var allStyles = getAllStyles();
        var st = allStyles.find(function(s) { return s.id === style; });
        var hasC = selChars[1] !== null;
        var spt = (style === 99 && styleRef) ? '添付された参照画像の絵柄・色使い・雰囲気に忠実に合わせてください。' : st.prompt;

        // キャラクター登場パネル数に応じた文字数ガイドライン
        var charPresentPanels = 4 - charAbsentCount;
        var charCountGuide = '';
        if (charAbsentCount === 0) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：4コマ全て\n・総セリフ文字数：90-120文字（理想：100-110文字）\n・1パネルあたり平均：22-30文字';
        } else if (charAbsentCount === 1) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：3コマ\n・総セリフ文字数：70-90文字（理想：75-85文字）\n・1パネルあたり平均：23-30文字';
        } else if (charAbsentCount === 2) {
          charCountGuide = '\n\n【文字数ガイドライン】\n・キャラクター登場パネル：2コマ\n・総セリフ文字数：50-70文字（理想：55-65文字）\n・1パネルあたり平均：25-35文字';
        }

        var spch = speech === 'formal'
          ? '【セリフ・語尾のバリエーション（重要）】\n・敬語（です・ます調）を基本とする\n・同じ語尾が連続しないようにする\n・4コマ内で最低3種類以上の語尾パターンを使い分ける\n・以下から自然に混ぜる：\n　問いかけ系（〜ですか？／〜でしょうか）\n　説明系（〜なんです／〜ております）\n　展開系（〜ですが、／実は〜／つまり〜）\n　強調系（〜なのです／〜と言えます）\n　締め系（〜しましょう／〜してみてください）' + charCountGuide
          : '【セリフ・語尾のバリエーション（重要）】\n・タメ口（だ・である調、カジュアル）を基本とする\n・同じ語尾が連続しないようにする\n・4コマ内で最低3種類以上の語尾パターンを使い分ける\n・以下から自然に混ぜる：\n　問いかけ系（〜だよね？／〜じゃない？／〜かな？）\n　説明系（〜なんだ／〜だよ／〜ってこと）\n　展開系（〜だけど、／実は〜／つまり〜）\n　強調系（〜なんだよ！／〜だって！）\n　締め系（〜しよう／〜してみて／〜だね）\n・親しみやすく、フレンドリーなトーンで' + charCountGuide;
        // キャラクター不在パネルのルールを作成
        var absentPanelRule = '';
        if (charAbsentCount === 0) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n⚠️ CRITICAL: DO NOT include any character-absent panels\n- ALL 4 panels MUST show characters\n- Every panel must have the character(s) visible and present\n- Do NOT create panels with only backgrounds, diagrams, infographics, or objects\n- Do NOT create concept visualization panels\n- Do NOT create landscape-only panels\n- Characters must appear in ALL FOUR panels without exception\n\n・キャラクター不在パネルは一切不要です\n・全4パネルに必ずキャラクターを登場させてください\n・背景のみ、図解のみ、物のみのパネルは作成禁止です\n・4コマ全てにキャラクターが登場している必要があります';
        } else if (charAbsentCount === 1) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n- MUST include exactly 1 character-absent panel (no more, no less)\n- Character-present panels: 3 panels\n- Character-absent panels: 1 panel\n- These panels tell the story visually without characters\n- NO speech bubbles in character-absent panels\n- Include title/heading (10 characters max) using story keywords\n- Reflect specific story content, NOT generic imagery\n\n・キャラクター登場パネル：3パネル\n・キャラクター不在パネル：1パネル（必須）\n・不在パネルでは図解・イメージ等でストーリーを視覚的に表現';
        } else if (charAbsentCount === 2) {
          absentPanelRule = '\n\n【キャラクター不在パネル】\n■ Character-Absent Panel Requirement:\n- MUST include exactly 2 character-absent panels (no more, no less)\n- Character-present panels: 2 panels\n- Character-absent panels: 2 panels\n- These panels tell the story visually without characters\n- NO speech bubbles in character-absent panels\n- Include title/heading (10 characters max) using story keywords\n- Reflect specific story content, NOT generic imagery\n\n・キャラクター登場パネル：2パネル\n・キャラクター不在パネル：2パネル（必須）\n・不在パネルでは図解・イメージ等でストーリーを視覚的に表現';
        }

        var charRule = hasC
          ? '【キャラクター人数ルール】\n・メインの登場人物は2人（デザインは参考画像に従う）\n・1枚目の画像のキャラクター：説明役\n・2枚目の画像のキャラクター：相談者役\n・相談者は絶対に説明をさせないでください\n・背景内の説明用イメージ人物（歴史的人物など）は別扱い\n\n【キャラクター登場ルール】\n・1コマに2人が登場しなくてもいい\n・1コマに説明者のみ、相談者のみでもいい' + absentPanelRule
          : '【キャラクター人数ルール】\n・登場人物は1人のみ（参考画像のキャラクター）\n・読者に語りかける形式で進行\n・独白・説明形式で内容を伝える' + absentPanelRule;
        var charCountText = hasC ? '2人のキャラクター' : '1人のキャラクター';

        // サブキャラクター指示
        var subCharInstructions = enableSubChars
          ? '\n\n⚠️ SUPPORTING CHARACTER GENERATION:\n\n■ Additional Characters in Story:\n- If the story mentions additional characters (customers, clerks, friends, family members, etc.), you MUST include them in the manga\n- Generate these supporting characters appropriately based on their role in the story\n- Examples: If story mentions "お客様" (customer), create a customer character and show them in conversation panels\n- Supporting characters should be designed to fit the story context (e.g., business customer in suit, cafe customer in casual clothes)\n- Maintain consistency of supporting characters across panels if they appear multiple times\n\n■ Supporting Character Design:\n- Create supporting characters that are DISTINCT from main characters (different appearance, clothing, hairstyle)\n- Supporting characters should look realistic for their role (customers, staff, strangers, etc.)\n- Use appropriate age, gender, and appearance based on story context\n- Supporting characters can have simpler designs than main characters but must be clearly visible\n\n■ Interaction Panels:\n- When main characters talk to supporting characters, show BOTH in the same panel\n- Use appropriate camera angles to show conversation (e.g., over-the-shoulder shots, two-shot compositions)\n- Speech bubbles should clearly indicate who is speaking\n- Supporting characters can have dialogue as specified in the story\n\n■ Examples:\n- Story: "（お客様）「無料だと思ってました」" → Show a customer character speaking this line, with main character also visible\n- Story: "店員に聞いてみた" → Include a staff/clerk character in that panel\n- Story: "友人と話していた" → Show the friend character alongside main character'
          : '';

        // キャラクター詳細情報を追加
        var charDetailText = '';
        var hasDetails = false;
        for (var i = 0; i < 4; i++) {
          if (selChars[i] && (charDetails[i].name || charDetails[i].features)) {
            hasDetails = true;
            var roleName = i === 0 ? '説明者 (Explainer)' : i === 1 ? '相談者 (Questioner)' : '参考' + (i + 1);
            charDetailText += '\n- ' + roleName + ':';
            if (charDetails[i].name) charDetailText += ' 名前: ' + charDetails[i].name;
            if (charDetails[i].features) charDetailText += ' | 特徴: ' + charDetails[i].features;
          }
        }
        if (hasDetails) {
          charDetailText = '\n\n■ Additional Character Details (参考情報):\nUse the following details to enhance character accuracy:' + charDetailText + '\n';
        }

        // キャラクター外見の詳細指示を作成
        var charDesc = hasC
          ? '⚠️ CRITICAL CHARACTER REFERENCE IMAGE REQUIREMENT - HIGHEST PRIORITY:\n\n■ Reference Image Order:\n- 1st image: Main Explainer character (説明者)\n- 2nd image: Questioner character (相談者)\n' + (selChars[2] ? '- 3rd image: Additional reference\n' : '') + (selChars[3] ? '- 4th image: Additional reference\n' : '') + charDetailText + '\n■ Character Reproduction Requirement:\nYou MUST reproduce the character design from reference images with 100% FIDELITY:\n- Facial features: Face shape, eye shape, eye color, nose, mouth - EXACTLY as shown\n- Hairstyle: Hair length, style, bangs, volume - EXACTLY as shown\n- Hair color: Exact color shade, highlights, gradients - EXACTLY as shown\n- Clothing: Style, color, patterns, accessories - EXACTLY as shown\n- Body proportions: Height, build, posture - EXACTLY as shown\n- Art style: Line weight, coloring technique, shading style - EXACTLY as shown\n\n■ Critical Instructions:\n- DO NOT modify or "improve" the character design\n- DO NOT change clothing between panels unless story requires it\n- DO NOT add or remove accessories\n- The reference images define the ABSOLUTE visual identity\n- Any deviation from reference images is considered a critical error\n- Maintain PERFECT consistency across all 4 panels\n\n■ Character Role Distribution:\n- Explainer (1st image character): ~70% of dialogue, provides main information\n- Questioner (2nd image character): ~30% of dialogue, asks questions and responds\n- Both characters must maintain their exact appearance from reference images throughout' + subCharInstructions
          : '⚠️ CRITICAL CHARACTER REFERENCE IMAGE REQUIREMENT - HIGHEST PRIORITY:\n\n■ Reference Image:\n- 1st image: The main character (登場人物)\n' + (selChars[2] ? '- 2nd image: Additional reference\n' : '') + (selChars[3] ? '- 3rd image: Additional reference\n' : '') + charDetailText + '\n■ Character Reproduction Requirement:\nYou MUST reproduce the character design from the reference image with 100% FIDELITY:\n- Facial features: Face shape, eye shape, eye color, nose, mouth - EXACTLY as shown\n- Hairstyle: Hair length, style, bangs, volume - EXACTLY as shown\n- Hair color: Exact color shade, highlights, gradients - EXACTLY as shown\n- Clothing: Style, color, patterns, accessories - EXACTLY as shown\n- Body proportions: Height, build, posture - EXACTLY as shown\n- Art style: Line weight, coloring technique, shading style - EXACTLY as shown\n\n■ Critical Instructions:\n- DO NOT modify or "improve" the character design\n- DO NOT change clothing between panels unless story requires it\n- DO NOT add or remove accessories\n- The reference image defines the ABSOLUTE visual identity\n- Any deviation from reference image is considered a critical error\n- Maintain PERFECT consistency across all 4 panels\n- This character speaks directly to the reader in explanatory style' + subCharInstructions;

        // カスタムレイアウト情報を抽出
        var panels = extractPanelInfo(story);
        var customLayout = panels.length > 0 ? generateLayoutInstructions(panels) : '';

        // 高さ情報を抽出（Webtoon Full Screen スタイルの場合のみ）
        var heightType = style === 11 ? extractHeightInfo(story) : null;
        var heightInstruction = style === 11 && heightType ? generateHeightInstruction(heightType) : '';

        // 余白情報を抽出（Webtoon Full Screen スタイルの場合のみ）
        var marginInfo = style === 11 ? extractMarginInfo(story) : null;
        var marginInstruction = style === 11 && marginInfo ? generateMarginInstruction(marginInfo) : '';

        return {
          STORY: story,
          STYLE_PROMPT: spt,
          SPEECH_STYLE: spch,
          CHARACTER_RULE: charRule,
          CHARACTER_COUNT: charCountText,
          CHARACTER_DESCRIPTION: charDesc,
          CUSTOM_LAYOUT: customLayout,
          PANEL_COUNT: panels.length > 0 ? panels.length.toString() : '4',
          HEIGHT_INSTRUCTION: heightInstruction,
          MARGIN_INSTRUCTION: marginInstruction
        };
      }

      // 単一ステップの実行
      function executeStep(stepIndex, stepOutputs) {
        var step = promptSteps[stepIndex];
        var commonVars = getCommonVars();

        // 変数マップを作成
        var vars = Object.assign({}, commonVars);

        // 前ステップの出力を追加
        if (stepIndex > 0) {
          vars.PREV_OUTPUT = stepOutputs[stepIndex - 1] || '';
        }

        // 各ステップの出力を追加
        stepOutputs.forEach(function(output, idx) {
          vars['STEP' + (idx + 1) + '_OUTPUT'] = output;
        });

        // 最終ステップの出力を追加
        if (stepOutputs.length > 0) {
          vars.GENERATED_PROMPT = stepOutputs[stepOutputs.length - 1];
        }

        var promptText = replaceVars(step.template, vars);
        console.log('===== Step ' + (stepIndex + 1) + ': ' + step.name + ' =====');
        console.log(promptText);

        if (step.type === 'image') {
          // 画像生成
          return executeImageGeneration(promptText).then(function(img) {
            // ウェブトゥーンスタイル(id:11)の場合は横幅1080pxに固定リサイズ
            if (style === 11 && img) {
              return new Promise(function(resolve, reject) {
                var image = new Image();
                image.onload = function() {
                  var canvas = document.createElement('canvas');
                  var targetWidth = 1080;
                  var aspectRatio = image.height / image.width;
                  var targetHeight = Math.round(targetWidth * aspectRatio);

                  canvas.width = targetWidth;
                  canvas.height = targetHeight;
                  var ctx = canvas.getContext('2d');

                  // 画像を1080px幅にリサイズ
                  ctx.drawImage(image, 0, 0, targetWidth, targetHeight);
                  resolve(canvas.toDataURL('image/jpeg', 0.95));
                };
                image.onerror = function() { reject(new Error('画像のリサイズに失敗しました')); };
                image.src = img;
              });
            }
            return img;
          });
        } else {
          // テキスト生成
          return executeTextGeneration(promptText);
        }
      }

      // テキスト生成
      function executeTextGeneration(promptText) {
        var body = {
          contents: [{ parts: [{ text: promptText }] }]
        };

        return fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=' + apiKey, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(function(res) {
          if (!res.ok) return res.json().then(function(err) { throw new Error(err.error ? err.error.message : 'Text API error'); });
          return res.json();
        })
        .then(function(data) {
          var txt = '';
          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            txt = data.candidates[0].content.parts[0].text || '';
          }
          console.log('生成結果:', txt.substring(0, 200) + '...');
          return txt;
        });
      }

      // WebP画像をPNG形式に変換（Gemini API互換性のため）
      async function convertWebPToPNG(dataUrl) {
        return new Promise(function(resolve, reject) {
          var img = new Image();
          img.onload = function() {
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL('image/png'));
          };
          img.onerror = function() { reject(new Error('画像の変換に失敗しました')); };
          img.src = dataUrl;
        });
      }

      // 画像生成
      async function executeImageGeneration(promptText) {
        var m = MODELS.find(function(x) { return x.id === model; });
        var parts = [];

        // キャラクター画像を処理
        for (var i = 0; i < selChars.length; i++) {
          var c = selChars[i];
          if (c && c.img) {
            var imageData = c.img;

            // WebP形式の場合はPNGに変換（Gemini API互換性のため）
            if (c.img.startsWith('data:image/webp')) {
              imageData = await convertWebPToPNG(c.img);
            }

            // PNGとして送信
            var b = imageData.split(',')[1];
            parts.push({ inlineData: { mimeType: 'image/png', data: b } });
          }
        }

        if (style === 99 && styleRef && styleRef.img) {
          var imageData = styleRef.img;

          // WebP形式の場合はPNGに変換
          if (styleRef.img.startsWith('data:image/webp')) {
            imageData = await convertWebPToPNG(styleRef.img);
          }

          var b = imageData.split(',')[1];
          parts.push({ inlineData: { mimeType: 'image/png', data: b } });
        }

        // モデルIDに応じた解像度と日本語テキスト品質の指定をプロンプトに追加
        var resolutionText;
        if (model === '4k') {
          resolutionText = '\n\n🚨 ABSOLUTE CRITICAL REQUIREMENTS - HIGHEST PRIORITY:\n\n【IMAGE RESOLUTION】\n- Output resolution: 2048×3072 pixels (4K ULTRA HIGH quality)\n- Aspect ratio: 2:3 (vertical)\n- NO compression, NO quality degradation\n- Maximum detail preservation\n\n【日本語テキスト品質 - 最優先事項】\n⚠️ CRITICAL: Japanese text rendering is THE MOST IMPORTANT requirement:\n- Use HIGHEST quality Japanese font rendering\n- Each character MUST be rendered at MAXIMUM resolution\n- Character strokes MUST be crisp, sharp, and perfectly clear\n- NO blurry characters, NO pixelation, NO artifacts\n- Font size MUST be large enough for perfect legibility (minimum 24pt equivalent)\n- Use professional manga font style with clear, bold strokes\n- Ensure maximum contrast between text and background\n- Apply anti-aliasing for smooth character edges\n- VERIFY every single character is perfectly readable before finalizing\n- Text quality is MORE IMPORTANT than any other visual element\n\n⚠️ If you must choose between artistic style and text clarity, ALWAYS prioritize text clarity.';
        } else if (model === '2k') {
          resolutionText = '\n\n🚨 CRITICAL REQUIREMENTS:\n\n【IMAGE RESOLUTION】\n- Output resolution: 1440×2160 pixels (2K HIGH quality)\n- Aspect ratio: 2:3 (vertical)\n\n【日本語テキスト品質】\n⚠️ Japanese text rendering is CRITICAL:\n- Use high quality Japanese font rendering\n- Each character must be sharp and clear\n- NO blurry characters, NO pixelation\n- Font size must be large enough for easy reading\n- Clear, bold strokes for maximum legibility\n- High contrast between text and background';
        } else {
          resolutionText = '\n\n【IMAGE RESOLUTION】\n- Output resolution: 1024×1536 pixels (standard quality)\n- Aspect ratio: 2:3 (vertical)\n\n【日本語テキスト品質】\n- Clear Japanese font rendering\n- Readable characters with good contrast';
        }

        var enhancedPromptText = promptText + resolutionText;

        var body = {
          system_instruction: { parts: [{ text: enhancedPromptText }] },
          contents: [{ parts: parts }],
          generationConfig: {
            responseModalities: ['IMAGE'],
            temperature: 0.3,      // テキスト品質重視：さらに低く設定
            topP: 0.8,            // より一貫性のある出力
            topK: 30,             // 候補をさらに絞る
            candidateCount: 1     // 1つの結果のみ生成
          }
        };

        console.log('画像生成リクエスト - モデル:', m.model, '品質:', model === '4k' ? '4K (2048×3072)' : model === '2k' ? '2K (1440×2160)' : '標準 (1024×1536)');

        return fetch('https://generativelanguage.googleapis.com/v1beta/models/' + m.model + ':generateContent?key=' + apiKey, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        })
        .then(function(res) {
          if (!res.ok) return res.json().then(function(err) { throw new Error(err.error ? err.error.message : 'Image API error'); });
          return res.json();
        })
        .then(function(data) {
          var img = null;
          if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
            data.candidates[0].content.parts.forEach(function(p) {
              if (p.inlineData) img = 'data:' + p.inlineData.mimeType + ';base64,' + p.inlineData.data;
            });
          }
          return img;
        });
      }

      // メイン生成関数（複数ステップ対応）
      function generate() {
        // セキュリティ：レート制限チェック
        try {
          checkRateLimit();
        } catch (err) {
          setError(err.message);
          return;
        }

        if (!apiKey) { setError('APIキーを設定してください'); return; }
        if (!selChars[0]) { setError('説明者を選択してください'); return; }
        if (!story || story.length < 20) { setError('20文字以上入力してください'); return; }
        if (promptSteps.length === 0) { setError('プロンプトが読み込まれていません'); return; }

        setIsGen(true);
        setGenStartTime(Date.now());
        setError('');
        setGenImages([]);
        setCurImg(0);
        cancelRef.current = false;
        setCurrentStep(0);

        var m = MODELS.find(function(x) { return x.id === model; });
        var currentImages = new Array(genCount);  // 固定サイズ配列で並列実行に対応

        function generateOne(imgIndex) {
          if (cancelRef.current) {
            return Promise.reject(new Error('キャンセルされました'));
          }
          setGenIdx(imgIndex);

          var stepOutputs = [];
          var finalOutput = null;  // 最終的な画像出力を保持

          function executeSteps(stepIndex) {
            if (stepIndex >= promptSteps.length || cancelRef.current) {
              if (cancelRef.current) throw new Error('キャンセルされました');
              return Promise.resolve();
            }

            setCurrentStep(stepIndex + 1);

            return executeStep(stepIndex, stepOutputs)
              .then(function(output) {
                if (promptSteps[stepIndex].type === 'image') {
                  // 画像生成の場合、結果を保存
                  if (!output) throw new Error('画像の生成に失敗しました');

                  finalOutput = output;  // 最終出力を保存
                  currentImages[imgIndex] = output;
                  var completedImages = currentImages.filter(function(img) { return img !== undefined; });
                  setGenImages(completedImages);
                  setCurImg(completedImages.length - 1);

                  // 高品質画像をSupabase Storageにアップロード
                  (async function() {
                    try {
                      var st = STYLES.find(function(s) { return s.id === style; });

                      // 画像をWebP形式に変換
                      var webpDataUrl = await new Promise(function(resolve, reject) {
                        var img = new Image();
                        img.onload = function() {
                          var canvas = document.createElement('canvas');
                          canvas.width = img.width;
                          canvas.height = img.height;
                          var ctx = canvas.getContext('2d');
                          ctx.drawImage(img, 0, 0);
                          // WebP形式で出力（品質90%）
                          resolve(canvas.toDataURL('image/webp', 0.90));
                        };
                        img.onerror = function() { reject(new Error('画像の変換に失敗しました')); };
                        img.src = output;
                      });

                      // Base64をBlobに変換
                      var base64Data = webpDataUrl.split(',')[1];
                      var byteCharacters = atob(base64Data);
                      var byteNumbers = new Array(byteCharacters.length);
                      for (var i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                      }
                      var byteArray = new Uint8Array(byteNumbers);
                      var blob = new Blob([byteArray], { type: 'image/webp' });

                      // ファイル名生成（ユーザーID/タイムスタンプ.webp）
                      var fileName = props.user.id + '/' + Date.now() + '_' + imgIndex + '.webp';

                      // Supabase Storageにアップロード
                      var uploadResult = await supabase.storage
                        .from('manga-images')
                        .upload(fileName, blob, {
                          contentType: 'image/webp',
                          cacheControl: '3600',
                          upsert: false
                        });

                      if (uploadResult.error) {
                        console.error('画像アップロードエラー:', uploadResult.error);
                        alert('画像のアップロードに失敗しました: ' + uploadResult.error.message);
                        return;
                      }

                      // 公開URLを取得
                      var publicUrlResult = supabase.storage
                        .from('manga-images')
                        .getPublicUrl(fileName);

                      var publicUrl = publicUrlResult.data.publicUrl;

                      // データベースに保存（URLのみ）
                      var result = await supabase
                        .from('mangas')
                        .insert([{
                          user_id: props.user.id,
                          image_url: publicUrl,
                          story: story,
                          style_id: style,
                          style_name: st ? st.name : '',
                          settings: {
                            speech: speech,
                            model: model,
                            modelName: m.name
                          }
                        }])
                        .select();

                      if (result.error) {
                        console.error('履歴保存エラー:', result.error);
                        alert('履歴の保存に失敗しました: ' + result.error.message);
                      } else {
                        // 履歴を再読み込み
                        var histResult = await supabase
                          .from('mangas')
                          .select('*')
                          .eq('user_id', props.user.id)
                          .order('created_at', { ascending: false })
                          .limit(10);

                        if (!histResult.error) {
                          var histArr = histResult.data.map(function(item) {
                            return {
                              id: item.id,
                              img: item.image_url,
                              settings: {
                                style: item.style_id,
                                styleName: item.style_name,
                                speech: item.settings?.speech,
                                model: item.settings?.model,
                                modelName: item.settings?.modelName,
                                story: (item.story || '').substring(0, 80) + '...'
                              },
                              ts: item.created_at
                            };
                          });
                          setHistory(histArr);

                          // 古い画像を自動削除（最新10件 + お気に入り以外）
                          cleanupOldImages();
                        }
                      }
                    } catch(e) {
                      console.error('保存エラー:', e);
                      alert('画像の保存に失敗しました');
                    }
                  })();

                  // 使用量記録
                  try {
                    var now = new Date();
                    var mk = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
                    var savedUsage = localStorage.getItem('manga_usage');
                    var usageData = savedUsage ? JSON.parse(savedUsage) : { monthly: [], total: { count: 0, cost: 0 } };
                    if (!usageData.monthly) usageData.monthly = [];
                    var md = usageData.monthly.find(function(x) { return x.month === mk; });
                    if (!md) { md = { month: mk, items: [] }; usageData.monthly.push(md); }
                    md.items.push({ date: now.toISOString(), model: model, price: m.price });
                    usageData.total.count = (usageData.total.count || 0) + 1;
                    usageData.total.cost = (usageData.total.cost || 0) + m.price;
                    localStorage.setItem('manga_usage', JSON.stringify(usageData));
                    setUsage(usageData);
                  } catch(e) {
                    console.error('使用量記録エラー:', e);
                  }
                } else {
                  // テキスト生成の場合、次のステップの入力として保存
                  stepOutputs.push(output);
                }

                return executeSteps(stepIndex + 1);
              });
          }

          return executeSteps(0)
            .then(function() {
              setCurrentStep(0);
              return finalOutput;  // 完了した画像を返す
            })
            .catch(function(e) {
              console.error('画像' + (imgIndex + 1) + '生成エラー:', e);
              throw e;
            });
        }

        // 並列生成: 全ての画像を同時に生成
        var promises = [];
        for (var i = 0; i < genCount; i++) {
          promises.push(generateOne(i));
        }

        Promise.all(promises)
          .then(function() {
            setIsGen(false);
            setGenStartTime(null);
            setCurrentStep(0);
            console.log('全' + genCount + '枚の生成が完了しました');
          })
          .catch(function(e) {
            setError('エラー: ' + e.message);
            setIsGen(false);
            setGenStartTime(null);
            setCurrentStep(0);
          });
      }

      function dl(img, i) {
        // URLからダウンロード（Supabase Storage対応）
        if (img.startsWith('http')) {
          fetch(img)
            .then(function(res) { return res.blob(); })
            .then(function(blob) {
              var url = URL.createObjectURL(blob);
              var a = document.createElement('a');
              a.href = url;
              a.download = 'manga_' + Date.now() + '_' + (i + 1) + '.png';
              a.click();
              URL.revokeObjectURL(url);
            })
            .catch(function(e) {
              console.error('ダウンロードエラー:', e);
              alert('ダウンロードに失敗しました');
            });
        } else {
          // Base64の場合（従来の方法）
          var a = document.createElement('a');
          a.href = img;
          a.download = 'manga_' + Date.now() + '_' + (i + 1) + '.png';
          a.click();
        }
      }

      // キャラクターシート生成関連
      function handleCharSheetImageUpload(e) {
        var file = e.target.files[0];
        if (!file) return;

        if (file.size > 10 * 1024 * 1024) {
          setError('ファイルサイズは10MB以下にしてください');
          return;
        }

        var reader = new FileReader();
        reader.onload = function(event) {
          setCharSheetBaseImg(event.target.result);
        };
        reader.readAsDataURL(file);
      }

      async function generateCharacterSheets() {
        if (!charSheetName) {
          setError('キャラクター名を入力してください');
          return;
        }
        if (!charSheetBaseImg && !charSheetDesc) {
          setError('ベース画像またはキャラクター説明のどちらかを入力してください');
          return;
        }
        if (!apiKey) {
          setError('APIキーを設定してください');
          return;
        }

        setCharSheetGenStep(1);
        setError('');
        setGeneratedCharSheets([]);
        setCurCharSheet(0);
        setCharSheetSaved([]);

        try {
          var promptTemplate = await fetch('./prompts/キャラクターシート_image.txt')
            .then(function(res) { return res.text(); })
            .catch(function() {
              return '⚠️ CRITICAL: Create a professional character sheet with EXACTLY 5 variations in a single image\n\n【CHARACTER DESCRIPTION】\n{{CHARACTER_DESCRIPTION}}\n\n【ART STYLE】\n{{STYLE_PROMPT}}\n\nLayout: Top row: Neutral (left), Smile (right) | Bottom row: Front (left), Side (center), Back (right)';
            });

          var allStyles = getAllStyles();
          var selectedStyle = allStyles.find(function(s) { return s.id === style; });
          var description = charSheetDesc || '添付されたベース画像のキャラクターの特徴を分析し、その特徴を忠実に再現してください';
          var prompt = promptTemplate
            .replace(/\{\{CHARACTER_DESCRIPTION\}\}/g, description)
            .replace(/\{\{STYLE_PROMPT\}\}/g, selectedStyle.prompt);

          var selectedModel = MODELS.find(function(m) { return m.id === model; });
          var modelName = selectedModel.model;
          var apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent?key=' + apiKey;

          var currentSheets = new Array(charSheetCount);

          function generateOne(sheetIndex) {
            return (async function() {
              var parts = [{ text: prompt }];

              try {
                var templateResponse = await fetch('./キャラクターシート_テンプレート.jpeg');
                var templateBlob = await templateResponse.blob();
                var templateBase64 = await new Promise(function(resolve) {
                  var reader = new FileReader();
                  reader.onloadend = function() { resolve(reader.result); };
                  reader.readAsDataURL(templateBlob);
                });
                parts.push({
                  inlineData: {
                    mimeType: 'image/jpeg',
                    data: templateBase64.split(',')[1]
                  }
                });
              } catch (e) {
                console.warn('テンプレート画像の読み込みに失敗:', e.message);
              }

              if (charSheetBaseImg) {
                parts.push({
                  inlineData: {
                    mimeType: 'image/png',
                    data: charSheetBaseImg.split(',')[1]
                  }
                });
              }

              var response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{ parts: parts }],
                  generationConfig: {
                    responseModalities: ['IMAGE'],
                    temperature: 0.3,
                    topP: 0.8,
                    topK: 30,
                    candidateCount: 1
                  }
                })
              });

              if (!response.ok) {
                var errorData = await response.json();
                throw new Error(errorData.error?.message || 'API呼び出しに失敗しました');
              }

              var data = await response.json();
              var imageData = data.candidates?.[0]?.content?.parts?.find(function(p) { return p.inlineData; })?.inlineData?.data;

              if (!imageData) throw new Error('画像生成に失敗しました');

              var generatedImage = 'data:image/jpeg;base64,' + imageData;

              // 画像を1080x1520にリサイズ
              var resizedImage = await new Promise(function(resolve, reject) {
                var img = new Image();
                img.onload = function() {
                  var canvas = document.createElement('canvas');
                  canvas.width = 1080;
                  canvas.height = 1520;
                  var ctx = canvas.getContext('2d');

                  // 背景を白で塗りつぶし
                  ctx.fillStyle = '#FFFFFF';
                  ctx.fillRect(0, 0, 1080, 1520);

                  // アスペクト比を保持してリサイズ
                  var scale = Math.min(1080 / img.width, 1520 / img.height);
                  var scaledWidth = img.width * scale;
                  var scaledHeight = img.height * scale;
                  var x = (1080 - scaledWidth) / 2;
                  var y = (1520 - scaledHeight) / 2;

                  ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                  resolve(canvas.toDataURL('image/jpeg', 0.95));
                };
                img.onerror = function() { reject(new Error('画像のリサイズに失敗しました')); };
                img.src = generatedImage;
              });

              currentSheets[sheetIndex] = resizedImage;

              var completedSheets = currentSheets.filter(function(sheet) { return sheet !== undefined; });
              setGeneratedCharSheets(completedSheets);
              setCurCharSheet(completedSheets.length - 1);

              return generatedImage;
            })();
          }

          var promises = [];
          for (var i = 0; i < charSheetCount; i++) {
            promises.push(generateOne(i));
          }

          await Promise.all(promises);

        } catch (err) {
          console.error('キャラクターシート生成エラー:', err);
          setError('生成エラー: ' + err.message);
        } finally {
          setCharSheetGenStep(0);
        }
      }

      async function saveCharSheetToLibrary(sheetImage, index) {
        // 保存済みとして即座にマーク（ボタンをすぐ切り替える）
        if (charSheetSaved.indexOf(index) === -1) {
          setCharSheetSaved(charSheetSaved.concat([index]));
        }

        try {
          // キャラクターシートはPNG形式で保存（参照画像として使用するため、Gemini APIとの互換性を保つ）
          // Base64をBlobに変換
          var base64Data = sheetImage.split(',')[1];
          var byteCharacters = atob(base64Data);
          var byteNumbers = new Array(byteCharacters.length);
          for (var i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          var byteArray = new Uint8Array(byteNumbers);
          var blob = new Blob([byteArray], { type: 'image/png' });

          // Supabase Storageにアップロード
          var fileName = user.id + '/charsheet_' + Date.now() + '_' + index + '.png';
          var uploadResult = await supabase.storage
            .from('manga-images')
            .upload(fileName, blob, {
              contentType: 'image/png',
              cacheControl: '3600',
              upsert: false
            });

          if (uploadResult.error) {
            console.error('画像アップロードエラー:', uploadResult.error);
            setError('画像のアップロードに失敗しました: ' + uploadResult.error.message);
            return;
          }

          // 公開URLを取得
          var publicUrlResult = supabase.storage
            .from('manga-images')
            .getPublicUrl(fileName);
          var publicUrl = publicUrlResult.data.publicUrl;

          // データベースに保存
          var allStyles = getAllStyles();
          var selectedStyle = allStyles.find(function(s) { return s.id === style; });

          var insertResult = await supabase
            .from('character_sheets')
            .insert([{
              user_id: user.id,
              name: charSheetName + (charSheetCount > 1 ? ' (' + (index + 1) + ')' : ''),
              description: charSheetDesc || '',
              style_id: style,
              style_name: selectedStyle ? selectedStyle.title : '',
              sheet_image_url: publicUrl,
              base_image_url: charSheetBaseImg
            }])
            .select();

          if (insertResult.error) {
            console.error('データベース保存エラー:', insertResult.error);
            setError('保存に失敗しました: ' + insertResult.error.message);
            return;
          }

          // character_sheetsを再読み込み
          loadCharacterSheets();

        } catch (err) {
          console.error('保存エラー:', err);
          setError('保存に失敗しました: ' + err.message);
        }
      }

      async function loadCharacterSheets() {
        if (!user) return;

        try {
          var result = await supabase
            .from('character_sheets')
            .select('*')
            .eq('user_id', user.id)
            .order('created_at', { ascending: false });

          if (result.error) {
            console.error('キャラクターシート読み込みエラー:', result.error);
            return;
          }

          setCharacterSheets(result.data || []);

          // Supabaseのキャラクターシートをchars形式に変換
          var supabaseChars = (result.data || []).map(function(sheet) {
            return {
              id: 'supabase_' + sheet.id,
              name: sheet.name,
              img: sheet.sheet_image_url,
              desc: sheet.description || '',
              source: 'supabase'
            };
          });

          // localStorageのキャラクターを取得
          var localChars = [];
          try {
            var saved = localStorage.getItem('manga_chars');
            if (saved) {
              localChars = JSON.parse(saved).filter(function(c) {
                return !c.source || c.source !== 'supabase';
              });
            }
          } catch(e) {
            console.error('localStorage読み込みエラー:', e);
          }

          // 統合して表示（Supabaseのシートを先頭に）
          setChars(supabaseChars.concat(localChars));

        } catch (err) {
          console.error('読み込みエラー:', err);
        }
      }

      function downloadCharSheet(sheetImage, index) {
        var a = document.createElement('a');
        a.href = sheetImage;
        a.download = 'character_sheet_' + charSheetName + '_' + (index + 1) + '_' + Date.now() + '.png';
        a.click();
      }

      function toggleFavHist(id) {
        var nf = favHist.indexOf(id) >= 0 ? favHist.filter(function(x) { return x !== id; }) : favHist.concat([id]);
        setFavHist(nf);
        localStorage.setItem('manga_fav_hist', JSON.stringify(nf));
      }

      // 古い画像の自動削除（最新10件 + お気に入り以外を削除）
      async function cleanupOldImages() {
        try {
          console.log('古い画像のクリーンアップを開始...');

          // お気に入り情報をlocalStorageから取得（state より確実）
          var favHistIds = [];
          try {
            var fh = localStorage.getItem('manga_fav_hist');
            if (fh) favHistIds = JSON.parse(fh);
          } catch (e) {
            console.warn('お気に入り情報の読み込みエラー:', e);
          }

          // 1. ユーザーの全ての履歴を取得
          var allHistResult = await supabase
            .from('mangas')
            .select('*')
            .eq('user_id', user.id)
            .order('created_at', { ascending: false });

          if (allHistResult.error) throw allHistResult.error;

          var allHistory = allHistResult.data;
          console.log('総履歴数:', allHistory.length + '件');

          // 2. 削除対象を特定（最新10件より古い + お気に入りでない）
          var toDelete = allHistory.slice(10).filter(function(item) {
            return favHistIds.indexOf(item.id) === -1; // お気に入りでないもの
          });

          if (toDelete.length === 0) {
            console.log('削除対象の画像はありません');
            return;
          }

          console.log('削除対象:', toDelete.length + '件');

          // 3. 各画像をStorageとDBから削除
          for (var i = 0; i < toDelete.length; i++) {
            var item = toDelete[i];

            // Storage から削除（URLからファイルパスを抽出）
            if (item.image_url) {
              try {
                var url = item.image_url;
                // URLから "manga-images/" 以降のパスを抽出（クエリパラメータを除外）
                var match = url.match(/manga-images\/([^?]+)/);
                if (match) {
                  var filePath = match[1];
                  var deleteResult = await supabase.storage
                    .from('manga-images')
                    .remove([filePath]);

                  if (deleteResult.error) {
                    console.warn('Storage削除エラー (続行):', deleteResult.error);
                  } else {
                    console.log('Storage削除成功:', filePath);
                  }
                }
              } catch (err) {
                console.warn('Storage削除エラー (続行):', err);
              }
            }

            // Database から削除
            try {
              var dbDeleteResult = await supabase
                .from('mangas')
                .delete()
                .eq('id', item.id);

              if (dbDeleteResult.error) {
                console.warn('DB削除エラー (続行):', dbDeleteResult.error);
              } else {
                console.log('DB削除成功:', item.id);
              }
            } catch (err) {
              console.warn('DB削除エラー (続行):', err);
            }
          }

          console.log('古い画像のクリーンアップが完了しました (' + toDelete.length + '件削除)');

        } catch (err) {
          console.error('クリーンアップエラー:', err);
          // ユーザーには通知しない（エラーがあっても生成は継続）
        }
      }

      function saveProj() {
        if (!newProjName) return;
        var p = { id: 'p_' + Date.now(), name: newProjName, settings: { selChars: selChars, style: style, styleRef: styleRef, speech: speech, model: model, charAbsentCount: charAbsentCount, enableSubChars: enableSubChars }, ts: new Date().toISOString() };
        var np = projects.concat([p]);
        setProjects(np);
        localStorage.setItem('manga_projects', JSON.stringify(np));
        setCurProj(p);
        setShowAddProj(false);
        setNewProjName('');
      }

      function loadProj(p) {
        var s = p.settings;
        if (s.selChars) setSelChars(s.selChars);
        if (s.style) setStyle(s.style);
        if (s.styleRef) setStyleRef(s.styleRef);
        if (s.speech) setSpeech(s.speech);
        if (s.model) setModel(s.model);
        if (s.charAbsentCount !== undefined) setCharAbsentCount(s.charAbsentCount);
        if (s.enableSubChars !== undefined) setEnableSubChars(s.enableSubChars);
        setCurProj(p);
      }

      function delProj(id) {
        if (!confirm('削除しますか？')) return;
        var np = projects.filter(function(p) { return p.id !== id; });
        setProjects(np);
        localStorage.setItem('manga_projects', JSON.stringify(np));
        if (curProj && curProj.id === id) setCurProj(null);
      }

      function clearProj() {
        setCurProj(null);
      }

      function exportProj(p) {
        var json = JSON.stringify(p, null, 2);
        var blob = new Blob([json], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'project_' + p.name + '_' + Date.now() + '.json';
        a.click();
        URL.revokeObjectURL(url);
      }

      function importProj() {
        var input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function(e) {
          var file = e.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function(ev) {
            try {
              var imported = JSON.parse(ev.target.result);
              imported.id = 'p_' + Date.now();
              imported.name = imported.name + ' (インポート)';
              var np = projects.concat([imported]);
              setProjects(np);
              localStorage.setItem('manga_projects', JSON.stringify(np));
              alert('プロジェクトをインポートしました');
            } catch(e) {
              alert('ファイルの読み込みに失敗しました');
            }
          };
          reader.readAsText(file);
        };
        input.click();
      }

      function compTut() { localStorage.setItem('manga_tut_seen', '1'); setShowTut(false); setTutStep(0); }
      function togAccord(k) { setAccord(accord.indexOf(k) >= 0 ? accord.filter(function(x) { return x !== k; }) : accord.concat([k])); }

      // カスタムスタイルをSTYLES形式に変換
      var customStylesFormatted = customStyles.map(function(cs) {
        return {
          id: 'custom_' + cs.id,
          name: cs.title,
          desc: cs.description || '',
          prompt: cs.prompt,
          custom: true,
          dbId: cs.id
        };
      });

      // すべてのスタイル（既定 + カスタム）
      var allStyles = STYLES.concat(customStylesFormatted);

      var sortedStyles = allStyles.slice();

      // styleOrderが存在する場合はそれに従ってソート
      if (styleOrder.length > 0) {
        sortedStyles.sort(function(a, b) {
          var aIdx = styleOrder.indexOf(a.id);
          var bIdx = styleOrder.indexOf(b.id);
          // 両方がstyleOrderに存在する場合はその順序
          if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
          // aのみstyleOrderに存在する場合はaを先に
          if (aIdx !== -1) return -1;
          // bのみstyleOrderに存在する場合はbを先に
          if (bIdx !== -1) return 1;
          // どちらもstyleOrderに存在しない場合はIDで比較
          return 0;
        });
      }

      function calcUsage() {
        var now = new Date();
        var mk = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
        var md = usage.monthly ? usage.monthly.find(function(m) { return m.month === mk; }) : null;
        if (!md || !md.items) return { count: 0, cost: 0, by: {} };
        var by = {}, cost = 0;
        md.items.forEach(function(item) {
          if (!by[item.model]) by[item.model] = { count: 0, cost: 0 };
          by[item.model].count++;
          by[item.model].cost += item.price;
          cost += item.price;
        });
        return { count: md.items.length, cost: cost, by: by };
      }
      var mu = calcUsage();

      function est() {
        var m = MODELS.find(function(x) { return x.id === model; });
        return { usd: (m.price * genCount).toFixed(2), jpy: Math.round(m.jpy * genCount) };
      }

      return html`
        <div class="flex min-h-screen">
          ${sidebar && html`<div class="md:hidden fixed inset-0 bg-black/50 z-40" onClick=${function() { setSidebar(false); }}></div>`}
          
          <div class="sidebar w-96 bg-white border-r p-5 overflow-y-auto flex-shrink-0 ${sidebar ? 'open' : ''}">
            <div class="flex items-center justify-between mb-6">
              <h1 class="text-xl font-bold text-gray-800">漫画クリエイター</h1>
              <button class="md:hidden text-gray-500 text-2xl" onClick=${function() { setSidebar(false); }}>×</button>
            </div>

            <div class="mb-4 glass-card animate-fadeIn">
              ${apiSaved && !showApiEdit ? html`
                <div class="flex items-center justify-between">
                  <div class="flex items-center gap-2">
                    <span class="text-sm font-semibold" style="color: var(--color-success);">API: 設定済み</span>
                    <span style="color: var(--color-success);">✓</span>
                  </div>
                  <button onClick=${function() { setShowApiEdit(true); }} class="text-xs text-blue-600 hover:text-blue-700 underline">
                    編集
                  </button>
                </div>
              ` : html`
                <div class="flex items-center mb-3">
                  <span class="text-sm font-semibold" style="color: var(--color-text-primary);">API設定</span>
                  <${HelpIcon} text=${HELP.api} />
                </div>
                <div class="relative mb-3">
                  <input type=${showApi ? 'text' : 'password'} value=${apiKey} onInput=${function(e) { setApiKey(e.target.value); setApiSaved(false); }} placeholder="APIキーを入力" class="input-field w-full pr-16 text-sm" />
                  <button onClick=${function() { setShowApi(!showApi); }} class="absolute right-3 top-1/2 -translate-y-1/2 text-xs" style="color: var(--color-text-secondary);">${showApi ? '隠す' : '表示'}</button>
                </div>
                <button onClick=${saveApi} class="btn-primary w-full text-sm">保存</button>
                <div class="mt-2 text-xs flex items-center gap-1" style="color: ${apiSaved ? 'var(--color-success)' : 'var(--color-warning)'};">
                  <span>${apiSaved ? '✓' : '⚠'}</span>
                  <span>${apiSaved ? '保存済み' : '未保存'}</span>
                </div>
                ${apiSaved && showApiEdit && html`
                  <button onClick=${function() { setShowApiEdit(false); }} class="text-xs text-gray-500 hover:text-gray-700 mt-2 w-full">
                    編集を閉じる
                  </button>
                `}
              `}
            </div>

            <div class="mb-4">
              <div class="flex items-center justify-between mb-2">
                <div class="flex items-center">
                  <span class="text-sm font-semibold text-gray-700">プロジェクト</span>
                  <${HelpIcon} text=${HELP.project} />
                </div>
                <div class="flex gap-1">
                  ${curProj && html`<button onClick=${clearProj} class="text-xs text-gray-500 hover:text-gray-700" title="選択解除">解除</button>`}
                  <button onClick=${importProj} class="text-xs text-blue-500 hover:text-blue-700" title="インポート">↓</button>
                </div>
              </div>
              <div class="flex gap-2 overflow-x-auto pb-2 scrollbar-thin">
                ${projects.map(function(p) {
                  return html`
                    <div key=${p.id} class="relative flex-shrink-0 group">
                      <button
                        onClick=${function() { loadProj(p); }}
                        class="px-3 py-2 text-xs rounded-lg border ${curProj && curProj.id === p.id ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                      >
                        ${p.name}
                      </button>
                      <div class="absolute -top-1 -right-1 hidden group-hover:flex gap-1">
                        <button
                          onClick=${function(e) { e.stopPropagation(); exportProj(p); }}
                          class="w-4 h-4 bg-green-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-green-600"
                          title="エクスポート"
                        >↑</button>
                        <button
                          onClick=${function(e) { e.stopPropagation(); delProj(p.id); }}
                          class="w-4 h-4 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600"
                          title="削除"
                        >×</button>
                      </div>
                    </div>
                  `;
                })}
                <button onClick=${function() { setShowAddProj(true); }} class="flex-shrink-0 px-3 py-2 text-xs rounded-lg border border-dashed border-gray-300 text-gray-400 hover:bg-gray-50">+ 新規</button>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('lib'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center">
                  <span class="text-sm font-semibold text-gray-700">キャラクターライブラリ</span>
                  <${HelpIcon} text=${HELP.library} />
                </div>
                <span class="text-gray-400">${accord.indexOf('lib') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('lib') >= 0 ? 'open' : ''}">
                <div class="flex gap-2 overflow-x-auto py-2 scrollbar-thin">
                  ${chars.map(function(c) {
                    return html`
                      <div key=${c.id} class="relative flex-shrink-0 group">
                        <div class="cursor-pointer" onClick=${function() {
                          var idx = selChars.findIndex(function(x) { return x === null; });
                          if (idx >= 0) {
                            var nc = selChars.slice();
                            nc[idx] = c;
                            setSelChars(nc);
                          }
                        }}>
                          <img src=${c.img} class="w-14 h-14 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400" />
                          <div class="text-xs text-center mt-1 truncate" style="width: 56px;">${c.name}</div>
                        </div>
                        <div class="absolute -top-1 -right-1 hidden group-hover:flex gap-1" style="z-index: 10;">
                          <button
                            onClick=${function(e) { e.stopPropagation(); editChar(c); }}
                            class="w-4 h-4 bg-blue-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-blue-600"
                            title="編集"
                          >✎</button>
                          <button
                            onClick=${function(e) { e.stopPropagation(); delChar(c.id); }}
                            class="w-4 h-4 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600"
                            title="削除"
                          >×</button>
                        </div>
                      </div>
                    `;
                  })}
                  <button onClick=${function() { setShowAddChar(true); }} class="flex-shrink-0 w-14 h-14 border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center text-gray-400">+</button>
                </div>
                <button
                  onClick=${function() { setActiveTab('character-sheet'); }}
                  class="mt-2 w-full px-3 py-2 text-sm bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                >
                  + シート生成
                </button>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('char'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">今回のキャラクター</span><${HelpIcon} text=${HELP.character} /></div>
                <span class="text-gray-400">${accord.indexOf('char') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('char') >= 0 ? 'open' : ''}">
                <div class="grid grid-cols-4 gap-2 py-2">
                  ${['説明者*', '相談者', '参考3', '参考4'].map(function(label, idx) { return html`<div key=${idx} class="border-2 ${selChars[idx] ? 'border-blue-400' : 'border-dashed border-gray-300'} rounded-lg p-1"><div class="text-xs text-gray-500 text-center mb-1">${label}</div>${selChars[idx] ? html`<div><div class="relative cursor-pointer" onClick=${function() { openCharDetail(idx); }}><img src=${selChars[idx].img} class="w-full h-14 object-cover rounded" /><button onClick=${function(e) { e.stopPropagation(); var nc = selChars.slice(); nc[idx] = null; setSelChars(nc); }} class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs">×</button></div><button onClick=${function() { openCharDetail(idx); }} class="text-xs text-blue-500 mt-1 hover:text-blue-600 w-full text-center">詳細を編集</button></div>` : html`<div class="h-14 flex items-center justify-center bg-gray-50 rounded cursor-pointer hover:bg-gray-100" onClick=${function() { charRefs.current[idx] && charRefs.current[idx].click(); }}><span class="text-gray-400 text-xs">+</span></div>`}<input ref=${function(el) { charRefs.current[idx] = el; }} type="file" accept="image/png,image/jpeg,image/webp" class="hidden" onChange=${function(e) { handleFile(e, idx); }} /></div>`; })}
                </div>
              </div>
            </div>

            <div class="mb-4">
              <button onClick=${function() { togAccord('style'); }} class="flex items-center justify-between w-full text-left">
                <div class="flex items-center"><span class="text-sm font-semibold text-gray-700">絵のテイスト</span><${HelpIcon} text=${HELP.style} /></div>
                <span class="text-gray-400">${accord.indexOf('style') >= 0 ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${accord.indexOf('style') >= 0 ? 'open' : ''}">
                <div class="max-h-64 overflow-y-auto py-2 scrollbar-thin">
                  ${sortedStyles.map(function(s) { return html`<div key=${s.id} draggable="true" onDragStart=${function(e) { handleDragStart(e, s.id); }} onDragOver=${handleDragOver} onDrop=${function(e) { handleDrop(e, s.id); }} class="flex items-center p-2 rounded-lg ${style === s.id ? 'bg-blue-50 border-l-4 border-blue-500' : 'hover:bg-gray-50'} ${draggedStyle === s.id ? 'opacity-50' : ''}"><div class="cursor-move mr-2 text-gray-400 hover:text-gray-600" onMouseDown=${function(e) { e.stopPropagation(); }}>☰</div><label class="flex items-center flex-1 cursor-pointer"><input type="radio" name="style" checked=${style === s.id} onChange=${function() { setStyle(s.id); }} class="mr-2" /><div class="flex-1"><div class="text-sm">${s.name}</div><div class="text-xs text-gray-500">${s.desc}</div></div></label>${s.custom && html`<div class="flex gap-2"><button onClick=${function(e) { e.preventDefault(); e.stopPropagation(); editCustomStyle(s.dbId); }} class="text-blue-500 hover:text-blue-700 text-sm">編集</button><button onClick=${function(e) { e.preventDefault(); e.stopPropagation(); delCustomStyle(s.dbId); }} class="text-red-500 hover:text-red-700 text-sm">削除</button></div>`}</div>`; })}
                </div>
                <button
                  onClick=${function() { setShowAddStyle(true); }}
                  class="w-full mt-2 p-2 border-2 border-dashed border-blue-300 rounded-lg text-blue-600 hover:bg-blue-50 transition-colors flex items-center justify-center gap-2"
                >
                  <span class="text-xl">+</span>
                  <span class="text-sm">カスタムスタイル追加</span>
                </button>
                ${style === 99 && html`<div class="mt-2 p-2 border border-dashed rounded-lg"><div class="text-xs text-gray-500 mb-2">参照画像</div>${styleRef ? html`<div class="relative inline-block"><img src=${styleRef.img} class="h-16 rounded" /><button onClick=${function() { setStyleRef(null); }} class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-xs">×</button></div>` : html`<button onClick=${function() { styleRefInput.current && styleRefInput.current.click(); }} class="text-sm text-blue-500">+ 画像選択</button>`}<input ref=${styleRefInput} type="file" accept="image/png,image/jpeg,image/webp" class="hidden" onChange=${function(e) { var f = e.target.files[0]; if (!f) return; try { validateImageFile(f); var r = new FileReader(); r.onload = function(ev) { setStyleRef({ img: ev.target.result }); }; r.readAsDataURL(f); } catch (err) { alert(err.message); e.target.value = ''; } }} /></div>`}
              </div>
            </div>

            <div class="mb-4 border-t pt-4">
              <button onClick=${function() { setShowAdvancedSettings(!showAdvancedSettings); }} class="flex items-center justify-between w-full text-left">
                <span class="text-sm font-semibold text-gray-700">詳細設定</span>
                <span class="text-gray-400">${showAdvancedSettings ? '▼' : '▶'}</span>
              </button>
              <div class="accordion-content ${showAdvancedSettings ? 'open' : ''}">
                <div class="py-2 space-y-4">

                  <div>
                    <div class="flex items-center mb-2">
                      <span class="text-sm font-medium text-gray-700">モデル選択</span>
                      <${HelpIcon} text=${HELP.model} />
                    </div>
                    <div class="space-y-1">
                      ${MODELS.map(function(m) { return html`<label key=${m.id} class="flex items-center p-2 rounded-lg cursor-pointer ${model === m.id ? 'bg-blue-50' : 'hover:bg-gray-50'}"><input type="radio" checked=${model === m.id} onChange=${function() { setModel(m.id); }} class="mr-2" /><div class="flex-1"><div class="text-sm">${m.name}</div><div class="text-xs text-gray-500">${m.price > 0 ? '$' + m.price + '/枚' : '無料'}</div></div></label>`; })}
                    </div>
                  </div>

                  <div>
                    <div class="text-sm font-medium text-gray-700 mb-2">セリフスタイル</div>
                    <div class="flex gap-2">
                      <label class="flex-1 flex items-center justify-center p-2 rounded-lg cursor-pointer border-2 ${speech === 'formal' ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}">
                        <input type="radio" checked=${speech === 'formal'} onChange=${function() { setSpeech('formal'); }} class="sr-only" />
                        <span class="text-sm">敬語</span>
                      </label>
                      <label class="flex-1 flex items-center justify-center p-2 rounded-lg cursor-pointer border-2 ${speech === 'casual' ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}">
                        <input type="radio" checked=${speech === 'casual'} onChange=${function() { setSpeech('casual'); }} class="sr-only" />
                        <span class="text-sm">タメ口</span>
                      </label>
                    </div>
                  </div>

                  <div>
                    <div class="text-sm font-medium text-gray-700 mb-2">キャラクター不在パネル</div>
                    <div class="flex gap-2">
                      ${[0, 1, 2].map(function(count) {
                        return html`
                          <button
                            key=${count}
                            onClick=${function() {
                              setCharAbsentCount(count);
                              localStorage.setItem('manga_char_absent_count', count);
                            }}
                            class="flex-1 p-2 rounded-lg border-2 text-center ${charAbsentCount === count ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-50'}"
                          >
                            <div class="text-sm font-semibold">${count === 0 ? 'なし' : count + '回'}</div>
                            <div class="text-xs text-gray-500 mt-1">${count === 0 ? '全4コマ' : (4 - count) + 'コマ登場'}</div>
                          </button>
                        `;
                      })}
                    </div>
                    <div class="text-xs text-gray-500 mt-2">
                      キャラクター不在パネルでは、図解・イメージ・クローズアップなどで内容を視覚的に表現します。
                    </div>
                  </div>

                </div>
              </div>
            </div>
          </div>

          <div class="flex-1 p-4 md:p-6 overflow-y-auto">
            ${!apiSaved && html`
              <div style="background: #FEF3C7; border: 2px solid #F59E0B; padding: 16px; text-align: center; margin-bottom: 20px; border-radius: 8px;">
                <div style="font-size: 18px; font-weight: bold; color: #92400E; margin-bottom: 8px;">
                  APIキーが未設定です
                </div>
                <div style="color: #78350F; margin-bottom: 12px;">
                  漫画を生成するには、Google AI StudioのAPIキーが必要です
                </div>
                <button onClick=${function() { window.open('https://aistudio.google.com/apikey', '_blank'); }} style="background: #F59E0B; color: white; padding: 10px 24px; border-radius: 8px; font-weight: bold; border: none; cursor: pointer; margin-right: 8px;">
                  API設定を開く
                </button>
                <button onClick=${function() { setShowTut(true); }} style="background: none; border: none; color: #92400E; text-decoration: underline; cursor: pointer;">
                  設定方法を見る（チュートリアル）
                </button>
              </div>
            `}
            <div class="md:hidden flex items-center justify-between mb-4">
              <button onClick=${function() { setSidebar(true); }} class="text-2xl">☰</button>
              <h1 class="text-lg font-bold">漫画クリエイター</h1>
              <div class="relative">
                <button
                  onClick=${function() { setShowUserMenu(!showUserMenu); }}
                  class="user-menu-button w-9 h-9 rounded-full text-white flex items-center justify-center text-sm font-bold transition-shadow"
                  style="background: var(--gradient-primary); box-shadow: var(--shadow-md);"
                  onMouseEnter=${(e) => e.target.style.boxShadow = 'var(--shadow-lg)'}
                  onMouseLeave=${(e) => e.target.style.boxShadow = 'var(--shadow-md)'}
                >
                  ${(user.user_metadata?.full_name || user.email || 'U').charAt(0).toUpperCase()}
                </button>
                ${showUserMenu && html`
                  <div class="user-menu-dropdown absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50">
                    <div class="px-4 py-2 border-b border-gray-100">
                      <div class="text-xs text-gray-500">ログイン中</div>
                      <div class="text-sm font-medium text-gray-800 truncate">${user.user_metadata?.full_name || user.email}</div>
                    </div>
                    <button onClick=${function() { setShowTut(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      使い方
                    </button>
                    <button onClick=${function() { setShowSamp(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      サンプル
                    </button>
                    <button onClick=${function() { setShowUsage(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      使用量
                    </button>
                    <div class="border-t border-gray-100 mt-1"></div>
                    <button onClick=${function() { onSignOut(); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50">
                      ログアウト
                    </button>
                  </div>
                `}
              </div>
            </div>

            <div class="hidden md:flex items-center justify-end mb-4 px-2">
              <div class="relative">
                <button
                  onClick=${function() { setShowUserMenu(!showUserMenu); }}
                  class="user-menu-button w-10 h-10 rounded-full text-white flex items-center justify-center text-base font-bold transition-shadow"
                  style="background: var(--gradient-primary); box-shadow: var(--shadow-md);"
                  onMouseEnter=${(e) => e.target.style.boxShadow = 'var(--shadow-lg)'}
                  onMouseLeave=${(e) => e.target.style.boxShadow = 'var(--shadow-md)'}
                >
                  ${(user.user_metadata?.full_name || user.email || 'U').charAt(0).toUpperCase()}
                </button>
                ${showUserMenu && html`
                  <div class="user-menu-dropdown absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50">
                    <div class="px-4 py-3 border-b border-gray-100">
                      <div class="text-xs text-gray-500">ログイン中</div>
                      <div class="text-sm font-medium text-gray-800 truncate">${user.user_metadata?.full_name || user.email}</div>
                    </div>
                    <button onClick=${function() { setShowTut(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      使い方
                    </button>
                    <button onClick=${function() { setShowSamp(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      サンプル
                    </button>
                    <button onClick=${function() { setShowUsage(true); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">
                      使用量
                    </button>
                    <div class="border-t border-gray-100 my-1"></div>
                    <button onClick=${function() { onSignOut(); setShowUserMenu(false); }} class="w-full px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50">
                      ログアウト
                    </button>
                  </div>
                `}
              </div>
            </div>

            <!-- タブナビゲーション -->
            <div class="mb-6 border-b border-gray-200">
              <nav class="flex gap-6">
                <button
                  onClick=${function() { setActiveTab('manga'); }}
                  class="pb-3 px-2 border-b-2 font-medium transition-colors ${activeTab === 'manga' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}"
                >
                  漫画生成
                </button>
                <button
                  onClick=${function() { setActiveTab('character-sheet'); }}
                  class="pb-3 px-2 border-b-2 font-medium transition-colors ${activeTab === 'character-sheet' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}"
                >
                  キャラクターシート
                </button>
                <button
                  onClick=${function() { setActiveTab('history'); setShowHist(true); }}
                  class="pb-3 px-2 border-b-2 font-medium transition-colors ${activeTab === 'history' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}"
                >
                  生成履歴
                </button>
              </nav>
            </div>

            ${activeTab === 'manga' && html`
            <div class="mb-6 card animate-fadeIn">
              <div class="flex items-center mb-3">
                <span class="text-lg font-semibold" style="color: var(--color-text-primary);">ストーリー・記事内容</span>
                <${HelpIcon} text=${HELP.story} />
              </div>
              <textarea
                value=${story}
                onInput=${function(e) { setStory(sanitizeInput(e.target.value, 5000)); }}
                placeholder="漫画にしたい内容を入力..."
                class="input-field w-full h-40 resize-y"
                style="font-family: var(--font-family);"
              ></textarea>
              <div class="flex justify-between text-xs mt-2" style="color: var(--color-text-secondary);">
                <span>${lastSave ? '自動保存 ' + lastSave.toLocaleTimeString() : ''}</span>
                <span>${story.length}文字</span>
              </div>
              <div class="text-xs mt-3" style="color: var(--color-text-secondary);">
                詳細なコマ設定: 位置 / サイズ / 内容 / セリフ / 背景 / キャラ / 表情 / カメラアングル / カメラ距離
                <button onClick=${function() { setShowPanelHelp(true); }} class="ml-2" style="color: var(--color-primary);">
                  [詳細を見る]
                </button>
              </div>

              <div class="mt-4 pt-4" style="border-top: 1px solid var(--color-border);">
                <div class="flex flex-wrap items-center gap-4">
                  <span class="text-sm font-medium" style="color: var(--color-text-primary);">生成枚数</span>
                  <div class="flex gap-2">${[1, 2, 3, 4, 5].map(function(n) { return html`<button key=${n} onClick=${function() { setGenCount(n); }} class="w-10 h-10 rounded-lg border-2 transition-all hover-lift ${genCount === n ? 'bg-blue-50' : ''}" style="border-color: ${genCount === n ? 'var(--color-primary)' : 'var(--color-border)'};">${n}</button>`; })}</div>
                  <div class="text-sm" style="color: var(--color-text-secondary);">予想: $${est().usd}（約${est().jpy}円）</div>
                </div>
              </div>
            </div>

            <div class="mb-6">
              ${isGen ? html`
                <div class="glass-card animate-fadeIn" style="background: var(--color-info-light); border-color: var(--color-info);">
                  <div class="flex items-center justify-between mb-3">
                    <div>
                      <div class="font-semibold" style="color: var(--color-text-primary);">生成中... ${genIdx + 1}/${genCount}枚</div>
                      ${elapsedTime > 0 && html`<div class="text-sm mt-1" style="color: var(--color-info);">経過時間: ${elapsedTime}秒</div>`}
                    </div>
                    <button
                      onClick=${function() { cancelRef.current = true; }}
                      class="px-4 py-2 text-sm rounded-lg transition-all"
                      style="background: var(--color-error); color: var(--color-white);"
                    >
                      停止
                    </button>
                  </div>
                  <div class="w-full rounded-full overflow-hidden" style="height: 8px; background: var(--color-bg-muted); box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <div
                      class="h-full rounded-full relative"
                      style=${{
                        width: ((genIdx + 1) / genCount * 100) + '%',
                        background: 'var(--gradient-primary)',
                        boxShadow: '0 0 12px rgba(0, 102, 204, 0.6)',
                        transition: 'width 0.5s cubic-bezier(0.4, 0, 0.2, 1)',
                        animation: 'shimmer 2s infinite'
                      }}
                    ></div>
                  </div>
                  ${currentStep > 0 && totalSteps > 0 && html`
                    <div class="mt-3 flex items-center gap-2 text-xs overflow-x-auto" style="color: var(--color-info);">
                      ${promptSteps.map(function(step, idx) {
                        var stepNum = idx + 1;
                        var isActive = stepNum === currentStep;
                        var isDone = stepNum < currentStep;
                        return html`
                          <div key=${idx} class="flex items-center gap-1 flex-shrink-0">
                            <div class="w-2 h-2 rounded-full ${isActive ? 'animate-pulse' : ''}" style="background: ${isActive ? 'var(--color-primary)' : isDone ? 'var(--color-success)' : 'var(--color-border)'};"></div>
                            <span class="${isActive ? 'font-semibold' : ''}">${step.name}</span>
                          </div>
                          ${idx < promptSteps.length - 1 && html`<span class="flex-shrink-0">→</span>`}
                        `;
                      })}
                    </div>
                  `}
                  ${genImages.length > 0 && html`<div class="mt-4 flex gap-2 overflow-x-auto">${genImages.map(function(img, i) { return html`<img key=${i} src=${img} class="w-20 h-28 object-cover rounded-lg cursor-pointer border-2 hover-lift" style="border-color: ${curImg === i ? 'var(--color-primary)' : 'var(--color-border)'};" onClick=${function() { setCurImg(i); }} />`; })}</div>`}
                </div>
              ` : html`
                <button
                  onClick=${generate}
                  disabled=${!apiSaved}
                  class="btn-primary w-full ${apiSaved && story ? 'hover-scale' : ''}"
                  style="font-size: var(--font-size-lg); font-weight: var(--font-weight-semibold); padding: var(--spacing-4) var(--spacing-6); ${!apiSaved ? 'opacity: 0.5; cursor: not-allowed;' : ''} ${apiSaved && story ? 'animation: pulse 2s ease-in-out infinite;' : ''}"
                >
                  漫画を生成（${genCount}枚）
                </button>
              `}
              ${error && html`<div class="alert alert-error mt-3 text-center">${error}</div>`}
            </div>

            <div class="mb-6">
              <div class="flex items-center justify-between mb-2">
                <span class="text-lg font-semibold text-gray-700">生成された漫画</span>
                ${genImages.length > 0 && html`<span class="text-sm text-gray-500">${curImg + 1}/${genImages.length}枚</span>`}
              </div>
              <div class="bg-gray-100 rounded-lg p-4 min-h-64 flex items-center justify-center relative">
                ${genImages.length > 0 ? html`
                  ${curImg > 0 && html`
                    <button
                      onClick=${function() { setCurImg(curImg - 1); }}
                      class="absolute left-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                    >
                      ←
                    </button>
                  `}
                  <img
                    src=${genImages[curImg]}
                    class="max-w-full max-h-[500px] rounded-lg shadow-lg cursor-pointer"
                    onClick=${function() { setModalImg(genImages[curImg]); setModalImgIdx(curImg); setShowImg(true); }}
                  />
                  ${curImg < genImages.length - 1 && html`
                    <button
                      onClick=${function() { setCurImg(curImg + 1); }}
                      class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                    >
                      →
                    </button>
                  `}
                ` : html`<div class="text-gray-400 text-center"><div class="text-4xl mb-2">○</div><div>ここに漫画が表示されます</div></div>`}
              </div>
              ${genImages.length > 1 && html`<div class="flex justify-center gap-2 mt-4">${genImages.map(function(_, i) { return html`<button key=${i} onClick=${function() { setCurImg(i); }} class="w-10 h-10 rounded-lg border-2 ${curImg === i ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">${i + 1}</button>`; })}</div>`}
              ${genImages.length > 0 && html`<div class="flex gap-3 mt-4 justify-center"><button onClick=${function() { dl(genImages[curImg], curImg); }} class="px-4 py-2 bg-blue-500 text-white text-sm rounded-lg">ダウンロード</button><button onClick=${function() { setGenImages([]); }} class="px-4 py-2 bg-gray-500 text-white text-sm rounded-lg">クリア</button></div>`}
            </div>

            ${history.length > 0 && html`
              <div>
                <div class="flex items-center justify-between mb-2"><span class="text-lg font-semibold text-gray-700">生成履歴</span><button onClick=${function() { setShowHist(true); }} class="text-sm text-blue-500">すべて見る</button></div>
                <div class="flex gap-3 overflow-x-auto pb-2 scrollbar-thin">${history.slice(0, 5).map(function(h) { return html`<div key=${h.id} class="flex-shrink-0 cursor-pointer relative" onClick=${function() { setHistDet(h); setShowHistDet(true); }}>${favHist.indexOf(h.id) >= 0 && html`<div class="absolute top-1 left-1 text-yellow-500">★</div>`}<img src=${h.img} class="w-20 h-28 object-cover rounded-lg border-2 border-gray-200 hover:border-blue-400" /></div>`; })}</div>
              </div>
            `}
            `}

            ${activeTab === 'character-sheet' && html`
            <div class="max-w-3xl mx-auto animate-fadeIn">
              <div class="space-y-6">
                <div>
                  <label class="block text-sm font-medium mb-2" style="color: var(--color-text-primary);">
                    キャラクター名 *
                  </label>
                  <input
                    type="text"
                    value=${charSheetName}
                    onInput=${function(e) { setCharSheetName(e.target.value); }}
                    placeholder="例: 山田太郎"
                    class="input-field w-full"
                  />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-2" style="color: var(--color-text-primary);">
                    ベース画像
                  </label>
                  <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center bg-gray-50 hover:bg-gray-100 transition-colors">
                    <input
                      type="file"
                      ref=${charSheetFileRef}
                      onChange=${handleCharSheetImageUpload}
                      accept="image/png,image/jpeg,image/webp"
                      class="hidden"
                    />
                    ${charSheetBaseImg ? html`
                      <div class="space-y-3">
                        <img
                          src=${charSheetBaseImg}
                          class="w-32 h-32 object-cover rounded-lg mx-auto border-2 border-gray-300"
                        />
                        <div class="flex gap-2 justify-center">
                          <button
                            onClick=${function() { charSheetFileRef.current?.click(); }}
                            class="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
                          >
                            変更
                          </button>
                          <button
                            onClick=${function() { setCharSheetBaseImg(null); }}
                            class="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600"
                          >
                            削除
                          </button>
                        </div>
                      </div>
                    ` : html`
                      <div class="space-y-2">
                        <button
                          onClick=${function() { charSheetFileRef.current?.click(); }}
                          class="text-blue-600 hover:text-blue-700 font-medium"
                        >
                          ファイルを選択
                        </button>
                        <p class="text-xs text-gray-500">
                          PNG, JPG, WEBP (最大10MB)
                        </p>
                      </div>
                    `}
                  </div>
                </div>

                <div>
                  <label class="block text-sm font-medium mb-2" style="color: var(--color-text-primary);">
                    キャラクター説明
                  </label>
                  <textarea
                    value=${charSheetDesc}
                    onInput=${function(e) { setCharSheetDesc(e.target.value); }}
                    placeholder="例:${'\n'}25歳男性、短い黒髪、茶色い瞳${'\n'}グレーのスーツに青いネクタイ${'\n'}優しい笑顔、細身の体型${'\n'}${'\n'}※ベース画像だけでも生成できます"
                    rows="4"
                    class="input-field w-full"
                    style="resize: vertical;"
                  ></textarea>
                  <div class="text-xs text-gray-500 mt-1">
                    ${charSheetDesc.length} / 500文字
                  </div>
                </div>

                <div>
                  <label class="block text-sm font-medium mb-2" style="color: var(--color-text-primary);">
                    絵のテイスト
                  </label>
                  <div class="p-3 bg-gray-100 rounded-lg border border-gray-300">
                    <div class="text-sm text-gray-700">
                      現在選択中: <span class="font-semibold">${(function() {
                        var allStyles = getAllStyles();
                        var currentStyle = allStyles.find(function(s) { return s.id === style; });
                        return currentStyle ? currentStyle.title : '未選択';
                      })()}</span>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">
                      左メニューの「絵のテイスト」から変更できます
                    </div>
                  </div>
                </div>

                <div class="mb-4 pt-4" style="border-top: 1px solid var(--color-border);">
                  <div class="flex flex-wrap items-center gap-4">
                    <span class="text-sm font-medium" style="color: var(--color-text-primary);">生成枚数</span>
                    <div class="flex gap-2">
                      ${[1, 2, 3, 4, 5].map(function(n) {
                        return html`
                          <button
                            key=${n}
                            onClick=${function() { setCharSheetCount(n); }}
                            class="w-10 h-10 rounded-lg border-2 transition-all hover-lift ${charSheetCount === n ? 'bg-blue-50' : ''}"
                            style="border-color: ${charSheetCount === n ? 'var(--color-primary)' : 'var(--color-border)'};"
                          >
                            ${n}
                          </button>
                        `;
                      })}
                    </div>
                  </div>
                </div>

                ${charSheetGenStep > 0 ? html`
                  <div class="mb-6 p-4 rounded-lg bg-blue-50 border-2 border-blue-200">
                    <div class="flex items-center justify-between mb-2">
                      <span class="text-sm font-medium text-blue-800">キャラクターシート生成中...</span>
                      <span class="text-sm text-blue-600">${generatedCharSheets.length} / ${charSheetCount}枚</span>
                    </div>
                    <div class="w-full bg-blue-200 rounded-full h-2 mb-2">
                      <div class="bg-blue-600 h-2 rounded-full transition-all" style="width: ${(generatedCharSheets.length / charSheetCount) * 100}%"></div>
                    </div>
                    <div class="text-xs text-blue-600">並列生成中...</div>
                  </div>
                ` : html`
                  <button
                    onClick=${generateCharacterSheets}
                    disabled=${!charSheetName || (!charSheetBaseImg && !charSheetDesc)}
                    class="btn-primary w-full ${charSheetName && (charSheetBaseImg || charSheetDesc) ? 'hover-scale' : ''}"
                    style="font-size: var(--font-size-lg); font-weight: var(--font-weight-semibold); padding: var(--spacing-4) var(--spacing-6); ${!charSheetName || (!charSheetBaseImg && !charSheetDesc) ? 'opacity: 0.5; cursor: not-allowed;' : ''}"
                  >
                    キャラクターシート生成（${charSheetCount}枚）
                  </button>
                `}

                ${error && html`<div class="alert alert-error mt-3 text-center">${error}</div>`}
              </div>

              <div class="mb-6 mt-6">
                <div class="flex items-center justify-between mb-2">
                  <span class="text-lg font-semibold text-gray-700">生成されたキャラクターシート</span>
                  ${generatedCharSheets.length > 0 && html`<span class="text-sm text-gray-500">${curCharSheet + 1}/${generatedCharSheets.length}枚</span>`}
                </div>
                <div class="bg-gray-100 rounded-lg p-4 min-h-64 flex items-center justify-center relative">
                  ${generatedCharSheets.length > 0 ? html`
                    ${curCharSheet > 0 && html`
                      <button
                        onClick=${function() { setCurCharSheet(curCharSheet - 1); }}
                        class="absolute left-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                      >
                        ←
                      </button>
                    `}
                    <img
                      src=${generatedCharSheets[curCharSheet]}
                      class="max-w-full max-h-[500px] rounded-lg shadow-lg cursor-pointer"
                      onClick=${function() { setModalImg(generatedCharSheets[curCharSheet]); setModalImgIdx(curCharSheet); setShowImg(true); }}
                    />
                    ${curCharSheet < generatedCharSheets.length - 1 && html`
                      <button
                        onClick=${function() { setCurCharSheet(curCharSheet + 1); }}
                        class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-black bg-opacity-50 hover:bg-opacity-70 text-white rounded-full w-10 h-10 flex items-center justify-center transition-all z-10"
                      >
                        →
                      </button>
                    `}
                  ` : html`<div class="text-gray-400 text-center"><div class="text-4xl mb-2">○</div><div>ここにキャラクターシートが表示されます</div></div>`}
                </div>
                ${generatedCharSheets.length > 1 && html`<div class="flex justify-center gap-2 mt-4">${generatedCharSheets.map(function(_, i) { return html`<button key=${i} onClick=${function() { setCurCharSheet(i); }} class="w-10 h-10 rounded-lg border-2 ${curCharSheet === i ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">${i + 1}</button>`; })}</div>`}
                ${generatedCharSheets.length > 0 && html`
                  <div class="flex gap-3 mt-4 justify-center">
                    <button
                      onClick=${function() {
                        saveCharSheetToLibrary(generatedCharSheets[curCharSheet], curCharSheet);
                      }}
                      class="px-4 py-2 text-white text-sm rounded-lg transition-colors ${charSheetSaved.indexOf(curCharSheet) >= 0 ? 'bg-green-500 hover:bg-green-600' : 'bg-blue-500 hover:bg-blue-600'}"
                    >
                      ${charSheetSaved.indexOf(curCharSheet) >= 0 ? '✓ 保存済み' : 'ライブラリに保存'}
                    </button>
                    <button
                      onClick=${function() { downloadCharSheet(generatedCharSheets[curCharSheet], curCharSheet); }}
                      class="px-4 py-2 bg-gray-500 text-white text-sm rounded-lg hover:bg-gray-600"
                    >
                      ダウンロード
                    </button>
                    ${generatedCharSheets.length > 1 && html`
                      <button
                        onClick=${async function() {
                          for (var i = 0; i < generatedCharSheets.length; i++) {
                            await saveCharSheetToLibrary(generatedCharSheets[i], i);
                          }
                        }}
                        class="px-4 py-2 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700"
                      >
                        全て保存
                      </button>
                    `}
                    <button
                      onClick=${function() { setGeneratedCharSheets([]); setCurCharSheet(0); setCharSheetSaved([]); }}
                      class="px-4 py-2 bg-gray-500 text-white text-sm rounded-lg hover:bg-gray-600"
                    >
                      クリア
                    </button>
                  </div>
                `}
              </div>
            </div>
            `}
          </div>

          <${Modal} isOpen=${showTut} onClose=${function() { setShowTut(false); }} title="使い方" size="md">
            <div class="text-center">
              <div class="flex justify-center gap-1 mb-4">${TUTORIAL.map(function(_, i) { return html`<div key=${i} class="w-3 h-3 rounded-full ${i === tutStep ? 'bg-blue-500' : 'bg-gray-300'}"></div>`; })}</div>
              <h4 class="text-xl font-bold mb-4">${TUTORIAL[tutStep].title}</h4>
              <p class="text-gray-700 mb-6 min-h-24 whitespace-pre-wrap">${TUTORIAL[tutStep].content}</p>
              <div class="flex justify-between">
                <button onClick=${function() { setTutStep(Math.max(0, tutStep - 1)); }} class="px-4 py-2 text-gray-600" disabled=${tutStep === 0}>← 戻る</button>
                <button onClick=${compTut} class="px-4 py-2 text-gray-500">スキップ</button>
                ${tutStep < TUTORIAL.length - 1 ? html`<button onClick=${function() { setTutStep(tutStep + 1); }} class="px-4 py-2 bg-blue-500 text-white rounded-lg">次へ →</button>` : html`<button onClick=${compTut} class="px-4 py-2 bg-blue-500 text-white rounded-lg">始める</button>`}
              </div>
            </div>
          <//>

          <${Modal} isOpen=${showSamp} onClose=${function() { setShowSamp(false); }} title="サンプルギャラリー" size="lg">
            <p class="text-gray-600 mb-4">このツールで作成できる漫画の例です</p>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">${SAMPLES.map(function(s) { return html`<div key=${s.id} class="border rounded-lg p-3"><div class="bg-gray-200 h-32 rounded mb-2 flex items-center justify-center text-gray-400 text-sm">サンプル画像</div><div class="text-sm font-semibold">${s.title}</div><div class="text-xs text-gray-500">${s.cat}</div></div>`; })}</div>
          <//>

          <${Modal} isOpen=${showHist} onClose=${function() { setShowHist(false); }} title="生成履歴" size="full">
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">${history.map(function(h) { return html`<div key=${h.id} class="cursor-pointer relative hover:scale-105 transition-transform" onClick=${function() { setHistDet(h); setShowHistDet(true); setShowHist(false); }}>${favHist.indexOf(h.id) >= 0 && html`<div class="absolute top-2 left-2 text-yellow-500 z-10 text-2xl">★</div>`}<img src=${h.img} class="w-full h-80 object-cover rounded-lg border-2 border-gray-200 shadow-lg" /></div>`; })}</div>
          <//>

          <${Modal} isOpen=${showHistDet} onClose=${function() { setShowHistDet(false); }} title="詳細" size="lg">
            ${histDet && (function() {
              var currentIndex = history.findIndex(function(h) { return h.id === histDet.id; });
              var hasPrev = currentIndex < history.length - 1;
              var hasNext = currentIndex > 0;
              return html`
                <div class="flex flex-col md:flex-row gap-4">
                  <div class="flex-1">
                    <img src=${histDet.img} class="w-full rounded-lg cursor-pointer" onClick=${function() { setModalImg(histDet.img); setShowImg(true); }} />
                    <div class="text-center text-sm text-gray-500 mt-2">${currentIndex + 1} / ${history.length}</div>
                  </div>

                  <div class="flex-1 flex flex-col">
                    <div class="flex items-center justify-between mb-4">
                      <button
                        onClick=${function() { setHistDet(history[currentIndex + 1]); }}
                        disabled=${!hasPrev}
                        class="px-4 py-2 rounded-lg font-semibold transition-all ${hasPrev ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}"
                        style="min-width: 80px;"
                      >
                        ‹ 前へ
                      </button>
                      <button
                        onClick=${function() { setHistDet(history[currentIndex - 1]); }}
                        disabled=${!hasNext}
                        class="px-4 py-2 rounded-lg font-semibold transition-all ${hasNext ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}"
                        style="min-width: 80px;"
                      >
                        次へ ›
                      </button>
                    </div>

                    <h4 class="font-semibold mb-2">生成設定</h4>
                    <div class="space-y-2 text-sm mb-4">
                      <div>テイスト: ${histDet.settings ? histDet.settings.styleName : '-'}</div>
                      <div>セリフ: ${histDet.settings && histDet.settings.speech === 'formal' ? '敬語' : 'タメ口'}</div>
                      <div>モデル: ${histDet.settings ? histDet.settings.modelName : '-'}</div>
                      <div>日時: ${new Date(histDet.ts).toLocaleString()}</div>
                    </div>
                    <div class="flex gap-2">
                      <button
                        onClick=${function() { toggleFavHist(histDet.id); }}
                        class="px-3 py-2 border rounded-lg ${favHist.indexOf(histDet.id) >= 0 ? 'border-yellow-500 bg-yellow-50' : ''}"
                      >
                        ${favHist.indexOf(histDet.id) >= 0 ? '★ 解除' : '☆ 登録'}
                      </button>
                      <button
                        onClick=${function() { dl(histDet.img, currentIndex); }}
                        class="px-3 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                      >
                        DL
                      </button>
                    </div>
                  </div>
                </div>
              `;
            })()}
          <//>

          <${Modal} isOpen=${showUsage} onClose=${function() { setShowUsage(false); }} title="使用量" size="md">
            <div class="space-y-4">
              <div><h4 class="font-semibold mb-2">今月</h4><div class="bg-gray-50 rounded-lg p-4"><div class="text-2xl font-bold">${mu.count}枚</div><div class="text-gray-600">推定: $${mu.cost.toFixed(2)}</div></div></div>
              <div><h4 class="font-semibold mb-2">累計</h4><div class="bg-gray-50 rounded-lg p-4"><div class="flex justify-between"><span>総枚数</span><span class="font-bold">${usage.total ? usage.total.count : 0}枚</span></div><div class="flex justify-between"><span>累計</span><span class="font-bold">$${usage.total ? usage.total.cost.toFixed(2) : '0.00'}</span></div></div></div>
            </div>
          <//>

          <${Modal} isOpen=${showAddChar} onClose=${function() { setShowAddChar(false); setNewCharName(''); setNewCharImg(null); }} title="キャラクター追加" size="sm">
            <input type="text" value=${newCharName} onInput=${function(e) { setNewCharName(sanitizeInput(e.target.value, 50)); }} placeholder="名前" class="w-full px-3 py-2 border rounded-lg mb-4" />
            <div class="border-2 border-dashed rounded-lg p-4 mb-4 text-center cursor-pointer" onClick=${function() { fileRef.current && fileRef.current.click(); }}>${newCharImg ? html`<img src=${newCharImg} class="max-h-32 mx-auto rounded" />` : html`<div class="text-gray-400"><div class="text-3xl mb-2">+</div><div>画像を選択</div></div>`}</div>
            <input ref=${fileRef} type="file" accept="image/png,image/jpeg,image/webp" class="hidden" onChange=${function(e) { var f = e.target.files[0]; if (!f) return; try { validateImageFile(f); var r = new FileReader(); r.onload = function(ev) { setNewCharImg(ev.target.result); }; r.readAsDataURL(f); } catch (err) { alert(err.message); e.target.value = ''; } }} />
            <div class="flex gap-3"><button onClick=${function() { setShowAddChar(false); setNewCharName(''); setNewCharImg(null); }} class="flex-1 py-2 border rounded-lg">キャンセル</button><button onClick=${addChar} disabled=${!newCharName || !newCharImg} class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50">追加</button></div>
          <//>

          <${Modal} isOpen=${showEditChar} onClose=${function() { setShowEditChar(false); setEditingCharId(null); setEditCharName(''); setEditCharImg(null); }} title="キャラクター編集" size="sm">
            <input type="text" value=${editCharName} onInput=${function(e) { setEditCharName(sanitizeInput(e.target.value, 50)); }} placeholder="名前" class="w-full px-3 py-2 border rounded-lg mb-4" />
            <div class="border-2 border-dashed rounded-lg p-4 mb-4 text-center cursor-pointer" onClick=${function() { editFileRef.current && editFileRef.current.click(); }}>${editCharImg ? html`<img src=${editCharImg} class="max-h-32 mx-auto rounded" />` : html`<div class="text-gray-400"><div class="text-3xl mb-2">+</div><div>画像を選択</div></div>`}</div>
            <input ref=${editFileRef} type="file" accept="image/png,image/jpeg,image/webp" class="hidden" onChange=${function(e) { var f = e.target.files[0]; if (!f) return; try { validateImageFile(f); var r = new FileReader(); r.onload = function(ev) { compressImage(ev.target.result, 500, 0.7).then(function(compressed) { setEditCharImg(compressed); }); }; r.readAsDataURL(f); } catch (err) { alert(err.message); e.target.value = ''; } }} />
            <div class="flex gap-3"><button onClick=${function() { setShowEditChar(false); setEditingCharId(null); setEditCharName(''); setEditCharImg(null); }} class="flex-1 py-2 border rounded-lg">キャンセル</button><button onClick=${updateChar} disabled=${!editCharName || !editCharImg} class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50">更新</button></div>
          <//>

          <${Modal} isOpen=${showAddProj} onClose=${function() { setShowAddProj(false); setNewProjName(''); }} title="プロジェクト保存" size="sm">
            <p class="text-sm text-gray-600 mb-4">現在の設定を保存します</p>
            <input type="text" value=${newProjName} onInput=${function(e) { setNewProjName(sanitizeInput(e.target.value, 100)); }} placeholder="プロジェクト名" class="w-full px-3 py-2 border rounded-lg mb-4" />
            <div class="flex gap-3"><button onClick=${function() { setShowAddProj(false); setNewProjName(''); }} class="flex-1 py-2 border rounded-lg">キャンセル</button><button onClick=${saveProj} disabled=${!newProjName} class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50">保存</button></div>
          <//>

          <${Modal} isOpen=${showAddStyle} onClose=${function() { setShowAddStyle(false); setNewStyleTitle(''); setNewStyleDesc(''); setNewStylePrompt(''); }} title="カスタムスタイル追加" size="md">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">タイトル *</label>
                <input
                  type="text"
                  value=${newStyleTitle}
                  onInput=${function(e) { setNewStyleTitle(sanitizeInput(e.target.value, 50)); }}
                  placeholder="例: アニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="50"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">説明</label>
                <input
                  type="text"
                  value=${newStyleDesc}
                  onInput=${function(e) { setNewStyleDesc(sanitizeInput(e.target.value, 100)); }}
                  placeholder="例: ジブリ作品のような温かみのあるアニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="100"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">プロンプト *</label>
                <textarea
                  value=${newStylePrompt}
                  onInput=${function(e) { setNewStylePrompt(sanitizeInput(e.target.value, 2000)); }}
                  placeholder="例: Studio Ghibli anime illustration style with warm watercolor backgrounds..."
                  class="w-full px-3 py-2 border rounded-lg h-32 resize-none"
                ></textarea>
                <p class="text-xs text-gray-500 mt-1">画像生成に使用されるプロンプトを入力してください</p>
              </div>
              <div class="flex gap-3">
                <button
                  onClick=${function() { setShowAddStyle(false); setNewStyleTitle(''); setNewStyleDesc(''); setNewStylePrompt(''); }}
                  class="flex-1 py-2 border rounded-lg hover:bg-gray-50"
                >
                  キャンセル
                </button>
                <button
                  onClick=${addCustomStyle}
                  disabled=${!newStyleTitle || !newStylePrompt}
                  class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600"
                >
                  追加
                </button>
              </div>
            </div>
          <//>

          <${Modal} isOpen=${showEditStyle} onClose=${function() { setShowEditStyle(false); setEditingStyleId(null); setEditStyleTitle(''); setEditStyleDesc(''); setEditStylePrompt(''); }} title="カスタムスタイル編集" size="md">
            <div class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">タイトル *</label>
                <input
                  type="text"
                  value=${editStyleTitle}
                  onInput=${function(e) { setEditStyleTitle(sanitizeInput(e.target.value, 50)); }}
                  placeholder="例: アニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="50"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">説明</label>
                <input
                  type="text"
                  value=${editStyleDesc}
                  onInput=${function(e) { setEditStyleDesc(sanitizeInput(e.target.value, 100)); }}
                  placeholder="例: ジブリ作品のような温かみのあるアニメ風"
                  class="w-full px-3 py-2 border rounded-lg"
                  maxLength="100"
                />
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">プロンプト *</label>
                <textarea
                  value=${editStylePrompt}
                  onInput=${function(e) { setEditStylePrompt(sanitizeInput(e.target.value, 2000)); }}
                  placeholder="例: Studio Ghibli anime illustration style with warm watercolor backgrounds..."
                  class="w-full px-3 py-2 border rounded-lg h-32 resize-none"
                ></textarea>
                <p class="text-xs text-gray-500 mt-1">画像生成に使用されるプロンプトを入力してください</p>
              </div>
              <div class="flex gap-3">
                <button
                  onClick=${function() { setShowEditStyle(false); setEditingStyleId(null); setEditStyleTitle(''); setEditStyleDesc(''); setEditStylePrompt(''); }}
                  class="flex-1 py-2 border rounded-lg hover:bg-gray-50"
                >
                  キャンセル
                </button>
                <button
                  onClick=${updateCustomStyle}
                  disabled=${!editStyleTitle || !editStylePrompt}
                  class="flex-1 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600"
                >
                  更新
                </button>
              </div>
            </div>
          <//>

          ${showImg && html`
            <div class="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4" onClick=${function() { setShowImg(false); }}>
              <div class="bg-white rounded-xl w-full max-w-7xl h-[90vh] overflow-hidden flex flex-col" onClick=${function(e) { e.stopPropagation(); }}>
                <div class="flex justify-between items-center p-4 border-b">
                  <h3 class="text-lg font-bold">プレビュー</h3>
                  <button onClick=${function() { setShowImg(false); }} class="text-gray-500 hover:text-gray-700 text-2xl leading-none">×</button>
                </div>
                <div class="flex gap-4 flex-1 overflow-hidden">
                  <div class="flex-1 flex items-center justify-center bg-gray-900 p-4">
                    ${(function() {
                      var imgList = activeTab === 'character-sheet' && generatedCharSheets.length > 0 ? generatedCharSheets : genImages;
                      var currentImg = imgList[modalImgIdx] || modalImg;
                      return html`
                        <img
                          src=${currentImg}
                          class="max-h-full max-w-full object-contain"
                        />
                      `;
                    })()}
                  </div>
                  <div class="w-64 p-4 flex flex-col gap-4 overflow-y-auto">
                    ${(function() {
                      var imgList = activeTab === 'character-sheet' && generatedCharSheets.length > 0 ? generatedCharSheets : genImages;
                      var hasMultiple = imgList.length > 1;
                      var currentImg = imgList[modalImgIdx] || modalImg;

                      return html`
                        ${hasMultiple && html`
                          <div class="flex flex-col gap-3">
                            ${modalImgIdx > 0 && html`
                              <button
                                onClick=${function() { setModalImgIdx(modalImgIdx - 1); }}
                                class="w-full py-3 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors text-center"
                              >
                                ← 前へ
                              </button>
                            `}
                            <div class="text-center text-gray-600 py-2">
                              ${modalImgIdx + 1} / ${imgList.length}
                            </div>
                            ${modalImgIdx < imgList.length - 1 && html`
                              <button
                                onClick=${function() { setModalImgIdx(modalImgIdx + 1); }}
                                class="w-full py-3 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors text-center"
                              >
                                次へ →
                              </button>
                            `}
                          </div>
                        `}
                        <a
                          href=${currentImg}
                          download=${activeTab === 'character-sheet' ? 'character_sheet_' + (modalImgIdx + 1) + '_' + Date.now() + '.png' : 'manga_' + (modalImgIdx + 1) + '_' + Date.now() + '.png'}
                          class="w-full py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-center block"
                        >
                          ダウンロード
                        </a>
                        ${hasMultiple && html`
                          <div class="border-t pt-4">
                            <div class="text-sm font-medium text-gray-700 mb-2">他の画像</div>
                            <div class="space-y-2">
                              ${imgList.map(function(img, i) {
                                return html`
                                  <img
                                    key=${i}
                                    src=${img}
                                    onClick=${function() { setModalImgIdx(i); }}
                                    class="w-full h-32 object-cover rounded cursor-pointer border-2 ${modalImgIdx === i ? 'border-blue-500' : 'border-gray-300'} hover:border-blue-400 transition-all"
                                  />
                                `;
                              })}
                            </div>
                          </div>
                        `}
                      `;
                    })()}
                  </div>
                </div>
              </div>
            </div>
          `}

          <${Modal} isOpen=${showDraft} onClose=${function() { setShowDraft(false); }} title="下書きが見つかりました" size="sm">
            <p class="text-gray-600 mb-4">前回の作業内容を復元しますか？</p>
            ${draft && html`<div class="bg-gray-50 rounded-lg p-3 mb-4 text-sm"><div class="text-gray-500">保存: ${new Date(draft.ts).toLocaleString()}</div><div class="text-gray-700 mt-1 truncate">「${draft.story ? draft.story.substring(0, 50) : ''}...」</div></div>`}
            <div class="flex gap-3"><button onClick=${function() { setShowDraft(false); localStorage.removeItem('manga_draft'); }} class="flex-1 py-2 border rounded-lg">破棄</button><button onClick=${restoreDraft} class="flex-1 py-2 bg-blue-500 text-white rounded-lg">復元</button></div>
          <//>

          <${Modal} isOpen=${showCharDetail} onClose=${function() { setShowCharDetail(false); }} title="キャラクター詳細設定" size="md">
            <div class="flex flex-col items-center">
              ${selChars[charDetailIdx] && html`
                <img src=${selChars[charDetailIdx].img} class="w-48 h-48 object-cover rounded-lg mb-4 border-2 border-blue-400" />
                <div class="w-full space-y-3">
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">キャラクター名（任意）</label>
                    <input
                      type="text"
                      placeholder="例: 美咲"
                      maxLength="10"
                      value=${charDetails[charDetailIdx].name}
                      onInput=${function(e) { updateCharDetail(charDetailIdx, 'name', e.target.value); }}
                      class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                    />
                    <p class="text-xs text-gray-500 mt-1">最大10文字</p>
                  </div>
                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">キャラクター特徴（任意）</label>
                    <textarea
                      placeholder="例: 黒髪ロングヘア、青い瞳${'\n'}白いシャツに黒いスカート${'\n'}優しくて落ち着いた雰囲気"
                      maxLength="200"
                      value=${charDetails[charDetailIdx].features}
                      onInput=${function(e) { updateCharDetail(charDetailIdx, 'features', e.target.value); }}
                      class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none"
                      rows="5"
                    ></textarea>
                    <p class="text-xs text-gray-500 mt-1">最大200文字 | ${charDetails[charDetailIdx].features.length}/200</p>
                  </div>
                  <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600">※これらの情報は任意入力です。画像生成時にAIへのヒントとして使用されます。</p>
                  </div>
                </div>
              `}
            </div>
          <//>

          <${Modal} isOpen=${showPanelHelp} onClose=${function() { setShowPanelHelp(false); }} title="コマ別の詳細指定ガイド" size="lg">
            <div class="space-y-4">
              <div class="mb-4">
                <h4 class="font-semibold text-gray-800 mb-2">この機能について</h4>
                <p class="text-sm text-gray-700">
                  ストーリー入力欄で <strong>【コマN】</strong> の形式を使うと、各コマの詳細を個別に指定できます。<br />
                  2〜4コマの漫画を作る場合や、特定のコマだけ詳しく指定したい場合に便利です。
                </p>
              </div>

              <div class="space-y-4">
                <h4 class="font-semibold text-gray-800">使用例</h4>

                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <p class="text-sm font-medium text-gray-800 mb-2">複数の項目を組み合わせた例</p>
                  <div class="text-xs text-gray-700 bg-gray-50 p-3 rounded whitespace-pre-wrap">【コマ1】
位置: 上
サイズ: 大
背景: 明るいカフェ
セリフ: いい天気だね！
表情: 笑顔

【コマ2】
位置: 下
サイズ: 小
内容: 薄暗い部屋、窓から雨が見える
セリフ: ...急に雨が
表情: 困惑</div>
                </div>

                <div class="border-t pt-4">
                  <div class="space-y-3 text-sm">
                    <div>
                      <div class="font-medium text-gray-800">位置</div>
                      <div class="text-gray-600 ml-2">例: 左上、右上、中央、上、下</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">サイズ</div>
                      <div class="text-gray-600 ml-2">例: 大、小、中</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">内容</div>
                      <div class="text-gray-600 ml-2">例: 主人公が驚いた表情で本を落とす、薄暗い部屋でデスクライトだけが明るい</div>
                      <div class="text-xs text-gray-500 ml-2 mt-1">※照明・トーンもここで指定可能（例: 薄暗い、明るい日差し、夜の雰囲気）</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">セリフ</div>
                      <div class="text-gray-600 ml-2">例: えっ、これ本当？、もう少しで完成だ...</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">背景</div>
                      <div class="text-gray-600 ml-2">例: 明るいリビング、夜のオフィス、カフェの店内</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">キャラ</div>
                      <div class="text-gray-600 ml-2">例: 説明者のみ、説明者と相談者、相談者のみ</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">表情</div>
                      <div class="text-gray-600 ml-2">例: 驚き、真剣、笑顔、困惑、納得</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">カメラアングル</div>
                      <div class="text-gray-600 ml-2">例: 正面、斜め上から、横顔、俯瞰</div>
                    </div>

                    <div>
                      <div class="font-medium text-gray-800">カメラ距離</div>
                      <div class="text-gray-600 ml-2">例: クローズアップ、全身、バストショット</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          <//>
        </div>
      `;
    }

    // デザイン切り替え機能
    window.switchDesign = function(design) {
      var validDesigns = ['plan-a', 'plan-b', 'plan-c'];
      if (!validDesigns.includes(design)) {
        console.error('Invalid design. Use "plan-a", "plan-b", or "plan-c"');
        return;
      }
      document.body.setAttribute('data-design', design);
      localStorage.setItem('manga_design_preset', design);
      console.log('✅ Design switched to:', design);
      console.log('   Plan A: クリーン&ミニマル');
      console.log('   Plan B: モダン&プロフェッショナル (current)');
      console.log('   Plan C: テック企業風');
    };

    // ページロード時にデザイン設定を復元
    (function() {
      var savedDesign = localStorage.getItem('manga_design_preset') || 'plan-b';
      document.body.setAttribute('data-design', savedDesign);
    })();

    // 認証ラッパー（メインApp）
    function App() {
      var s1 = useState(null); var user = s1[0], setUser = s1[1];
      var s2 = useState(true); var loading = s2[0], setLoading = s2[1];

      useEffect(function() {
        // 現在のセッションを確認
        supabase.auth.getSession().then(function(result) {
          setUser(result.data.session?.user || null);
          setLoading(false);
        });

        // 認証状態の変更を監視
        var subscription = supabase.auth.onAuthStateChange(function(_event, session) {
          setUser(session?.user || null);
        });

        return function() { subscription.data.subscription.unsubscribe(); };
      }, []);

      async function handleSignOut() {
        await supabase.auth.signOut();
      }

      // 読み込み中
      if (loading) {
        return html`
          <div class="min-h-screen flex items-center justify-center bg-gray-50">
            <div class="text-center">
              <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
              <p class="text-gray-600">読み込み中...</p>
            </div>
          </div>
        `;
      }

      // 未ログインの場合は認証画面を表示
      if (!user) {
        return html`<${AuthForm} />`;
      }

      // ログイン済みの場合は漫画生成アプリを表示
      return html`<${MangaApp} user=${user} onSignOut=${handleSignOut} />`;
    }

    // アプリをレンダリング
    render(html`<${App} />`, document.getElementById('app'));
  </script>
</body>
</html>
